<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="别在机会来临之时却无法握住。">
<meta property="og:type" content="website">
<meta property="og:title" content="John 的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="John 的技术博客">
<meta property="og:description" content="别在机会来临之时却无法握住。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="John 的技术博客">
<meta name="twitter:description" content="别在机会来临之时却无法握住。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>John 的技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John 的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/接口安全及签名规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/17/接口安全及签名规范/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-17T15:49:58+08:00">
                2019-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口安全及签名规范"><a href="#接口安全及签名规范" class="headerlink" title="接口安全及签名规范"></a>接口安全及签名规范</h1><h2 id="0-敏感数据本地加密后传输"><a href="#0-敏感数据本地加密后传输" class="headerlink" title="0.敏感数据本地加密后传输"></a>0.敏感数据本地加密后传输</h2><ul>
<li>数据安全:所有敏感数据如：登录密码、支付密码、手机号等在传输过程之中需要加密。</li>
<li>加密方式:HMAC+MD5+key 。</li>
<li>流程<ul>
<li>用户注册：在用户注册的时候判断用户是否允许注册，若允许注册则由服务器产生加密所使用的 key并保存到数据库中，在客户端保存该 key(可以加密也可以明文)。调用注册接口进行注册时，传递加密后的密码，由服务器存入数据库。</li>
<li>用户登录：在用户登录的时候，若是客户端不存在 key，则需要向服务端获取。</li>
<li>一个用户一个 key，该 key 推荐定时更新。</li>
<li>若某客户端无可以，此时需要向服务端获取。但是服务端允许直接返回 key，而是服务端请求具有 key 的另外客户端询问是否授权。此时服务器需要维护一个用户所登录的设备集合。</li>
</ul>
</li>
</ul>
<p>类似用户密码、手机号等敏感数据在传输过程中需要加密，加密的方式选择RSA/SHA1/MD5/HMAC在敏感数据加盐后再加密用以保护。</p>
<h2 id="1-使用-token-标志用户"><a href="#1-使用-token-标志用户" class="headerlink" title="1.使用 token 标志用户"></a>1.使用 token 标志用户</h2><p>api_token、user_token、refresh_token</p>
<h2 id="2-网络请求添加签名"><a href="#2-网络请求添加签名" class="headerlink" title="2.网络请求添加签名"></a>2.网络请求添加签名</h2><ul>
<li><p>请求头</p>
<ul>
<li>sign : 密文主体</li>
<li>timestamp : 当前时间戳整形</li>
<li>nonce : 随机字符串用于签名和防重放</li>
<li>Authorization : 用户 token</li>
</ul>
<p>签名规则</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">nonce:</span>需要为不能重复的字符串，需要定义加密方法，例如<span class="symbol">:nonce=</span>时间戳+设备ip地址+设备 Mac 地址然后 MD5。服务端需要保存此值用于之后防重放(多个网络请求需要保存多个值，需要保存成集合)。请注意该集合需要被清理，具体的清理时间。这里我们使用nonce=MD5(时间戳+UUID)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.首先在请求头添加 sign 字段用于表示该网络请求所发起的时间。</span><br><span class="line"><span class="number">2</span>.将网络请求参数根据参数名的 ASCII 码从大到小进行排序，再使用 URL键值对的形式(即key1=value1&amp;key2=value2…请注意此处当参数为最后一个的时候将不需要拼接&amp;符号)拼接成字符串StringA。</span><br><span class="line"><span class="number">3</span>.在 StringA 最后拼接上 timestamp 、 token 、 nonce，接着对拼接之后的字符串进行 MD5/RSA 加密，再将加密结果得到的字符串全部转为大写并存入sign字段。</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 注意：POST/</span>GET请求需要使用相同的加密方法。 </span><br><span class="line">/<span class="regexp">/ 若是参数中存在字典或者数组，请将其转换为 JSON 字符串再进行拼接</span></span><br></pre></td></tr></table></figure>
<p>范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ulr:				https://baidu.com/login</span><br><span class="line">params:				</span><br><span class="line">&#123;</span><br><span class="line">    latitude = 121.58299,</span><br><span class="line">    longitude = 29.85297,</span><br><span class="line">    udi = 55;</span><br><span class="line">&#125;</span><br><span class="line">timestamp:			1547867244</span><br><span class="line">nonce:				a4e9512cc607eaf9e95d15fdb56e0ece	</span><br><span class="line">StringA:		    latitude=121.58299&amp;longitude=29.85297&amp;udi=55</span><br><span class="line"></span><br><span class="line">拼接后字符串:			</span><br><span class="line">latitude=121.58299&amp;longitude=29.85297&amp;udi=551547867794eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIgb2a6675a75ed2d0b39da3e2f03805790</span><br><span class="line"></span><br><span class="line">Authorization:		</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIg</span><br><span class="line"></span><br><span class="line">sign:	规则:sign = MD5((StringA + timestamp + token + nonce).upperCase())	</span><br><span class="line">sign:   13541B7DBF0092DE2D9DDEF4009DBE74</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-接口防重放功能"><a href="#3-接口防重放功能" class="headerlink" title="3.接口防重放功能"></a>3.接口防重放功能</h2><ol>
<li>使用物理防火墙。例如：指定某请求在给定时间内允许访问几次</li>
<li>代码防重放(timestamp + nonce)<ol>
<li>在用户登录或者更新用户信息的时候使用某一接口(例如：ClienPing)获取 App 本地时间和服务器时间的差值，服务器需要保存此差值，用于防重放功能。</li>
<li>在签名验证步骤之前判断用户发起的网络请求中的时间戳和服务器的时间戳差值(例如有效时间是一分钟)是否在允许的范围之内。</li>
<li>在判断时间有效之后需要服务端需要在用户的 nonce 集合中判断是否已经存在了该值，如果存在则拒绝该网络请求。否则记录该 nonce 值，并允许该请求。</li>
<li>清理 nonce 集合，需要定制nonce集合清理的时机(可以选择一定大小和一定时机清理)，例如:若有效时间设置为一分钟，则判断某用户某一次请求时其 nonce 集合的最后修改时间是否早于该请求一分钟，若是，则删除集合，否则继续添加。</li>
</ol>
</li>
</ol>
<h2 id="4-接口验证不通过返回状态码"><a href="#4-接口验证不通过返回状态码" class="headerlink" title="4.接口验证不通过返回状态码"></a>4.接口验证不通过返回状态码</h2><ul>
<li>401</li>
<li>402</li>
<li>403</li>
</ul>
<blockquote>
<p>参考资料：</p>
<p>深入了解Token认证的来龙去脉:<a href="https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/01/iOS-CALayer-教程-入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/iOS-CALayer-教程-入门/" itemprop="url">iOS CALayer 教程:入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T16:18:16+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-CALayer-教程-入门"><a href="#iOS-CALayer-教程-入门" class="headerlink" title="iOS CALayer 教程:入门"></a>iOS CALayer 教程:入门</h1><blockquote>
<p>原文链接:<a href="https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started" target="_blank" rel="noopener">CALayer Tutorial for iOS: Getting Started</a></p>
<p>作者:Michael Ciurus</p>
<p>最近在研究 CALayer 和 UIView 之间的联系和区别，看完这篇文章介绍的 <code>CALayer</code>子类和其使用介绍的挺详细的，所以翻译一下这篇文章。</p>
<p>译者注：原文中 layer 可能在文章中被翻译为’图层’，corner radius 被翻译为’角半径’</p>
</blockquote>
<p>在这篇教程中，你将会学习到什么是<code>CALayer</code>，并且能看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p><strong>升级说明</strong>：本教程已由<a href="https://www.raywenderlich.com/u/michalciurus" target="_blank" rel="noopener">Michael Ciurus</a>升级到 iOS11，Swift4和Xcode9。原教程作者是<a href="https://www.raywenderlich.com/u/scotteg" target="_blank" rel="noopener">Scott Gardner</a>。</p>
<p>可能正如你知道的，在 iOS App 中你看到的所有的东西都是View。有button view,table view,slider view,甚至是包含其他视图的父视图。</p>
<p>你可能不知道的是每个在 iOS 中的每个 view都由一个另外的名为图层——<code>CALayer</code>的类提供支持。</p>
<p>在本篇教程中，你将会了解到什么是<code>CALayer</code>并且知道它是如何工作的。你同样也会看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p>本文章的前提是你已经了解了作为 iOS App 的基础和Swift，包括使用 storyboard构建 UI。</p>
<blockquote>
<p><strong>注意：</strong>如果你并不擅长这个，别担心。我们关于这个主题我们有多个教程和书籍，例如 <a href="http://www.raywenderlich.com/77176/learn-to-code-iOS-apps-with-swift-tutorial-4" target="_blank" rel="noopener">Learn to Code iOS Apps with Swift</a>and <a href="http://www.raywenderlich.com/store/iOS-apprentice" target="_blank" rel="noopener">The iOS Apprentice</a>。</p>
</blockquote>
<h2 id="CALayer-和UIView-有何关系？"><a href="#CALayer-和UIView-有何关系？" class="headerlink" title="CALayer 和UIView 有何关系？"></a>CALayer 和UIView 有何关系？</h2><p><code>UIView</code>处理非常多的事情，例如：布局、响应事件等。有一点很有意思，<code>UIView</code>并不直接参与处理绘制或者动画，而是<code>UIView</code>将其交付给它的兄弟——<code>Core Animation</code>来处理。事实上<code>UIView</code>是<code>CALayer</code>的包装容器。当你在一个<code>UIView</code>上设置了<code>bounds</code>之后，视图只是将<code>bounds</code>设置在了其背后的<code>CALayer</code>上。如果你在<code>UIView</code>上调用了<code>layoutIfNeed</code>方法，该方法会转发给其根<code>CALayer</code>。每个<code>UIView</code>都有一个能够拥有<code>subLayers</code>的根<code>CALayer</code>。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/uiview.png" alt="uiview"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>最简单的了解<code>layer</code>是什么的途径就是在看它们在实际运用中的效果。你将会从一个简单的项目开始使用layers。<a href="https://koenig-media.raywenderlich.com/uploads/2017/08/LayerStarterProject.zip" target="_blank" rel="noopener">下载</a>这个简单的只在中心插入了视图的 App。</p>
<p>在 <strong>ViewController.swift</strong>中使用如下代码替换其内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> viewForLayer: <span class="type">UIView</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> layer: <span class="type">CALayer</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> viewForLayer.layer</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setUpLayer()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setUpLayer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    layer.backgroundColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line">    layer.borderWidth = <span class="number">100.0</span></span><br><span class="line">    layer.borderColor = <span class="type">UIColor</span>.red.cgColor</span><br><span class="line">    layer.shadowOpacity = <span class="number">0.7</span></span><br><span class="line">    layer.shadowRadius = <span class="number">10.0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如之前提到的，每一个<code>UIView</code>都有一个<code>layer</code>与其关联，并且你能够是用<code>.layer</code>获得它。以上代码的第一件事情就是创建了一个名为<code>layer</code>的计算属性来访问<code>viewForLayer</code>的<code>layer</code>。</p>
<p>代码中同样也调用了<code>setUpLayer()</code>方法，用以设置图层的一些属性——阴影、蓝色的背景颜色和巨大的红色边框颜色。等会你将会学习到更多关于<code>setUpLayer()</code>方法，但是现在首先要做的事情是构建并运行iOS模拟器来查看你自己定义的图层。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-1-281x500.png" alt=""></p>
<p>只使用了短短几句代码就实现了酷炫的效果，对吧？并且由于所有的<code>view</code>都是由<code>layer</code>提供支持的，所以你可以在你的 app 中对所有的视图做如上操作。</p>
<h2 id="基础CALayer属性"><a href="#基础CALayer属性" class="headerlink" title="基础CALayer属性"></a>基础<code>CALayer</code>属性</h2><p><code>CALayer</code>拥有一些列的方法让你可以自定义外观。回想一下你刚才所做的事情:</p>
<ul>
<li>将其图层的背景颜色从默认的无颜色设置为蓝色。</li>
<li>改变图层的<code>borderWidth</code>从默认的0设置为100来赋予其边框。</li>
<li>改变其边框颜色，从默认的黑色改变为红色。</li>
<li>并且最后，改变其<code>shadowOpacity</code>属性，从默认的0(完全透明)到0.7，来赋予其阴影。仅这一点就会使得阴影显示出来，然后下一步增加了其阴影半径，从默认的3到10。</li>
</ul>
<p>这还只是您可以在<code>CALayer</code>设置的部分属性。接下来我们继续尝试两个属性。在<code>setUpLayer()</code>的底部添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>在<code>CALayer</code>中的<code>contents</code>属性允许你使用图片设置其内容，所以在这里你是使用名为’star’的图片设置了其图层内容。该图片已经在初始项目中提供。</p>
<p>构建并运行然后花点时间欣赏一下那令人惊叹的艺术品:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-2-179x320.png" alt="CALayerPlayground-2"></p>
<p>为什么五角星会在被定位在中心呢？这是因为你将<code>kCAGravityCenter</code>设置到了其属性<code>contentsGravity</code>上。正如你所预料的那样，你同样能够将其位置设置为顶部、顶部偏右、右侧、底部偏右、底部、底部偏左、左侧和顶部偏左。</p>
<h2 id="改变图层的外观"><a href="#改变图层的外观" class="headerlink" title="改变图层的外观"></a>改变图层的外观</h2><p>初始项目包含了<code>tap</code>和<code>pinch</code>的手势识别器。</p>
<p>将<code>tapGestureRecognized(_:)</code>方法改变为如下所示:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">  layer.shadowOpacity = layer.shadowOpacity == <span class="number">0.7</span> ? <span class="number">0.0</span> : <span class="number">0.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码将告诉<code>viewForLayer</code>的图层当视图响应<code>tap</code>时，将其图层的阴影不透明在0和0.7之间切换。</p>
<p>你可能会问，那视图呢？当然你也可以覆写<code>CALayer</code>的 <code>hitTest(_:)</code> 来做同样的事情，并且你也会在本文的后面看到这种方式。但是<code>hitTest</code>是图层能做的全部了，因为图层无法响应手势识别器。这就是为什么你在视图中创建<code>tap</code>的手势识别器。</p>
<p>现在将 <code>pinchGestureRecognized(_:)</code> 中的实现改为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UIPinchGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> offset: <span class="type">CGFloat</span> = sender.scale &lt; <span class="number">1</span> ? <span class="number">5.0</span> : -<span class="number">5.0</span></span><br><span class="line">  <span class="keyword">let</span> oldFrame = layer.frame</span><br><span class="line">  <span class="keyword">let</span> oldOrigin = oldFrame.origin</span><br><span class="line">  <span class="keyword">let</span> newOrigin = <span class="type">CGPoint</span>(x: oldOrigin.x + offset, y: oldOrigin.y + offset)</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="type">CGSize</span>(width: oldFrame.width + (offset * -<span class="number">2.0</span>), height: oldFrame.height + (offset * -<span class="number">2.0</span>))</span><br><span class="line">  <span class="keyword">let</span> newFrame = <span class="type">CGRect</span>(origin: newOrigin, size: newSize)</span><br><span class="line">  <span class="keyword">if</span> newFrame.width &gt;= <span class="number">100.0</span> &amp;&amp; newFrame.width &lt;= <span class="number">300.0</span> &#123;</span><br><span class="line">    layer.borderWidth -= offset</span><br><span class="line">    layer.cornerRadius += (offset / <span class="number">2.0</span>)</span><br><span class="line">    layer.frame = newFrame</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你基于用户的<code>pinch</code>来创建一个正的或者一个负的偏移量，并接着调整图层<code>frame</code>中的大小、边框宽度和边框的角半径。</p>
<p>一个图层(layer)的角半径默认是零，这就意味着此时是标准的拥有90度角的正方形。可以通过增加角半径来创建圆角。想要将正方形转变为圆形？只需要将其角半径设置为其宽度的一半。</p>
<p>构建并运行，然后尝试点击和捏合你的视图:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-3-179x320.png" alt="CALayerPlayground-3"></p>
<p>只需要一点润色你就可以自己拥有一个非常漂亮的头像。</p>
<h2 id="很棒的CALayer-之旅"><a href="#很棒的CALayer-之旅" class="headerlink" title="很棒的CALayer 之旅"></a>很棒的CALayer 之旅</h2><p><code>CALayer</code>不仅仅只拥有方法和属性可以设置，它还有一系列具有特有方法和属性子类。</p>
<p>有什么比查看教程更好的符合raywenderlich.com风格的方式来了解这些很棒的 API 呢?</p>
<p>在本文接下来的部分中，你需要如下准备：</p>
<ul>
<li><a href="https://github.com/raywenderlich/LayerPlayer" target="_blank" rel="noopener">The Layer Player Source Code</a></li>
<li><a href="http://bit.ly/AppStoreLayerPlayer" target="_blank" rel="noopener">The Layer Player App (可选)</a></li>
</ul>
<p>这是一个拥有你将在本文中学习到的十种不同<code>CALayer</code>子类范例的便捷 App。这里有许多很棒的例子：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/starter-480x285.png" alt="Layer Player screenshots"></p>
<p>当你浏览下面每个例子之前，我建议你先使用一下上述<code>CALayer</code>的 App，并且看看源码。在本文的剩余部分中，你并不需要真正写任何代码，所以请放心坐下并防松阅读。</p>
<h2 id="范例1：CALayer"><a href="#范例1：CALayer" class="headerlink" title="范例1：CALayer"></a>范例1：CALayer</h2><p>你已经看过了使用<code>CALayer</code>的例子，并且设置了一些它的属性。</p>
<p>以下还有一些之前尚未提到过的内容：</p>
<ul>
<li><strong>图层能够拥有子图层</strong>。就类似视图能够拥有子视图一样，图层能够拥有子图层。你可以使用这个来创建一些酷炫的效果。</li>
<li><strong>图层属性具有动画效果</strong>。当你改变了图层的属性，默认情况下会对其进行动画处理。你也可以根据自己的时间来自定义动画行为。</li>
<li><strong>图层是轻量级的</strong>。图层相较于视图来说更加轻量级，因此它能够带来更高的性能。</li>
<li><strong>图层拥有大量使用的属性</strong>。你已经在之前看到过其部分的属性了，现在让我们看更多属性。</li>
</ul>
<p>你接下来将会看到<code>CALayer</code>的一个完整属性列表，其中有部分你还尚未接触过，它们非常方便！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layer = <span class="type">CALayer</span>()</span><br><span class="line">layer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>正如你之前看到的，上述代码是创建了一个<code>CALayer</code>实例，并将<code>someView</code>的<code>bounds</code>赋值给它。接着将图片设置为图层的内容并将其在图层内居中。请注意，此处使用的是底层Quartz图片数据(<code>CGImage</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer.magnificationFilter = kCAFilterLinear</span><br><span class="line">layer.isGeometryFlipped = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当图片通过<code>contentsGravity</code>被扩大尺寸时使用如上滤镜，这可以用于调整尺寸(调整大小、调整宽高比和调整宽高比填充)和位置(例如：中心、顶部、顶部偏右、右侧等)。</p>
<p>如上的变更并不具有动画效果，并且如果<code>isGeometryFlipped</code>并非被设置为<code>true</code>。那么该图层的几何位置和阴影将会上下颠倒。我们接着继续：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layer.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">11</span>/<span class="number">255.0</span>, green: <span class="number">86</span>/<span class="number">255.0</span>, blue: <span class="number">14</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">layer.opacity = <span class="number">1.0</span></span><br><span class="line">layer.isHidden = <span class="literal">false</span></span><br><span class="line">layer.masksToBounds = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>你将图层的颜色设置为Ray 最喜欢的绿色阴影。这能够使得图层不透明并且可见。同时，你告诉图层不要遮罩其本身内容，这意味着当其本身尺寸大小小于其内容(五角星形图片)时，图片不会被裁剪。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layer.cornerRadius = <span class="number">100.0</span></span><br><span class="line">layer.borderWidth = <span class="number">12.0</span></span><br><span class="line">layer.borderColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>将图层的角半径设置为其宽度的一半，这样来创建出一个圆形带边框的图层。请注意这里的图层颜色将被设置为Quartz颜色的引用(<code>CGColor</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layer.shadowOpacity = <span class="number">0.75</span></span><br><span class="line">layer.shadowOffset = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">layer.shadowRadius = <span class="number">3.0</span></span><br><span class="line">someView.layer.addSublayer(layer)</span><br></pre></td></tr></table></figure>
<p>你创建了阴影并且将<code>shouldRasterize</code>属性设置为<code>true</code>(稍后讨论)，接着将图层添加到视图层次中。</p>
<p>最终结果如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayer-250x250.png" alt="CALayer"></p>
<p><code>CALayer</code>拥有两个额外属性，这两个额外的属性可以提升其性能：<code>shouldRasterize</code> 和 <code>drawsAsynchronously</code>。</p>
<p><code>shouldRasterize</code>默认是<code>false</code>，并且当其被设置为<code>true</code>的时候能够提升性能，这是因为图层只需要被渲染一次。这对于那些在屏幕内具有动画效果但是外观不会改变的对象十分有用。</p>
<p><code>drawsAsynchronously</code>与<code>shouldRasterize</code>洽洽相反。<code>shouldRasterize</code>默认也是<code>false</code>。当图层内容被反复绘制的时候将该属性设置为<code>true</code>将会提升性能，例如当你使用<code>emitter layer</code>持续渲染具有动效的粒子。(在随后的<code>CAEmitterLayer</code>例子中可以看到)</p>
<blockquote>
<p>一句忠告：在设置<code>drawsAsynchronously</code>或<code>shouldRasterize</code>之前先考虑其意义。对比在开启和关闭这两项特性时的性能，这样你能够真正了解这两项性能是否真的能够带来性能上的提升。如果误用，可能会导致性能急转直下。</p>
</blockquote>
<p>现在将你的注意力转移到<strong>Layer Player</strong>上。它包含了多个控件来控制<code>CALayer</code>的属性:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/1-180x320.png" alt="CALayer properties"></p>
<p>试试调节各个控件吧，这是一个很棒的方式来让你了解<code>CALayer</code>到底能够做什么！</p>
<blockquote>
<p>注意：图层并不是响应连的一部分，因此他们并不向视图一样响应直接响应手势和触摸，正如你在CALayerPlayground项目中看到的那样。</p>
<p>然而你可以对其进行点击测试(hit test)，正如你在<code>CATransformLayer</code>实例代码中看到的那样。当你看到<code>CAReplicatorLayer</code>时你将会看到你同样可以对图层的动画进行自定义。</p>
</blockquote>
<h2 id="范例2：CAScrollLayer"><a href="#范例2：CAScrollLayer" class="headerlink" title="范例2：CAScrollLayer"></a>范例2：CAScrollLayer</h2><p><code>CAScrollLayer</code>展示一个可滑动图层的一部分。<code>CAScrollLayer</code>相当基础并且无法直接响应触摸或者用户点击事件来检测可滑动视图的边界，但是它可以做一些有意思的事情，例如：可以防止滑动超出其边界范围。</p>
<p><code>UIScrollView</code>并未使用<code>CAScrollLayer</code>来完成其工作，而是使用直接改变其图层边界的方式代替它。</p>
<p><code>CAScrollLayer</code>能够将其本身设置为横向或者纵向滑动或者横向纵向均可滑动，并且可以通过编程的方式来告诉它滑动到一个特殊的点或者区域。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> scrollingViewLayer: <span class="type">CAScrollLayer</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> scrollingView.layer <span class="keyword">as</span>! <span class="type">CAScrollLayer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  scrollingViewLayer.scrollMode = kCAScrollBoth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">panRecognized</span><span class="params">(<span class="number">_</span> sender: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newPoint = scrollingView.bounds.origin</span><br><span class="line">  newPoint.x -= sender.translation(<span class="keyword">in</span>: scrollingView).x</span><br><span class="line">  newPoint.y -= sender.translation(<span class="keyword">in</span>: scrollingView).y</span><br><span class="line">  sender.setTranslation(<span class="type">CGPoint</span>.zero, <span class="keyword">in</span>: scrollingView)</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  scrollingViewLayer.scroll(to: newPoint)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> sender.state == .ended &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollingViewLayer.scroll(to: <span class="type">CGPoint</span>.zero)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中：</p>
<ol>
<li>计算属性用于返回<code>scrollingView</code>的图层为<code>CAScrollLayer</code>。</li>
<li>将滑动模式设置为横向纵向均可滑动。</li>
<li>当滑动手势被识别，一个新的点会在此时被创建出来并且滑动图层会以使用<code>UIView</code>动画的方式滑动到这个点。注意<code>scroll(to:)</code>并没有自带动画效果。</li>
</ol>
<p>Layer Player演示了一个拥有图片视图的CAScrollLayer，这个图片视图带有一个图片，这个图片超过其滑动视图的边界。当你运行上述代码，并移动视图，其结果应该如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAScrollLayer.gif" alt="CAScrollLayer"></p>
<p> Layer Player包含了两个控件用以锁定水平滑动或者竖直滑动。</p>
<p>以下是一些当你使用(或者不适用)<code>CAScrollLayer</code>的经验之谈:</p>
<ul>
<li>当你想要一些轻量级并且只能通过代码来滑动，那么不妨考虑一下使用<code>CAScrollLayer</code>。</li>
<li>如果你想要用户能够滑动，可能使用<code>UIScrollView</code>更好。想要了解更多这方面的东西，请点击我们的课程 <a href="http://www.raywenderlich.com/93104/video-tutorial-swift-scroll-view-school-part-0-introduction" target="_blank" rel="noopener">18-part video tutorial series</a>。</li>
<li>如果你是滑动一个非常巨大的图片，请考虑使用<code>CATiledLayer</code>(稍后将会带来讲解)。</li>
</ul>
<h2 id="范例3：CATextLayer"><a href="#范例3：CATextLayer" class="headerlink" title="范例3：CATextLayer"></a>范例3：CATextLayer</h2><p><code>CATextLayer</code>能够简单并且快速渲染普通字符串或者属性字符串(attributed strings)。和<code>UILabel</code>不同的是<code>CATextLayer</code>无法拥有<code>UIFont</code>，它只能使用<code>CTFontRef</code>或者<code>CGFontRef</code>。</p>
<p>在如下的代码块中，能够改变字体、字体大小、颜色、对其方式、文字截断方式以及其动画效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> textLayer = <span class="type">CATextLayer</span>()</span><br><span class="line">textLayer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="type">String</span>(</span><br><span class="line">  repeating: <span class="string">"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit </span></span><br><span class="line"><span class="string">             congue dictum. "</span>,</span><br><span class="line">  <span class="built_in">count</span>: <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">textLayer.string = string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">textLayer.font = <span class="type">CTFontCreateWithName</span>(fontName, fontSize, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">textLayer.foregroundColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line">textLayer.alignmentMode = kCAAlignmentLeft</span><br><span class="line">textLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">someView.layer.addSublayer(textLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码说明:</p>
<ol>
<li>创建<code>CATextLayer</code>实例并且将<code>someView</code>的视图边界设置给它。</li>
<li>创建重复的字符串文本，并将其设置给文字图层(text layer)。</li>
<li>创建字体，并将字体设置到文字图层上(text layer)。</li>
<li>设置图层能够换行并且左对齐，(你可以对其方式设置为自然对其方式、右对齐、居中、和文本对其)并且将其<code>contentsScale</code>到屏幕，然后将它加入视图层。</li>
</ol>
<p>所有图层类，不止是<code>CATextLayer</code>渲染放大因子(scale factor)默认为1。当图层依附于视图(view)时，图层会自动拥有一个适应当前屏幕所最合适的放大因子。你需要手动为图层创建确切的<code>contentsScale</code>，或者他们的放大因素为1，但是会在 retain 屏幕上显示像素化。</p>
<p>如果添加到方形<code>UIView</code>中，被创建出的文字图层可能会如下所示:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-250x250.png" alt="CATextLayer"></p>
<p>当你希望使用省略号代表被剪切的文本时，截断(Truncation)是你可以使用的非常合适的设置。截断(Truncation)默认是无(none)，但是你也可以设置为起始位置、中间位置和结束位置：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-StartTruncation.png.png" alt="起始位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-MiddleTruncation.png.png" alt="中间位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-EndTruncation.png" alt="结束位置"></p>
<p>Layer Player拥有多个控件来改变<code>CATextLayer</code>的值:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/3-180x320.png" alt="CATextLayer 属性"></p>
<h2 id="范例4：AVPlayerLayer"><a href="#范例4：AVPlayerLayer" class="headerlink" title="范例4：AVPlayerLayer"></a>范例4：AVPlayerLayer</h2><p><code>AVPlayerLayer</code>向AVFoundation中添加了一个美妙好用的图层。它拥有一个<code>AVPlayer</code>来播放音视频多媒体文件(<code>AVPlayerItem</code>)。如下是一个创建<code>AVPlayerLayer</code>的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player: <span class="type">AVPlayer</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> playerLayer = <span class="type">AVPlayerLayer</span>()</span><br><span class="line">  playerLayer.frame = someView.bounds</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"someVideo"</span>, withExtension: <span class="string">"m4v"</span>)</span><br><span class="line">  player = <span class="type">AVPlayer</span>(url: url!)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  player.actionAtItemEnd = .<span class="keyword">none</span></span><br><span class="line">  playerLayer.player = player</span><br><span class="line">  someView.layer.addSublayer(playerLayer)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                         selector: #selector(playerDidReachEnd),</span><br><span class="line">                                         name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                         object: player.currentItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的接要点如下:</p>
<ul>
<li>创建一个新的播放图层(playerLayer)并设置其边界</li>
<li>使用音视频文件创建播放器(player)</li>
<li>告诉播放器当其播放停止时不做任何额外的操作。额外的操作包括有暂停或播放下一个音视频文件，如果情况允许的话。</li>
<li>注册一个多媒体播放器停止播放的通知。(并将控制器作为观察者在控制器析构的时候移除)。</li>
</ul>
<p>接着，当播放按钮被点击时，播放音视频文件并且设置按钮标题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">playButtonTapped</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> playButton.titleLabel?.text == <span class="string">"Play"</span> &#123;</span><br><span class="line">    player.play()</span><br><span class="line">    playButton.setTitle(<span class="string">"Pause"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    player.pause()</span><br><span class="line">    playButton.setTitle(<span class="string">"Play"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在播放器播放结束时将播放光标移动到初始位置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">playerDidReachEnd</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> playerItem = notification.object <span class="keyword">as</span>! <span class="type">AVPlayerItem</span></span><br><span class="line">  playerItem.seek(to: kCMTimeZero, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意这里只是一个让你入门的简单示例，在真实的项目中，通常不建议切换按钮的标题。</p>
<p>使用以上代码创建出来的 <code>AVPlayerLayer</code> 和他的 <code>AVPlayer</code> 将会以<code>AVPlayerItem</code>实例的第一帧呈现，类似如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AVPlayerItem.png" alt="AVPlayerItem"></p>
<p><code>AVPlayerLayer</code>有两个额外的属性:</p>
<ul>
<li><code>videoGravity</code>设置视频显示的尺寸调整行为。</li>
<li><code>isReadyForDisplay</code>检查视频是否已经可以准备播放。</li>
</ul>
<p>从另一方面来说，<code>AVPlayer</code>拥有很多额外的属性和方法。其中有一个需要<code>rate</code>属性需要注意，它表示播放速率以0~1的速率为例。0表示暂停，1表示以正常速率播放(1x)。</p>
<p>然而设置<code>rate</code>同样表示以此速率开始播放。换句话来说调用<code>pause()</code>和将<code>rate</code>设置为0所做的事一样，同理调用<code>play()</code>和设置<code>rate</code>为1也是一致的。</p>
<p>那关于快进、慢放或者是倒放操作呢？ <code>AVPlayer</code> 也能让你满意。将<code>rate</code>设置为任何大于1的数等同于要求播放器将播放速率设置为其值乘以正常速度，举个例子，将<code>rate</code>设置为2表示两倍速。</p>
<p>正如你假设的那样，将<code>rate</code>设置为负值表示将播放速率乘以正常速度倒放。</p>
<p>在以任意非正常速度播放之前会有适当的变量来验证该<code>AVPlayerItem</code>是否能够以该速度播放:</p>
<ul>
<li><code>canPlayFastForward</code>：对于任何大于1的数。</li>
<li><code>canPlaySlowForward</code>：对于任何大于0小于且不包含1的数。</li>
<li><code>canPlayReverse</code>：对于-1。</li>
<li><code>canPlaySlowReverse</code>：大于-1小于0但不包含0。</li>
<li><code>canPlayFastReverse</code>：对于任意小于-1的数。</li>
</ul>
<p>大多数视频通常可以以各种快进速度播放，但它们倒放的典型情况较少。和其他范例一样，Layer Player同样也有播放控件:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/4-180x320.png" alt="AVPlayerLayer properties"></p>
<h2 id="范例5：CAGradientLayer"><a href="#范例5：CAGradientLayer" class="headerlink" title="范例5：CAGradientLayer"></a>范例5：CAGradientLayer</h2><p><code>CAGradientLay</code>让混合两种或更多颜色变得简单，使其更加合适作为背景。为了配置它，你需要设置一个<code>CGColor</code>的数组和用以指定CAGradientLayer起始位置和结束位置的<code>startPoint</code>、<code>endPoint</code>。</p>
<p>请注意 <code>startPoint</code> 和<code>endPoint</code>并不是一个确切的点。相反它们声明于单位坐标空间上，并且它们会在图层被绘制的时候去映射图层边界。也就是说x 的值为1的时候表示该点位于图层的右边缘，y 的值为1的时候表示该点位于图层的底部边缘。</p>
<p><code>CAGradientLayer</code>有一个<code>type</code>字段，虽然<code>kCAGradientLayerAxial</code>是唯一的选项，它能线性的过渡数组中的颜色。</p>
<p>这意味着如果你在<code>startPoint</code>和<code>endPoint</code>绘制一条线(A)，渐变将沿着垂直于A的假想线（B）发生，沿B的所有点都是相同的颜色：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AxialGradientLayerType.gif" alt="AxialGradientLayerType"></p>
<p>另外，你也可以使用0~1之间的数来控制<code>locations</code>，这些值可以指定<code>colors</code>数组中使用的下一个颜色的相对相对起始位置。</p>
<p>如果忘了指定<code>locations</code>属性，则其默认是均分图层用以使用相同的间隔显示颜色。如果<code>locations</code>被设置了，则其数量必须要与<code>colors</code>数量一致，否则会发生一些预想不到的问题。</p>
<p>如下是创建渐变图层的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cgColor</span><span class="params">(red: CGFloat, green: CGFloat, blue: CGFloat)</span></span> -&gt; <span class="type">CGColor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UIColor</span>(red: red/<span class="number">255.0</span>, green: green/<span class="number">255.0</span>, blue: blue/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame = someView.bounds</span><br><span class="line">gradientLayer.colors = [cgColor(red: <span class="number">209.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">102.0</span>, blue: <span class="number">34.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">218.0</span>, blue: <span class="number">33.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">221.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">17.0</span>, green: <span class="number">51.0</span>, blue: <span class="number">204.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">34.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">102.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">68.0</span>)]</span><br><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">1</span>)</span><br><span class="line">someView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码中，你创建了一个渐变图层并将<code>someView</code>的bounds 设置给它，然后设置其<code>colors</code>数组，设置起始位置和结束位置，接着将其加到视图的图层层次结构上。以下是可能出现的结果:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAGradientLayer-250x250.png" alt="CAGradientLayer"></p>
<p>多么五彩缤纷啊！你能够编写一只蝴蝶，从应用程序中飘出来搔痒你的鼻子。 ：]</p>
<p>Layer Player提供了多个用于更改起始位置、结束位置、颜色和位置。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/5-180x320.png" alt="AVPlayerLayer controls"></p>
<h2 id="范例6：CAReplicatorLayer"><a href="#范例6：CAReplicatorLayer" class="headerlink" title="范例6：CAReplicatorLayer"></a>范例6：CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>会在指定时间内以指定次数复制某个图层，这可以让你你创建一些酷炫的效果。</p>
<p>每个图层副本都可以改变其颜色和位置，并且可以延迟创建它们用以为replicator layer创建一些动画效果。为了赋予replicator layer 3D 效果还可以给设置他们的深度(Depth)。以下是一个例子:</p>
<p>首先创建一个<code>CAReplicatorLayer</code>并将<code>someView</code>的大小位置赋值给它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> replicatorLayer = <span class="type">CAReplicatorLayer</span>()</span><br><span class="line">replicatorLayer.frame = someView.bounds</span><br></pre></td></tr></table></figure>
<p>接下来设置复制器图层(replicator layer)所拷贝的副本的数量(instanceCount)并延时绘制。同样的要将复制器图层(replicator layer)设置为2D 模式(<code>preservesDepth = false</code>)然后将实例颜色设置为白色。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicatorLayer.instanceCount = <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceDelay = <span class="type">CFTimeInterval</span>(<span class="number">1</span> / <span class="number">30.0</span>)</span><br><span class="line">replicatorLayer.preservesDepth = <span class="literal">false</span></span><br><span class="line">replicatorLayer.instanceColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>下一步将对每个连续的副本实例设置其各自的红色/绿色/蓝色的颜色偏移量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicatorLayer.instanceRedOffset = <span class="number">0.0</span></span><br><span class="line">replicatorLayer.instanceGreenOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceBlueOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceAlphaOffset = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>上述属性每个默认都是零，并且这样赋值的方式有效的在所有实例中保留了其颜色的值。然而在这个例子中，最初的实例颜色被设置为白色，这意味着红色/绿色/蓝色均已为1。因此设置绿色和蓝色的值为负值，这允许红色更加突出。类似的将alpha 偏移设置到连续拷贝副本的 alpha 属性。</p>
<p>在这之后创建一个形变(transform)来以圆形旋转每个连续的拷贝副本。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> angle = <span class="type">Float</span>(<span class="type">Double</span>.pi * <span class="number">2.0</span>) / <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceTransform = <span class="type">CATransform3DMakeRotation</span>(<span class="type">CGFloat</span>(angle), <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">someView.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure>
<p>然后为拷贝器图层(replicator layer)创建一个可使用的图层实例并将其设置上大小和边界(frame)，因此首个被创建的实例将会被绘制到横坐标的中心(center x)并且位于<code>someView</code>边界的顶部(top of <code>someView</code>‘s bounds)。同样的设置图层实例的颜色并将创建的图层实例添加到复制器图层(replicator layer)上:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instanceLayer = <span class="type">CALayer</span>()</span><br><span class="line"><span class="keyword">let</span> layerWidth: <span class="type">CGFloat</span> = <span class="number">10.0</span></span><br><span class="line"><span class="keyword">let</span> midX = someView.bounds.midX - layerWidth / <span class="number">2.0</span></span><br><span class="line">instanceLayer.frame = <span class="type">CGRect</span>(x: midX, y: <span class="number">0.0</span>, width: layerWidth, height: layerWidth * <span class="number">3.0</span>)</span><br><span class="line">instanceLayer.backgroundColor = <span class="type">UIColor</span>.white.cgColor</span><br><span class="line">replicatorLayer.addSublayer(instanceLayer)</span><br></pre></td></tr></table></figure>
<p>现在创建以不透明度从1到0的渐隐动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fadeAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"opacity"</span>)</span><br><span class="line">fadeAnimation.fromValue = <span class="number">1.0</span></span><br><span class="line">fadeAnimation.toValue = <span class="number">0.0</span></span><br><span class="line">fadeAnimation.duration = <span class="number">1</span></span><br><span class="line">fadeAnimation.repeatCount = <span class="type">Float</span>.greatestFiniteMagnitude</span><br></pre></td></tr></table></figure>
<p>并在最后设置图层实例的不透明度为0，这样能让图层实例在被绘制和设置其颜色透明度钱前保持透明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instanceLayer.opacity = <span class="number">0.0</span></span><br><span class="line">instanceLayer.add(fadeAnimation, forKey: <span class="string">"FadeAnimation"</span>)</span><br></pre></td></tr></table></figure>
<p>如下是上述代码的结果：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAReplicatorLayer.gif" alt="CAReplicatorLayer"></p>
<p>Layer Player包含了很多控件可以让你来操纵<code>CAReplicatorLayer</code>的大部分属性。</p>
<h2 id="范例7：CATiledLayer"><a href="#范例7：CATiledLayer" class="headerlink" title="范例7：CATiledLayer"></a>范例7：CATiledLayer</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/MTQQ-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/MTQQ-介绍/" itemprop="url">MTQQ 介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T14:51:14+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文出处:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
<p>本文只为自己快速查看资料，原文出处如上。</p>
</blockquote>
<h2 id="2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet"><a href="#2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet" class="headerlink" title="2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet"></a>2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet</h2><h5 id="MQTT控制报文的结构"><a href="#MQTT控制报文的结构" class="headerlink" title="MQTT控制报文的结构"></a>MQTT控制报文的结构</h5><table>
<thead>
<tr>
<th>Fixed header</th>
<th>固定报头，所有控制报文都包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable header</td>
<td>可变报头，部分控制报文包含</td>
</tr>
<tr>
<td>Payload</td>
<td>有效载荷，部分控制报文包含</td>
</tr>
</tbody>
</table>
<h2 id="2-2-固定报头-Fixed-header"><a href="#2-2-固定报头-Fixed-header" class="headerlink" title="2.2 固定报头 Fixed header"></a>2.2 固定报头 Fixed header</h2><h5 id="固定报头的格式"><a href="#固定报头的格式" class="headerlink" title="固定报头的格式"></a>固定报头的格式</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT控制报文的类型</center></td><br>        <td colspan="4"><center>用于指定控制报文类型的标志位</center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type"><a href="#2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type" class="headerlink" title="2.2.1 MQTT控制报文的类型 MQTT Control Packet type"></a>2.2.1 MQTT控制报文的类型 MQTT Control Packet type</h3><h5 id="控制报文的类型"><a href="#控制报文的类型" class="headerlink" title="控制报文的类型"></a>控制报文的类型</h5><table>
<thead>
<tr>
<th><strong>名字</strong></th>
<th><strong>值</strong></th>
<th><strong>报文流动方向</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>0</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
<tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端请求连接服务端</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>服务端到客户端</td>
<td style="text-align:left">连接报文确认</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布消息</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 1消息发布收到确认</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布收到（保证交付第一步）</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布释放（保证交付第二步）</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 2消息发布完成（保证交互第三步）</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端订阅请求</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>服务端到客户端</td>
<td style="text-align:left">订阅请求报文确认</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端取消订阅请求</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>服务端到客户端</td>
<td style="text-align:left">取消订阅报文确认</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>客户端到服务端</td>
<td style="text-align:left">心跳请求</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>服务端到客户端</td>
<td style="text-align:left">心跳响应</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端断开连接</td>
</tr>
<tr>
<td>Reserved</td>
<td>15</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-标志-Flags"><a href="#2-2-2-标志-Flags" class="headerlink" title="2.2.2 标志 Flags"></a>2.2.2 标志 Flags</h3><h5 id="标志位-Flag-Bits"><a href="#标志位-Flag-Bits" class="headerlink" title="标志位 Flag Bits"></a>标志位 Flag Bits</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>固定报头标志</strong></th>
<th><strong>Bit 3</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>Bit 0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>CONNACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>Used in MQTT 3.1.1</td>
<td>DUP1</td>
<td>QoS2</td>
<td>QoS2</td>
<td>RETAIN3</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREC</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREL</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>SUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li>DUP1 =控制报文的重复分发标志</li>
<li>QoS2 = PUBLISH报文的服务质量等级</li>
<li>RETAIN3 = PUBLISH报文的保留标志</li>
</ul>
<h3 id="2-2-3-剩余长度-Remaining-Length"><a href="#2-2-3-剩余长度-Remaining-Length" class="headerlink" title="2.2.3 剩余长度 Remaining Length"></a>2.2.3 剩余长度 Remaining Length</h3><p>剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
<p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个<em>延续位（continuation bit）</em>。剩余长度字段最大4个字节。</p>
<blockquote>
<p>  <strong>非规范评注</strong></p>
<p>例如，十进制数64会被编码为一个字节，数值是64，十六进制表示为0x40,。十进制数字321(=65+2*128)被编码为两个字节，最低有效位在前。第一个字节是 65+128=193。注意最高位为1表示后面至少还有一个字节。第二个字节是2。</p>
<p><strong>非规范评注</strong></p>
<p>这允许应用发送最大256MB(268,435,455)大小的控制报文。这个数值在报文中的表示是：0xFF,0xFF,0xFF,0x7F。</p>
<p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.4_Size" target="_blank" rel="noopener">表格 2.4剩余长度字段的大小</a>展示了剩余长度字段所表示的值随字节增长。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 最大四个字节，所以理论上最大控制报文大小是2^(4*8) = 4.294967e+9 bits，并且剩余长度字段最大四个字节，若是数据到达四个字节，则低字节的最高位则应该为0,此时表示无更多字节，所以实际上是(2^(4*8) /</span> <span class="number">2</span> = <span class="number">256</span> MB)。</span><br></pre></td></tr></table></figure>
<h5 id="表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field"><a href="#表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field" class="headerlink" title="表格 2.4剩余长度字段的大小 Size of Remaining Length field"></a>表格 2.4剩余长度字段的大小 Size of Remaining Length field</h5><table>
<thead>
<tr>
<th><strong>字节数</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0 (0x00)</td>
<td>127 (0x7F)</td>
</tr>
<tr>
<td>2</td>
<td>128 (0x80, 0x01)</td>
<td>16 383 (0xFF, 0x7F)</td>
</tr>
<tr>
<td>3</td>
<td>16 384 (0x80, 0x80, 0x01)</td>
<td>2 097 151 (0xFF, 0xFF, 0x7F)</td>
</tr>
<tr>
<td>4</td>
<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>
<td>268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td>
</tr>
</tbody>
</table>
<p>分别表示（每个字节的低7位用于编码数据，最高位是标志位）：</p>
<ul>
<li>1个字节时，从0(0x00)到127(0x7f)</li>
<li>2个字节时，从128(0x80,0x01)到16383(0Xff,0x7f)</li>
<li>3个字节时，从16384(0x80,0x80,0x01)到2097151(0xFF,0xFF,0x7F)</li>
<li>4个字节时，从2097152(0x80,0x80,0x80,0x01)到268435455(0xFF,0xFF,0xFF,0x7F)</li>
</ul>
<h2 id="2-3-可变报头-Variable-header"><a href="#2-3-可变报头-Variable-header" class="headerlink" title="2.3 可变报头 Variable header"></a>2.3 可变报头 Variable header</h2><h5 id="图例-2-3-报文标识符字节-Packet-Identifier-bytes"><a href="#图例-2-3-报文标识符字节-Packet-Identifier-bytes" class="headerlink" title="图例 2.3 -报文标识符字节 Packet Identifier bytes"></a>图例 2.3 -报文标识符字节 Packet Identifier bytes</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>报文标识符 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>报文标识符 LSB</td>
</tr>
</tbody>
</table>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。</p>
<p>SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文<strong>必须</strong>包含一个非零的16位报文标识符（Packet Identifier）[MQTT-2.3.1-1]。客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符 [MQTT-2.3.1-2]。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它<strong>必须</strong>使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT-2.3.1-3]。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端 [MQTT-2.3.1-4]。</p>
<p>QoS等于0的PUBLISH报文<strong>不能</strong>包含报文标识符 [MQTT-2.3.1-5]。</p>
<p>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT-2.3.1-6]。类似地，SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT-2.3.1-7]。</p>
<h5 id="表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier"><a href="#表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier" class="headerlink" title="表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier"></a>表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>报文标识符字段</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>不需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>需要（如果QoS &gt; 0）</td>
</tr>
<tr>
<td>PUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<p>客户端和服务端彼此独立地分配报文标识符。因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端发送标识符为0x1234的PUBLISH报文，它有可能会在收到那个报文的PUBACK之前，先收到服务端发送的另一个不同的但是报文标识符也为0x1234的PUBLISH报文。</p>
<table>
<thead>
<tr>
<th>Client</th>
<th>Server</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUBLISH</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBLISH</td>
<td>Packet Identifier=0x1234</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBACK</td>
<td>Packet Identifier=0x1234</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="2-4-有效载荷-Payload"><a href="#2-4-有效载荷-Payload" class="headerlink" title="2.4 有效载荷 Payload"></a>2.4 有效载荷 Payload</h2><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷，这将在第三章论述。对于<strong>PUBLISH来说有效载荷就是应用消息</strong>。</p>
<h5 id="表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload"><a href="#表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload" class="headerlink" title="表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload"></a>表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>有效载荷</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>可选</td>
</tr>
<tr>
<td>PUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>不需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<h2 id="3-1-CONNECT-–-连接服务端"><a href="#3-1-CONNECT-–-连接服务端" class="headerlink" title="3.1 CONNECT – 连接服务端"></a>3.1 CONNECT – 连接服务端</h2><p>客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1]。</p>
<p>在一个网络连接上，客户端只能发送一次CONNECT报文。服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接 [MQTT-3.1.0-2]。有关错误处理的信息请查看4.8节。</p>
<p><strong>有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will主题，Will消息，用户名和密码</strong>。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。</p>
<h3 id="3-1-1-固定报头-Fixed-header"><a href="#3-1-1-固定报头-Fixed-header" class="headerlink" title="3.1.1 固定报头 Fixed header"></a>3.1.1 固定报头 Fixed header</h3><h5 id="图例-3-1-–CONNECT报文的固定报头"><a href="#图例-3-1-–CONNECT报文的固定报头" class="headerlink" title="图例 3.1 –CONNECT报文的固定报头"></a>图例 3.1 –CONNECT报文的固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="剩余长度字段"><a href="#剩余长度字段" class="headerlink" title="剩余长度字段"></a><strong>剩余长度字段</strong></h3><p>剩余长度等于<strong>可变报头的长度（10字节</strong>）加上有效载荷的长度。编码方式见 2.2.3节的说明。</p>
<h3 id="3-1-2-可变报头-Variable-header"><a href="#3-1-2-可变报头-Variable-header" class="headerlink" title="3.1.2 可变报头 Variable header"></a>3.1.2 可变报头 Variable header</h3><p>CONNECT报文的可变报头按下列次序包含四个字段：<strong>协议名（Protocol Name），协议级别（Protocol Level），连接标志（Connect Flags）和保持连接（Keep Alive）</strong>。</p>
<h4 id="协议名-Protocol-Name"><a href="#协议名-Protocol-Name" class="headerlink" title="协议名 Protocol Name"></a>协议名 Protocol Name</h4><h5 id="图例-3-2-协议名字节构成"><a href="#图例-3-2-协议名字节构成" class="headerlink" title="图例 3.2 -协议名字节构成"></a>图例 3.2 -协议名字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>长度 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>长度 LSB (4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘M’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘Q’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 6</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>协议名是表示协议名 <em>MQTT</em> 的UTF-8编码的字符串。MQTT规范的后续版本不会改变这个字符串的偏移和长度。</p>
<h4 id="协议级别-Protocol-Level"><a href="#协议级别-Protocol-Level" class="headerlink" title="协议级别 Protocol Level"></a>协议级别 Protocol Level</h4><h5 id="图例-3-3-Protocol-Level-byte协议级别字节构成"><a href="#图例-3-3-Protocol-Level-byte协议级别字节构成" class="headerlink" title="图例 3.3 - Protocol Level byte协议级别字节构成"></a>图例 3.3 - Protocol Level byte协议级别字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议级别</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 7</td>
<td>Level(4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="连接标志-Connect-Flags"><a href="#连接标志-Connect-Flags" class="headerlink" title="连接标志 Connect Flags"></a>连接标志 Connect Flags</h4><p>连接标志字节包含一些用于指定MQTT连接行为的参数。它还指出有效载荷中的字段是否存在。</p>
<h5 id="图例-3-4-连接标志位"><a href="#图例-3-4-连接标志位" class="headerlink" title="图例 3.4 -连接标志位"></a>图例 3.4 -连接标志位</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0304.png" alt="figure-3.4"></p>
<p>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接 [MQTT-3.1.2-3]。</p>
<h4 id="清理会话-Clean-Session"><a href="#清理会话-Clean-Session" class="headerlink" title="清理会话 Clean Session"></a>清理会话 Clean Session</h4><p><strong>位置：</strong>连接标志字节的第1位</p>
<p>这个二进制位指定了会话状态的处理方式。</p>
<p>客户端和服务端可以保存会话状态，以支持跨网络连接的可靠消息传输。这个标志位用于控制会话状态的生存时间。</p>
<p>如果清理会话（CleanSession）标志被设置为0，服务端<strong>必须</strong>基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端<strong>必须</strong>创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端<strong>必须</strong>保存会话信息 [MQTT-3.1.2-4]。当清理会话标志为0的会话连接断开之后，服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.1.2-5]。服务端也<strong>可以</strong>保存满足相同条件的QoS 0级别的消息。</p>
<p>如果清理会话（CleanSession）标志被设置为1，客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用 [MQTT-3.1.2-6]。</p>
<p>客户端的会话状态包括：</p>
<ul>
<li>已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息</li>
<li>已从服务端接收，但是还没有完成确认的QoS 2级别的消息。</li>
</ul>
<p>服务端的会话状态包括：</p>
<ul>
<li>会话是否存在，即使会话状态的其它部分都是空。</li>
<li>客户端的订阅信息。</li>
<li>已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。</li>
<li>即将传输给客户端的QoS 1和QoS 2级别的消息。</li>
<li>已从客户端接收，但是还没有完成确认的QoS 2级别的消息。</li>
<li>可选，准备发送给客户端的QoS 0级别的消息。</li>
</ul>
<p>保留消息不是服务端会话状态的一部分，会话终止时<strong>不能</strong>删除保留消息 [MQTT-3.1.2.7]。</p>
<p>有关状态存储的限制和细节见第 4.1节。</p>
<p>当清理会话标志被设置为1时，客户端和服务端的状态删除不需要是原子操作。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>为了确保在发生故障时状态的一致性，客户端应该使用会话状态标志1重复请求连接，直到连接成功。</p>
<p><strong>非规范评注</strong></p>
<p>一般来说，客户端连接时总是将清理会话标志设置为0或1，并且不交替使用两种值。这个选择取决于具体的应用。清理会话标志设置为1的客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS 1或 QoS 2级别，同时将清理会话标志设置为0。</p>
<p><strong>非规范评注</strong></p>
<p>清理会话标志0的客户端连接时，它请求服务端在连接断开后保留它的MQTT会话状态。如果打算在之后的某个时间点重连到这个服务端，客户端连接应该只使用清理会话标志0。当客户端决定之后不再使用这个会话时，应该将清理会话标志设置为1最后再连接一次，然后断开连接。</p>
</blockquote>
<h4 id="遗嘱标志-Will-Flag"><a href="#遗嘱标志-Will-Flag" class="headerlink" title="遗嘱标志 Will Flag"></a>遗嘱标志 Will Flag</h4><p><strong>位置：</strong>连接标志的第2位。</p>
<p>遗嘱标志（Will Flag）被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端<strong>必须</strong>发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 [MQTT-3.1.2-8] 。</p>
<p>遗嘱消息发布的条件，包括但不限于：</p>
<ul>
<li>服务端检测到了一个I/O错误或者网络故障。</li>
<li>客户端在保持连接（Keep Alive）的时间内未能通讯。</li>
<li>客户端没有先发送DISCONNECT报文直接关闭了网络连接。</li>
<li>由于协议错误服务端关闭了网络连接。</li>
</ul>
<p>如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-9]。</p>
<p>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文，遗嘱消息就<strong>必须</strong>从存储的会话状态中移除 [MQTT-3.1.2-10]。</p>
<p>如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0，并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-11]。</p>
<p>如果遗嘱标志被设置为0，网络连接断开时，<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.2-12]。</p>
<p>服务端应该迅速发布遗嘱消息。在关机或故障的情况下，服务端可以推迟遗嘱消息的发布直到之后的重启。如果发生了这种情况，在服务器故障和遗嘱消息被发布之间可能会有一个延迟。</p>
<h4 id="遗嘱QoS-Will-QoS"><a href="#遗嘱QoS-Will-QoS" class="headerlink" title="遗嘱QoS Will QoS"></a>遗嘱QoS Will QoS</h4><p><strong>位置：</strong>连接标志的第4和第3位。</p>
<p>这两位用于指定发布遗嘱消息时使用的服务质量等级。</p>
<p>如果遗嘱标志被设置为0，遗嘱QoS也<strong>必须</strong>设置为0(0x00) [MQTT-3.1.2-13]。</p>
<p>如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值<strong>不能</strong>等于3 [MQTT-3.1.2-14]。</p>
<h4 id="遗嘱保留-Will-Retain"><a href="#遗嘱保留-Will-Retain" class="headerlink" title="遗嘱保留 Will Retain"></a>遗嘱保留 Will Retain</h4><p><strong>位置：</strong>连接标志的第5位。</p>
<p>如果遗嘱消息被发布时需要保留，需要指定这一位的值。</p>
<p>如果遗嘱标志被设置为0，遗嘱保留（Will Retain）标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-15]。</p>
<p>如果遗嘱标志被设置为1：</p>
<ul>
<li>如果遗嘱保留被设置为0，服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布 [MQTT-3.1.2-16]。</li>
<li>如果遗嘱保留被设置为1，服务端<strong>必须</strong>将遗嘱消息当作保留消息发布 [MQTT-3.1.2-17]。</li>
</ul>
<h4 id="用户名标志-User-Name-Flag"><a href="#用户名标志-User-Name-Flag" class="headerlink" title="用户名标志 User Name Flag"></a>用户名标志 User Name Flag</h4><p><strong>位置：</strong>连接标志的第7位。</p>
<p>如果用户名（User Name）标志被设置为0，有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-18]。</p>
<p>如果用户名（User Name）标志被设置为1，有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-19]。</p>
<h4 id="密码标志-Password-Flag"><a href="#密码标志-Password-Flag" class="headerlink" title="密码标志 Password Flag"></a>密码标志 Password Flag</h4><p><strong>位置：</strong>连接标志的第6位。</p>
<p>如果密码（Password）标志被设置为0，有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-20]。</p>
<p>如果密码（Password）标志被设置为1，有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-21]。</p>
<p>如果用户名标志被设置为0，密码标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-22]。</p>
<h4 id="保持连接-Keep-Alive"><a href="#保持连接-Keep-Alive" class="headerlink" title="保持连接 Keep Alive"></a>保持连接 Keep Alive</h4><h5 id="图例-3-5保持连接字节"><a href="#图例-3-5保持连接字节" class="headerlink" title="图例 3.5保持连接字节"></a>图例 3.5保持连接字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 9</td>
<td>保持连接 Keep Alive MSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 10</td>
<td>保持连接 Keep Alive LSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端<strong>必须</strong>发送一个PINGREQ报文 [MQTT-3.1.2-23]。</p>
<p>不管保持连接的值是多少，客户端任何时候都可以发送PINGREQ报文，并且使用PINGRESP报文判断网络和服务端的活动状态。</p>
<p>如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它<strong>必须</strong>断开客户端的网络连接，认为网络连接已断开 [MQTT-3.1.2-24]。</p>
<p>客户端发送了PINGREQ报文之后，如果在合理的时间内仍没有收到PINGRESP报文，它<strong>应该</strong>关闭到服务端的网络连接。</p>
<p>保持连接的值为零表示关闭保持连接功能。这意味着，服务端不需要因为客户端不活跃而断开连接。注意：不管保持连接的值是多少，任何时候，只要服务端认为客户端是不活跃或无响应的，可以断开客户端的连接。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>保持连接的实际值是由应用指定的，一般是几分钟。允许的最大值是18小时12分15秒。</p>
</blockquote>
<h4 id="可变报头非规范示例"><a href="#可变报头非规范示例" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><h5 id="图例-3-6-可变报头非规范示例"><a href="#图例-3-6-可变报头非规范示例" class="headerlink" title="图例 3.6 -可变报头非规范示例"></a>图例 3.6 -可变报头非规范示例</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0306.png" alt="figure-3.6"></p>
<h3 id="3-1-3-有效载荷-Payload"><a href="#3-1-3-有效载荷-Payload" class="headerlink" title="3.1.3 有效载荷 Payload"></a>3.1.3 有效载荷 Payload</h3><p>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，<strong>必须</strong>按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 [MQTT-3.1.3-1]。</p>
<h4 id="客户端标识符-Client-Identifier"><a href="#客户端标识符-Client-Identifier" class="headerlink" title="客户端标识符 Client Identifier"></a>客户端标识符 Client Identifier</h4><p>服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 [MQTT-3.1.3-2]。</p>
<p>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段 [MQTT-3.1.3-3]。</p>
<p>客户端标识符<strong>必须</strong>是1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-4]。</p>
<p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字）[MQTT-3.1.3-5]。</p>
<p>服务端<strong>可以</strong>允许编码后超过23个字节的客户端标识符 (ClientId)。服务端<strong>可以</strong>允许包含不是上面列表字符的客户端标识符 (ClientId)。</p>
<p>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文 [MQTT-3.1.3-6]。</p>
<p>如果客户端提供了一个零字节的客户端标识符，它<strong>必须</strong>同时将清理会话标志设置为1 [MQTT-3.1.3-7]。</p>
<p>如果客户端提供的ClientId为零字节且清理会话标志为0，服务端<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-8]。</p>
<p>如果服务端拒绝了这个ClientId，它<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-9]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端实现可以提供一个方便的方法用于生成随机的ClientId。当清理会话标志被设置为0时应该主动放弃使用这种方法。</p>
</blockquote>
<h4 id="遗嘱主题-Will-Topic"><a href="#遗嘱主题-Will-Topic" class="headerlink" title="遗嘱主题 Will Topic"></a>遗嘱主题 Will Topic</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱主题（Will Topic）。遗嘱主题<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-10]。</p>
<h4 id="遗嘱消息-Will-Message"><a href="#遗嘱消息-Will-Message" class="headerlink" title="遗嘱消息 Will Message"></a>遗嘱消息 Will Message</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱消息。遗嘱消息定义了将被发布到遗嘱主题的应用消息，见3.1.2.5节的描述。这个字段由一个两字节的长度和遗嘱消息的有效载荷组成，表示为零字节或多个字节序列。长度给出了跟在后面的数据的字节数，不包含长度字段本身占用的两个字节。</p>
<p>遗嘱消息被发布到遗嘱主题时，它的有效载荷只包含这个字段的数据部分，不包含开头的两个长度字节。</p>
<h4 id="用户名-User-Name"><a href="#用户名-User-Name" class="headerlink" title="用户名 User Name"></a>用户名 User Name</h4><p>如果用户名（User Name）标志被设置为1，有效载荷的下一个字段就是它。用户名<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-11]。服务端可以将它用于身份验证和授权。</p>
<h4 id="密码-Password"><a href="#密码-Password" class="headerlink" title="密码 Password"></a>密码 Password</h4><p>如果密码（Password）标志被设置为1，有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段，长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节），后面跟着0到65535字节的二进制数据。</p>
<h5 id="图例-3-7-密码字节"><a href="#图例-3-7-密码字节" class="headerlink" title="图例 3.7 - 密码字节"></a>图例 3.7 - 密码字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>数据长度 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>数据长度 LSB</td>
</tr>
<tr>
<td>byte 3 ….</td>
<td>如果长度大于0，这里就是数据部分</td>
</tr>
</tbody>
</table>
<h3 id="3-1-4-响应-Response"><a href="#3-1-4-响应-Response" class="headerlink" title="3.1.4 响应 Response"></a>3.1.4 响应 Response</h3><p>注意：服务器可以在同一个TCP端口或其他网络端点上支持多种协议（包括本协议的早期版本）。如果服务器确定协议是MQTT 3.1.1，那么它按照下面的方法验证连接请求。</p>
<ol>
<li>网络连接建立后，如果服务端在合理的时间内没有收到CONNECT报文，服务端<strong>应该</strong>关闭这个连接。</li>
<li>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接 [MQTT-3.1.4-1]。</li>
<li>服务端<strong>可以</strong>检查CONNECT报文的内容是不是满足任何进一步的限制，<strong>可以</strong>执行身份验证和授权检查。如果任何一项检查没通过，按照3.2节的描述，它<strong>应该</strong>发送一个适当的、返回码非零的CONNACK响应，并且<strong>必须</strong>关闭这个网络连接。</li>
</ol>
<p>如果验证成功，服务端会执行下列步骤。</p>
<ol>
<li>如果ClientId表明客户端已经连接到这个服务端，那么服务端<strong>必须</strong>断开原有的客户端连接 [MQTT-3.1.4-2]。</li>
<li>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程 [MQTT-3.1.4-3]。</li>
<li>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT-3.1.4-4]。</li>
<li>开始消息分发和保持连接状态监视。</li>
</ol>
<p>允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文。如果服务端拒绝了CONNECT，它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据 [MQTT-3.1.4-5]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端通常会等待一个CONNACK报文。然而客户端有权在收到CONNACK之前发送控制报文，由于不需要维持连接状态，这可以简化客户端的实现。</p>
</blockquote>
<h2 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h2><p>服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK [MQTT-3.2.0-1]。</p>
<p>如果客户端在合理的时间内没有收到服务端的CONNACK报文，客户端<strong>应该</strong>关闭网络连接。<em>合理</em> 的时间取决于应用的类型和通信基础设施。</p>
<h3 id="3-2-1-固定报头"><a href="#3-2-1-固定报头" class="headerlink" title="3.2.1 固定报头"></a>3.2.1 固定报头</h3><p>固定报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_Figure_3.8_%E2%80%93" target="_blank" rel="noopener">图例 3.8 – CONNACK 报文固定报头</a> 的描述。</p>
<h5 id="图例-3-8-–-CONNACK-报文固定报头"><a href="#图例-3-8-–-CONNACK-报文固定报头" class="headerlink" title="图例 3.8 – CONNACK 报文固定报头"></a>图例 3.8 – CONNACK 报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<p><strong>剩余长度字段</strong>表示可变报头的长度。对于CONNACK报文这个值等于2。</p>
<h3 id="3-2-2-可变报头"><a href="#3-2-2-可变报头" class="headerlink" title="3.2.2 可变报头"></a>3.2.2 可变报头</h3><p>可变报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E5%9B%BE%E4%BE%8B_3.9_%E2%80%93CONNACK%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4" target="_blank" rel="noopener">图例 3.9 –CONNACK报文可变报头</a> 的描述。</p>
<h5 id="图例-3-9-–CONNACK报文可变报头"><a href="#图例-3-9-–CONNACK报文可变报头" class="headerlink" title="图例 3.9 –CONNACK报文可变报头"></a>图例 3.9 –CONNACK报文可变报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>连接确认标志</center></td><br>        <td colspan="7"><center>Reserved 保留位</center></td><br>        <td colspan="1"><center>SP1</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>     <tr><br>        <td colspan="9"><center>连接返回码</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br></table>

<h4 id="连接确认标志-Connect-Acknowledge-Flags"><a href="#连接确认标志-Connect-Acknowledge-Flags" class="headerlink" title="连接确认标志 Connect Acknowledge Flags"></a>连接确认标志 Connect Acknowledge Flags</h4><p>第1个字节是 <em>连接确认标志</em>，位7-1是保留位且<strong>必须</strong>设置为0。 第0 (SP)位 是当前会话（Session Present）标志。</p>
<h4 id="当前会话-Session-Present"><a href="#当前会话-Session-Present" class="headerlink" title="当前会话 Session Present"></a>当前会话 Session Present</h4><p><strong>位置：</strong>连接确认标志的第0位。</p>
<p>如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还<strong>必须</strong>将CONNACK报文中的当前会话设置（Session Present）标志为0 [MQTT-3.2.2-1]。</p>
<p>如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1 [MQTT-3.2.2-2]。如果服务端没有已保存的会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0 [MQTT-3.2.2-3]。</p>
<p>当前会话标志使服务端和客户端在是否有已存储的会话状态上保持一致。</p>
<p>一旦完成了会话的初始化设置，已经保存会话状态的客户端将期望服务端维持它存储的会话状态。如果客户端从服务端收到的当前的值与预期的不同，客户端可以选择继续这个会话或者断开连接。客户端可以丢弃客户端和服务端之间的会话状态，方法是，断开连接，将清理会话标志设置为1，再次连接，然后再次断开连接。</p>
<p>如果服务端发送了一个包含非零返回码的CONNACK报文，它<strong>必须</strong>将当前会话标志设置为0 [MQTT-3.2.2-4]。</p>
<h4 id="连接返回码-Connect-Return-code"><a href="#连接返回码-Connect-Return-code" class="headerlink" title="连接返回码 Connect Return code"></a>连接返回码 Connect Return code</h4><p><strong>位置：</strong>可变报头的第2个字节。</p>
<p>连接返回码字段使用一个字节的无符号值，在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E8%A1%A8%E6%A0%BC_3.1_%E2%80%93%E8%BF%9E%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%A0%81%E7%9A%84%E5%80%BC" target="_blank" rel="noopener">表格 3.1 –连接返回码的值</a> 中列出。如果服务端收到一个合法的CONNECT报文，但出于某些原因无法处理它，服务端应该尝试发送一个包含非零返回码（表格中的某一个）的CONNACK报文。如果服务端发送了一个包含非零返回码的CONNACK报文，那么它<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-5].。</p>
<h5 id="表格-3-1-–连接返回码的值"><a href="#表格-3-1-–连接返回码的值" class="headerlink" title="表格 3.1 –连接返回码的值"></a>表格 3.1 –连接返回码的值</h5><table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>返回码响应</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x00连接已接受</td>
<td>连接已被服务端接受</td>
</tr>
<tr>
<td>1</td>
<td>0x01连接已拒绝，不支持的协议版本</td>
<td>服务端不支持客户端请求的MQTT协议级别</td>
</tr>
<tr>
<td>2</td>
<td>0x02连接已拒绝，不合格的客户端标识符</td>
<td>客户端标识符是正确的UTF-8编码，但服务端不允许使用</td>
</tr>
<tr>
<td>3</td>
<td>0x03连接已拒绝，服务端不可用</td>
<td>网络连接已建立，但MQTT服务不可用</td>
</tr>
<tr>
<td>4</td>
<td>0x04连接已拒绝，无效的用户名或密码</td>
<td>用户名或密码的数据格式无效</td>
</tr>
<tr>
<td>5</td>
<td>0x05连接已拒绝，未授权</td>
<td>客户端未被授权连接到此服务器</td>
</tr>
<tr>
<td>6-255</td>
<td></td>
<td>保留</td>
</tr>
</tbody>
</table>
<p>如果认为上表中的所有连接返回码都不太合适，那么服务端<strong>必须</strong>关闭网络连接，不需要发送CONNACK报文 [MQTT-3.2.2-6]。</p>
<h3 id="3-2-3-有效载荷"><a href="#3-2-3-有效载荷" class="headerlink" title="3.2.3 有效载荷"></a>3.2.3 有效载荷</h3><p>CONNACK报文没有有效载荷。</p>
<h2 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h2><p>PUBLISH控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。</p>
<h3 id="3-3-1-固定报头"><a href="#3-3-1-固定报头" class="headerlink" title="3.3.1 固定报头"></a>3.3.1 固定报头</h3><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E5%9B%BE%E4%BE%8B_3.10_%E2%80%93" target="_blank" rel="noopener">图例 3.10 – PUBLISH报文固定报头</a>描述了固定报头的格式</p>
<h5 id="图例-3-10-–-PUBLISH报文固定报头"><a href="#图例-3-10-–-PUBLISH报文固定报头" class="headerlink" title="图例 3.10 – PUBLISH报文固定报头"></a>图例 3.10 – PUBLISH报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>    <tr><br>        <td><center><strong>byte 1</strong></center></td><br>        <td colspan="4"><center>MQTT控制报文类型 (3)</center></td><br>        <td><center><strong>DUP</strong></center></td><br>        <td><center><strong>QoS-H</strong></center></td><br>        <td><center><strong>QoS-</strong></center></td><br>        <td><center><strong>RETAIN</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h4 id="重发标志-DUP"><a href="#重发标志-DUP" class="headerlink" title="重发标志 DUP"></a>重发标志 DUP</h4><p><strong>位置：</strong>第1个字节，第3位</p>
<p>如果DUP标志被设置为0，表示这是客户端或服务端第一次请求发送这个PUBLISH报文。如果DUP标志被设置为1，表示这可能是一个早前报文请求的重发。</p>
<p>客户端或服务端请求重发一个PUBLISH报文时，<strong>必须</strong>将DUP标志设置为1 [MQTT-3.3.1.-1].。对于QoS 0的消息，DUP标志<strong>必须</strong>设置为0 [MQTT-3.3.1-2]。</p>
<p>服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值<strong>必须</strong>单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定 [MQTT-3.3.1-3]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>接收者收到一个DUP标志为1的控制报文时，不能假设它看到了一个这个报文之前的一个副本。</p>
<p><strong>非规范评注</strong></p>
<p>需要特别指出的是，DUP标志关注的是控制报文本身，与它包含的应用消息无关。当使用QoS 1时，客户端可能会收到一个DUP标志为0的PUBLISH报文，这个报文包含一个它之前收到过的应用消息的副本，但是用的是不同的报文标识符。 2.3.1节提供了有关报文标识符的更多信息。</p>
</blockquote>
<h4 id="服务质量等级-QoS"><a href="#服务质量等级-QoS" class="headerlink" title="服务质量等级 QoS"></a>服务质量等级 QoS</h4><p><strong>位置：</strong>第1个字节，第2-1位。</p>
<p>这个字段表示应用消息分发的服务质量等级保证。服务质量等级在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.2_-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">表格 3.2 -服务质量定义</a> 中列出。</p>
<h5 id="表格-3-2-服务质量定义"><a href="#表格-3-2-服务质量定义" class="headerlink" title="表格 3.2 -服务质量定义"></a>表格 3.2 -服务质量定义</h5><table>
<thead>
<tr>
<th><strong>QoS值</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>最多分发一次</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>至少分发一次</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>只分发一次</td>
</tr>
<tr>
<td>-</td>
<td>1</td>
<td>1</td>
<td>保留位</td>
</tr>
</tbody>
</table>
<p>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它<strong>必须</strong>关闭网络连接 [MQTT-3.3.1-4]。</p>
<h4 id="保留标志-RETAIN"><a href="#保留标志-RETAIN" class="headerlink" title="保留标志 RETAIN"></a>保留标志 RETAIN</h4><p><strong>位置：</strong>第1个字节，第0位。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它<strong>必须</strong>被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它<strong>必须</strong>丢弃之前为那个主题保留的任何消息。它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 [MQTT-3.3.1-7]。有关存储状态的更多信息见 4.1节。</p>
<p>服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它<strong>必须</strong>将报文的保留标志设为1 [MQTT-3.3.1-8]。当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端<strong>必须</strong>将保留标志设为0，不管它收到的这个消息中保留标志的值是多少 [MQTT-3.3.1-9]。</p>
<p>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT-3.3.1-10]。<em>当作正常</em> 意思是现存的客户端收到的消息中保留标志未被设置。服务端<strong>不能</strong>存储零字节的保留消息 [MQTT-3.3.1-11]。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息 [MQTT-3.3.1-12]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>对于发布者不定期发送状态消息这个场景，保留消息很有用。新的订阅者将会收到最近的状态。</p>
</blockquote>
<p><strong>剩余长度字段</strong></p>
<p>等于可变报头的长度加上有效载荷的长度。</p>
<h3 id="3-3-2-可变报头"><a href="#3-3-2-可变报头" class="headerlink" title="3.3.2 可变报头"></a>3.3.2 可变报头</h3><p>可变报头按顺序包含主题名和报文标识符。</p>
<h4 id="主题名-Topic-Name"><a href="#主题名-Topic-Name" class="headerlink" title="主题名 Topic Name"></a>主题名 Topic Name</h4><p>主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。</p>
<p>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段。它<strong>必须</strong>是 1.5.3节定义的UTF-8编码的字符串 [MQTT-3.3.2-1]。</p>
<p>PUBLISH报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2]。</p>
<p>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器（根据 4.7节定义的匹配过程）[MQTT-3.3.2-3]。</p>
<h4 id="报文标识符-Packet-Identifier"><a href="#报文标识符-Packet-Identifier" class="headerlink" title="报文标识符 Packet Identifier"></a>报文标识符 Packet Identifier</h4><p>只有当QoS等级是1或2时，报文标识符（Packet Identifier）字段才能出现在PUBLISH报文中。2.3.1节提供了有关报文标识符的更多信息。</p>
<h4 id="可变报头非规范示例-1"><a href="#可变报头非规范示例-1" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_Figure_3.11_-" target="_blank" rel="noopener">图例 3.11 – PUBLISH报文可变报头非规范示例</a> 举例说明了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.3_-" target="_blank" rel="noopener">表格 3.3 - PUBLISH报文非规范示例</a> 中简要描述的PUBLISH报文的可变报头。</p>
<h5 id="表格-3-3-PUBLISH报文非规范示例"><a href="#表格-3-3-PUBLISH报文非规范示例" class="headerlink" title="表格 3.3 - PUBLISH报文非规范示例"></a>表格 3.3 - PUBLISH报文非规范示例</h5><table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>主题名</td>
<td>a/b</td>
</tr>
<tr>
<td>报文标识符</td>
<td>10</td>
</tr>
</tbody>
</table>
<h5 id="图例-3-11-–-PUBLISH报文可变报头非规范示例"><a href="#图例-3-11-–-PUBLISH报文可变报头非规范示例" class="headerlink" title="图例 3.11 – PUBLISH报文可变报头非规范示例"></a>图例 3.11 – PUBLISH报文可变报头非规范示例</h5><table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Topic Name 主题名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>Length MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>Length LSB (3)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘a’ (0x61)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘/’ (0x2F)</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘b’ (0x62)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>报文标识符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 6</td>
<td>报文标识符 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 7</td>
<td>报文标识符 LSB (10)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>示例中的主题名为 “a/b”，长度等于3，报文标识符为 “10”</p>
<h3 id="3-3-3-有效载荷"><a href="#3-3-3-有效载荷" class="headerlink" title="3.3.3 有效载荷"></a>3.3.3 有效载荷</h3><p>有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的。</p>
<h3 id="3-3-4-响应"><a href="#3-3-4-响应" class="headerlink" title="3.3.4 响应"></a>3.3.4 响应</h3><p>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应，见下面表格的描述 [MQTT-3.3.4-1]。</p>
<h5 id="表格-3-4-–-PUBLISH报文的预期响应"><a href="#表格-3-4-–-PUBLISH报文的预期响应" class="headerlink" title="表格 3.4 – PUBLISH报文的预期响应"></a>表格 3.4 – PUBLISH报文的预期响应</h5><table>
<thead>
<tr>
<th><strong>服务质量等级</strong></th>
<th><strong>预期响应</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QoS 0</td>
<td>无响应</td>
</tr>
<tr>
<td>QoS 1</td>
<td>PUBACK报文</td>
</tr>
<tr>
<td>QoS 2</td>
<td>PUBREC报文</td>
</tr>
</tbody>
</table>
<h3 id="3-3-5-动作-Actions"><a href="#3-3-5-动作-Actions" class="headerlink" title="3.3.5 动作 Actions"></a>3.3.5 动作 Actions</h3><p>客户端使用PUBLISH报文发送应用消息给服务端，目的是分发到其它订阅匹配的客户端。</p>
<p>服务端使用PUBLISH报文发送应用消息给每一个订阅匹配的客户端。</p>
<p>客户端使用带通配符的主题过滤器请求订阅时，客户端的订阅可能会重复，因此发布的消息可能会匹配多个过滤器。对于这种情况，服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端 [MQTT-3.3.5-1]。服务端之后可以按照订阅的QoS等级，分发消息的副本给每一个匹配的订阅者。</p>
<p>收到一个PUBLISH报文时，接收者的动作取决于4.3节描述的QoS等级。</p>
<p>如果服务端实现不授权某个客户端发布PUBLISH报文，它没有办法通知那个客户端。它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认，或者关闭网络连接 [MQTT-3.3.5-2]。</p>
<blockquote>
<p>MQTT 原文文献:<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p>
<p>MQTT 中文版:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/UIView和-CALayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/UIView和-CALayer/" itemprop="url">UIView和 CALayer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T11:21:19+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>作为普通开发者而言，写 UI 和控件时，我们并不经常直接接触到<code>CALayer</code>，但是<code>CALayer</code>却是写页面最常用的类之一(每个 UIView 至少有一个 CALayer)。但是什么是 CALayer 呢？</p>
<blockquote>
<p>参考资料：</p>
<p>CALayer Tutorial for iOS: Getting Started：<a href="https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started" target="_blank" rel="noopener">https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Objective-C-代码转换为-C-代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Objective-C-代码转换为-C-代码/" itemprop="url"> Objective-C 代码转换为 C++代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T11:22:30+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在研究 iOS 系统方法实现的时候，由于有时苹果未将改方法的实现开源，所以此时我们就需要将指定你文件转换为C++文件，这样就可以看到部分底层实现。</p>
<p>当你在谷歌搜索如何创建C++文件文件的时候，你得到的答案可能是这样:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>这样</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc AppDelegate.m -o AppDelegate.cpp</span><br></pre></td></tr></table></figure>
<p>或者是这样</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk ViewController.m</span><br></pre></td></tr></table></figure>
<p>这时候你可能欣喜，竟然有那么多种方案可以实现，但是在键入这些代码之后你可能会发现令你更加欣(fa)喜(kuang)的一面,这结果可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error1.png" alt="UIKit/UIKit.h not found"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error2.png" alt="not support weak references"></p>
<p>或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error3.png" alt="assigning retained object to weak variable"></p>
<p>这时候你看到那么多友善(mmp)的提示你的心情可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile1.jpg" alt="faker smile one"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile2.jpg" alt="faker smile two"></p>
<p>亦或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile3.jpg" alt="faker smile three"></p>
<p>如果你真的遇到这些问题，请冷静一下，我们先来解决这个技术难题</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/dontDoThis1.jpg" alt="大哥别这样"></p>
<p>首先我们分析一下第一个命令产生的问题—— <code>fatal error: &#39;UIKit/UIKit.h&#39; file not found</code></p>
<p>这个问题产生的原因是因为 clang 将.m文件转换为 C++文件的时候，clang 找不到这个头文件，这时候我们只需要指定一下其平台即可 </p>
<ul>
<li>指定真机 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<ul>
<li>指定模拟器 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>但是指定真机之后还可能会产生问题，例如代码中有 weak，这时候 clang 转换又双叒叕不通过了，这时只需要支持 ARC 指定运行时版本即可 </p>
<ul>
<li>支持 ARC 指定运行时版本，例如在-rewrite-objc 后面添加如下代码 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时候两个最常见的问题已经解决了，接下来解决第三个问题。 </p>
<p>第三个问题困扰了我好久，最后发现只要不直接使用 alloc init 或者 new 之类的初始化方法给被 weak 修饰的指针赋值即可。 </p>
<ul>
<li>最终命令 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<p>创建 C++文件总流程: </p>
<ol>
<li>打开终端，使用命令先进入指定路径(需要转换文件所在的路径) </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ChromeBook:</span>oc中的 weak sq$ cd /Users/sq/Desktop/Project/OCTest/oc中的\ weak/oc中的\ weak</span><br></pre></td></tr></table></figure>
<ol>
<li>输入上述最终命令，将最终命令中的Appdelegate.m改为你的目标文件 </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料： </p>
<p>OC代码转C++代码的生成:<a href="https://www.jianshu.com/p/3a896cba744a" target="_blank" rel="noopener">https://www.jianshu.com/p/3a896cba744a</a> </p>
<p>Objective-C编译成C++代码报错:<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">https://www.jianshu.com/p/43a09727eb2c</a> </p>
<p>使用clang将OC代码转为C++（亲测有效）:<a href="https://blog.csdn.net/qq_34003239/article/details/84230019" target="_blank" rel="noopener">https://blog.csdn.net/qq_34003239/article/details/84230019</a> </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/iOS-中的-weak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/iOS-中的-weak/" itemprop="url">iOS 中的 weak</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T17:03:05+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是-weak"><a href="#什么是-weak" class="headerlink" title="什么是 __weak"></a>什么是 __weak</h2><p>前段时间因为项目忙(lan)，好久没有写博客了，现在趁着项目结束，赶紧写两篇博客来巩固一下知识。今天我们来了解一下 <code>weak</code>。</p>
<p>首先，<code>weak</code>是一个修饰符，也是内存管理语义的一种(有关内存管理语义请看<a href="http://devjohn.cn/2018/08/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89/" target="_blank" rel="noopener">这里</a>)，用于修饰对象的所有权。请注意<code>weak</code>修饰符是在自动引用计数出现前就已经存在了，在那个时候iOS 的内存管理机制还是垃圾收集机制。</p>
<p><code>weak</code>定义的是一种非拥有关系，为这个属性设置新值的时候，设置方法既不会保留新值，也不会释放旧值。</p>
<p>接下来我们用一个例子来了解一下，具体<code>weak</code>是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    __weak NSObject *obj233 = [NSObject new];</span><br><span class="line">    __weak NSString *str233 = @&quot;test_Str&quot;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;obj233 = %@&quot;,obj233);</span><br><span class="line">    NSLog(@&quot;str233 = %@&quot;,str233);	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请读者猜测一下具体会输出什么信息？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-12-04 10:14:25.468487+0800 oc中的 weak[20959:6105765] obj233 = (null)</span><br><span class="line">2018-12-04 10:14:25.468958+0800 oc中的 weak[20959:6105765] str233 = test_Str</span><br></pre></td></tr></table></figure>
<p>首先我们分析一下，<code>obj233</code>为什么会输出(null)(这里的(null)其实输出的就是 nil)。</p>
<p>众所周知，阅读代码的顺序是从右至左，第一步调用的是<code>[NSObject new]</code>，这里创建了一个新的<code>NSObject</code>对象(为了方便理解，我们将该变量命名为o1)，第二步是申明一个被<code>weak</code>修饰的指针，这个指针指向的是刚创建的变量o1。由于<code>weak</code>的特性——不增加引用计数。所以o1并没有被任何指针或对象所拥有此时的引用计数仍然为0，因此o1变量会在创建赋值之后不久就被销毁。并且又因为<code>weak</code>的第二个特性，当指向的对象被销毁的时候，被<code>weak</code>修饰的指针会自动被置为 nil。</p>
<p>那么同理的<code>str233</code>为什么就不为<code>nil</code>呢？这是由于<code>Objective-C</code>中字符串的特性导致的。</p>
<p>到底是字符串的什么特性导致的呢？我们先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)stringTest</span><br><span class="line">&#123;</span><br><span class="line">    NSString *s1 = [[NSString alloc] initWithString:@&quot;str1&quot;];</span><br><span class="line">    NSString *s2 = @&quot;str1&quot;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;str1 = %p&quot;,@&quot;str1&quot;);</span><br><span class="line">    NSLog(@&quot;s1 = %p&quot;,s1);</span><br><span class="line">    NSLog(@&quot;s2 = %p&quot;,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到底回输出什么呢？我们构建并运行之后了解一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-12-04 16:37:38.994474+0800 oc中的 weak[311:12354] str1 = 0x102fd00f0</span><br><span class="line">2018-12-04 16:37:38.994487+0800 oc中的 weak[311:12354] s1 = 0x102fd00f0</span><br><span class="line">2018-12-04 16:37:38.994498+0800 oc中的 weak[311:12354] s2 = 0x102fd00f0</span><br></pre></td></tr></table></figure>
<p>从这一段输出我们能发现，打印出的字符串指针地址都是一样的。这说明<code>s1</code>、<code>s2</code>、<code>@&quot;str1&quot;</code>实际上都是同一个指针。然后我们接着测试，这次测试其引用计数。在<code>stringTest</code>方法中添加查看引用计数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)stringTest</span><br><span class="line">&#123;</span><br><span class="line">    NSString *s1 = [[NSString alloc] initWithString:@&quot;str1&quot;];</span><br><span class="line">    printf(&quot;s1 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s1)));</span><br><span class="line">    NSString *s2 = @&quot;str1&quot;;</span><br><span class="line">    printf(&quot;s2 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s2)));</span><br><span class="line">    NSString *s3 = s2;</span><br><span class="line">    printf(&quot;s3 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s3)));</span><br><span class="line">    printf(&quot;str1 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(@&quot;str1&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后结果如下:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">s2 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">s3 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">str1 retain count = <span class="number">1152921504606846975</span></span><br></pre></td></tr></table></figure>
<p>从上述结果你能看到，字符串的引用计数不会随着引用增加该增加。现在我们回到最初的问题上，这时候就能够解释为什么被<code>weak</code>修饰的<code>str233</code>字符串不会为 nil——<strong>字符串的生命周期不受引用计数的影响</strong>。</p>
<p>看到这里你可能会有疑问，在引用计数变为0之后，是立刻将对象置为 nil，还是在一个特定的时间置 nil。我们接着看下去。</p>
<h2 id="weak-修饰符的背后"><a href="#weak-修饰符的背后" class="headerlink" title="weak 修饰符的背后"></a>weak 修饰符的背后</h2><h3 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h3><p>首先我们在<code>viewDidLoad</code>中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj233 = [NSObject new];</span><br><span class="line">__weak NSObject *obj1 = obj233;</span><br></pre></td></tr></table></figure>
<p>上述代码将<code>obj233</code>赋值给被<code>weak</code>修饰的obj1，接下来我们开启Xcode 的反汇编功能(Xcode-&gt;Debug-&gt;Debug Workflow-&gt;Always show Disassembly)，并在为<code>obj1</code>赋值之后打上断点，接着构建并运行程序，查看。</p>
<p><img src="/2018/12/03/iOS-中的-weak/断点查看汇编.png" alt="image-断点查看汇编"></p>
<p>我们看右侧的注释，首先<code>objc_msgSendSuper2</code>是<code>ViewDidLoad</code>方法中的<code>[super viewDidLoad];</code>。</p>
<p>接着是<code>objc_msgSend</code>这里是源代码中的<code>NSObject *obj233 = [NSObject new];</code>。</p>
<p>接下来三个方法就是我们今天要研究的代码。</p>
<p>首先是<code>objc_initWeak</code>这个方法，看到这个方法的前缀首先<code>cmd+shift+o</code>搜索该方法。但是该方式无法搜索到该方法，所以我们需要去下载<code>Objective-C</code>的源码，并搜索该方法。(请点击<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">这里下载</a>，下载完成之后解压，并打开objc.xcodeproj)。</p>
<p>找到该方法，见下图</p>
<p><img src="/2018/12/03/iOS-中的-weak/objc_initWeak-function-des.png" alt="image-20181206151850180"></p>
<p>我们着重看第一句说明：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initialize a fresh weak pointer to some object location. </span><br><span class="line">中文释义</span><br><span class="line">初始化一个新的弱指针，这个指针指向某个对象地址。</span><br></pre></td></tr></table></figure>
<p>接着我们去Clang编译器官网查看关于该方法的<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-initweak" target="_blank" rel="noopener">部分</a>。</p>
<p><img src="/2018/12/03/iOS-中的-weak/id objc_initWeak.png" alt="image-20181207113924683"></p>
<p>这里说明了一个前提：</p>
<blockquote>
<p><code>object</code> is a valid pointer which has not been registered as a <code>__weak</code> object. <code>value</code> is null or a pointer to a valid object.</p>
</blockquote>
<p><code>object</code>要是一个有效的并且尚未被注册为<code>__weak</code>的对象。<code>value</code>是一个空或者非空的指向一个有效对象的指针。这里的意思我理解为一个对象不能被<code>__weak</code>多次修饰。</p>
<p>然后是接下来的一句:</p>
<blockquote>
<p>If <code>value</code> is a null pointer or the object to which it points has begun deallocation, <code>object</code> is zero-initialized. Otherwise, <code>object</code> is registered as a <code>__weak</code> object pointing to <code>value</code></p>
</blockquote>
<p>如果<code>value</code>是一个空指针或者是一个已经开始释放的对象，<code>object</code>则进行零初始化。否则<code>object</code>被注册为指向<code>value</code>的<code>__weak</code>对象。</p>
<p>接着我们继续分析<code>objc_initWeak</code>这个方法，这个方法传入两个参数，分别是类型为<code>id *location</code>和<code>id newObj</code>，<code>id</code>在 Objective-C 中是最常见的类型类型之一，但是<code>id *</code>是代表着什么呢？</p>
<p>在回答这个问题之前，再问一个问题：<code>id</code>是什么？</p>
<p>“<code>id</code>可以代表任意类型的Objective-C 对象。”这样说没错，但是我如果接着问呢？什么是 <code>Objective-C</code>对象?</p>
<p>这个是时候，可能就会把一部分人给难住。但是别着急，我们接着看下去，代码不会欺骗我们。</p>
<p>打开<code>objc.h</code>中找到如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以得知，<code>id</code>就是<code>objc_object *</code>的一个别名。那什么是<code>objc_object</code>呢，这里不做多说明，想知道的朋友请看看这篇文章——</p>
<p>好了，那现在我们知道了<code>id</code>类型，那么什么是<code>id *</code>类型呢？</p>
<p>我们再来看看这个方法，这个方法的作用是将字符串输出到指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error;</span><br></pre></td></tr></table></figure>
<p>在这个方法中<code>error</code>的类型是这样的<code>NSError * *</code>的，类似于我们将<code>id *</code>转换为其原本形式<code>objc_object **</code>。那这时候我们怎么传入参数呢？就以上述方法为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">    [@&quot;eat chicken tonight&quot; writeToFile:@&quot;/file.txt&quot; atomically:true encoding:NSUTF8StringEncoding error:&amp;error];</span><br></pre></td></tr></table></figure>
<p>这时候传入<code>error</code>参数时必须要加一个<code>&amp;</code>符号，这个符号是什么意思呢？并且我们经常看到的<code>*</code>又是什么意思呢？请看我这篇文章的分析——</p>
<blockquote>
<p>关于&amp;、*、指针、和二级指针</p>
<ul>
<li>取地址运算符&amp;：&amp;是一元运算符，返回操作数的内存地址。</li>
<li>间接寻址运算符 *：也是一元运算符，是&amp;运算符的补充。返回操作数指定地址的变量的值。</li>
</ul>
<p>但是在声明对象的时候<code>*</code>代表着该对象是指针(指针表示这个变量中保存的内容是另一个变量的地址)，<code>* *</code>则代表着该变量是二级指针。二级指针中保存的内容是另一个指针的地址。</p>
<p>为什么会出现这种情况呢，因为一个函数只能有一个返回值，当一个函数需要返回两个数的时候，常规的办法并无法解决。所以这时候出现了二级指针，并且在函数中无法改变形参(让其指向一个新的变量)，但是可以通过二级指针来改变其当前所指向的变量。因此这时候就出现了方法中需要传入二级指针的情况。</p>
</blockquote>
<p>所以我们可以知道<code>id *</code>实际上就是一个二级指针，所以调用该方法的时候需要传入该变量的地址。</p>
<p>所以我们回到刚才的问题，我们能够得知，<code>objc_initWeak</code>方法需要传入一个指针地址和一个指针，然后返回一个新的指针。</p>
<p>那为什么会有这样的设计呢？这是因为<strong>Runtime维护了一个 weak 表，用于储存指向某个对象的 weak 指针，和这个对象。这个 weak 表实际上是一个(hash)哈希表(又称散列表)，表以对象地址作为 key，weak 指针地址作为 value ，并且由于一个对象可能被多个 weak 指针所指向，所以weak 表中一个 key 可能会有多个 value。</strong>这个存入就是和销毁就是通过<code>storeWeak</code>方法来实现。</p>
<p>我们看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj233 = [NSObject new];</span><br><span class="line">__weak NSObject *obj1 = obj233;		// ocjc_initWeak(&amp;obj1,obj233)</span><br><span class="line">__weak NSObject *obj2 = obj233;		// ocjc_initWeak(&amp;obj2,obj233)</span><br></pre></td></tr></table></figure>
<p> 在这个例子中，</p>
<h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><p>打开<code>NSObject.mm</code>文件，并找到<code>storeWeak</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">// 更新一个 weak 变量。如果HaveOld为true，则该变量具有一个需要清除的现有值。这个值可能是nil。如果</span><br><span class="line">// HaveNew为true，则有个新值需要被分配到该变量中。这个值可能会是nil。如果CrashIfDeallocating是 </span><br><span class="line">// true，则如果 newobj 正在取消分配或 newobj 的类不支持弱引用, 则该过程将停止。如果</span><br><span class="line">// CrashIfDeallocating是false，则是用nil储存。</span><br><span class="line">enum CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = false, DoCrashIfDeallocating = true</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用此方法时在新值和旧值之间必须要有一个</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    // 如果传递新值 newObj 不能为 nil</span><br><span class="line">    if (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // 为新值和旧值获取锁</span><br><span class="line">    // Order by lock address to prevent lock ordering problems. </span><br><span class="line">    // Retry if the old value changes underneath us.</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent a deadlock between the weak reference machinery</span><br><span class="line">    // and the +initialize machinery by ensuring that no </span><br><span class="line">    // weakly-referenced object has an un-+initialized isa.</span><br><span class="line">    if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            // If this class is finished with +initialize then we&apos;re good.</span><br><span class="line">            // If this class is still running +initialize on this thread </span><br><span class="line">            // (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            // then we may proceed but it will appear initializing and </span><br><span class="line">            // not yet initialized to the check above.</span><br><span class="line">            // Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看接口的说明</p>
<blockquote>
<p>Update a weak variable. If HaveOld is true, the variable has an existing value that needs to be cleaned up. This value might be nil.If HaveNew is true, there is a new value that needs to be assigned into the variable. This value might be nil.If CrashIfDeallocating is true, the process is halted if newObj is deallocating or newObj’s class does not support weak references. If CrashIfDeallocating is false, nil is stored instead.</p>
</blockquote>
<p>中文释义</p>
<blockquote>
<p>更新一个 weak 变量。如果<code>HaveOld</code>为<code>true</code>，则该变量具有一个需要清除的现有值。这个值可能是<code>nil</code>。如果<code>HaveNew</code>为<code>true</code>，则有个新值需要被分配到该变量中。这个值可能会是<code>nil</code>。如果<code>CrashIfDeallocating</code>是 <code>true</code>，则如果 newobj 正在取消分配或 newobj 的类不支持弱引用, 则该过程将停止。如果<code>CrashIfDeallocating</code>是<code>false</code>，则是用<code>nil</code>储存。</p>
</blockquote>
<blockquote>
<p>参考资料</p>
<p>1.深入理解 Objective-C 中的字符串常量：<a href="https://blog.csdn.net/qijianli/article/details/7826962" target="_blank" rel="noopener">https://blog.csdn.net/qijianli/article/details/7826962</a></p>
<p>2.浅谈iOS之weak底层实现原理：<a href="https://blog.csdn.net/Future_One/article/details/81606895" target="_blank" rel="noopener">https://blog.csdn.net/Future_One/article/details/81606895</a></p>
<p>3.iOS __weak的底层实现：<a href="https://www.jianshu.com/p/48044cc54392" target="_blank" rel="noopener">https://www.jianshu.com/p/48044cc54392</a></p>
<p>4.细说weak：<a href="https://www.jianshu.com/p/10c0f49f4755" target="_blank" rel="noopener">https://www.jianshu.com/p/10c0f49f4755</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/GPUImage-使用心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/GPUImage-使用心得/" itemprop="url">GPUImage 使用心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T23:14:12+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/15/类和-isa-指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/类和-isa-指针/" itemprop="url">类和 isa 指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T15:56:14+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对于普通对象来说，isa-指针包含对象的类"><a href="#对于普通对象来说，isa-指针包含对象的类" class="headerlink" title="对于普通对象来说，isa 指针包含对象的类"></a>对于普通对象来说，isa 指针包含对象的类</h2><p>oc 中所有的 isa 指针指向的都是类。</p>
<p>在 oc 中每一个类的对象都都有一个指向类的指针 isa。并且在 oc 中任何数据结构也在一个正确的位置上都有一个指向类的指针，使其能够被视为对象。</p>
<p>所以一个对象的类型是由 isa 指针决定的，isa 指针指向对象的类。</p>
<p><del>接下来我们查看类的定义，首先我们使用如下代码导入所需框架:</del>(这样查看的是旧的定义)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;objc/objc.h&gt;</span><br></pre></td></tr></table></figure>
<p><del>首先我们先查看对象的定义,找到objc_object ，并查看:</del></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p><del>我们看到objc_object中只定义了一个 Class 类型的变量，Class类型其实我们可以从上述代码第一条得知 Class其实就是一个objc_class类型的指针。<strong>对于对象来说isa指针就是指向对象所对应的类。</strong></del></p>
<p>新定义:</p>
<p>首先<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">下载文档</a>，然后我们打开它objc-private.h 文件。我们查看objc_object 定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 objc_object 中，isa 是一个 isa_t 类型的变量，继续在这个文件中查找 “union isa_t ”，然后我们看这个变量的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 isa_t 是一个union类型的结构体(或者称为联合体)。这个 isa_t 中定义了一个 Class 类型的cls 变量。然后我们接着查找这个 Class 类型。在同一个文件中搜索’objc_class *Class’，你会看到Class 类型的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>你会看到其实 cls 变量是一个指针，其值指向的对象是objc_class结构体。接着我们打开objc-runtime-new.h 文件，搜索“objc_class ”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体就是类的结构，所以我们说<strong>对于普通对象来说，isa 指针包含对象的类</strong>。为什么特指普通对象呢，我们继续看下去。</p>
<h2 id="类其实也是一个对象"><a href="#类其实也是一个对象" class="headerlink" title="类其实也是一个对象"></a>类其实也是一个对象</h2><p>首先我们着重看上述几个变量,并逐条分析。objc_class 继承自objc_obbject，所以我们 objc_class 中也存在一个isa 变量。而且由这个继承结构我们可以得出：<strong>类其实也是一个对象</strong>。只不过这个对象并不是由我们来创建，而是由系统来创建。既然类也是一个对象，那么其 isa 指针中必定也包含对象的类，即<strong>“类对象的类“</strong>。那么”类对象的类“是什么呢？其实它就是<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB" target="_blank" rel="noopener">元类(metaclass)</a>，但是，元类有什么作用呢？先别急，我们等会讨论。</p>
<h3 id="类对象中保存类的父类"><a href="#类对象中保存类的父类" class="headerlink" title="类对象中保存类的父类"></a>类对象中保存类的父类</h3><p>superclass 也是一个objc_class类型，就是一个类，按照其字面意思理解是指向本对象的父类，事实上真是这个意思，在这里就是元类的父类。这具体是指向的什么呢，这等我们讨论元类的时候再讨论。</p>
<p>然后下一个就是cache，这个变量是cache_t类型的，它是一个<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>(又名哈希表，是根据键(Key)而直接访问在内存存储位置的数据结构)，缓存的是曾经调用过的方法列表，并且它可以使用键值对的方式去读取，这样效率肯定比遍历快得多。如果你想了解更多请看<a href="https://juejin.im/post/5b1b45c36fb9a01e5b10f96b" target="_blank" rel="noopener">方法缓存与查找</a>。</p>
<h3 id="类对象保存属性、实例所能执行的普通方法和所遵守的协议"><a href="#类对象保存属性、实例所能执行的普通方法和所遵守的协议" class="headerlink" title="类对象保存属性、实例所能执行的普通方法和所遵守的协议"></a>类对象保存属性、实例所能执行的普通方法和所遵守的协议</h3><p>接下来就是一个bits，它是class_data_bits_t类型的变量，在讲解这个变量之前，我们先看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@&quot;stringValue&quot;</span><br><span class="line">    writeToFile:@&quot;/file.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</span><br></pre></td></tr></table></figure>
<p>当字符串实例调用实例方法writeToFile:的时候，这个方法也是存在于内存中的，那么它是在哪里被定义的呢？在没有接触过 runtime 之前，你可能会对此感到疑惑，可能觉得它就是保存在对象里的，也可能觉得它是保存在对象的类中的，或者说根本就没有想法(刚开始我就是一脸懵逼)。我们接下来就来探讨这个问题，首先看对象类型objc_object 结构体。在这结构体中，大部分的函数和变量都是和 ARC 与 isa 有关的，你找了很久也没有找到名称类似的函数和变量。接着我们看objc_class 结构体，因为变量才是保存信息所用的单元，所以我们先看变量。在 objc_class 中，我们讲过了前面几个变量，接着就是要讲class_data_bits_t类型的变量bits。我们在”objc-runtime-new.h”中搜索class_data_bits_t，我们可以看到这个类型的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    // Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们发现了两个新的类型，分别是uintptr_t和class_rw_t。我们依次查看这两个类型的定义：首先我们使用快捷键 cmd+shift+o 调出快速搜索栏填入uintptr_t。</p>
<p><img src="/2018/08/15/类和-isa-指针/快速查找uintptr_t.png" alt="image-20180817093327289"></p>
<p>打开这个文件，你会看到uintptr_t 的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _UINTPTR_T</span><br><span class="line">#define _UINTPTR_T</span><br><span class="line">typedef unsigned long		uintptr_t;</span><br><span class="line">#endif /* _UINTPTR_T */</span><br></pre></td></tr></table></figure>
<p>其实它就是一个长整型的别名，它不保存方法，我们接着看下一个变量类型class_rw_t。</p>
<p>还是在objc-runtime-new.h 中，搜索class_rw_t，你会看到他的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先查看变量，你会惊喜的发现有一个类型为method_array_t的变量methods。这个变量难道就是我们需要找的保存方法的变量？对没错，他就是保存对象方法列表的变量。查看它的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_list_t **beginCategoryMethodLists() &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    method_list_t **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    method_array_t duplicate() &#123;</span><br><span class="line">        return Super::duplicate&lt;method_array_t&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有多个新的类型，我们先查看第一个类型list_array_tt。同样的在”objc-runtime-new.h”中搜索list_array_tt，看到其定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list_array_tt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> count;</span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> size_t <span class="title">byteSize</span><span class="params">(<span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">array_t</span>) + count*<span class="keyword">sizeof</span>(lists[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> byteSize() &#123;</span><br><span class="line">            <span class="keyword">return</span> byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关template 关键字请看<a href="https://blog.csdn.net/hycoldrain/article/details/3716131" target="_blank" rel="noopener">这里</a>，所以我们可以知道，其实method_array_t就是一个二维数组，这个二维数组中保存的就是method_list_t数组，method_list_t数组中保存的是method_t。我们接着查看 method_t。我们继续在”objc-runtime-new.h”中搜索method_t ，我们可以看到 method_t 的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,</span><br><span class="line">                                    const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>wow，这不就是我们熟知的方法的结构吗！name 是 SEL 类型的表示方法名。imp 是 IMP 类型，表示指向方法的实现地址。<strong>所以，类对象保存着对象所能执行的普通方法。</strong>为什么是普通方法呢，等我们讨论元类的时候再做解释，接下来我们来看它们的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们先看 IMP，IMP 类型我们根据新的 IMP 定义可以这样理解：<strong>IMP 作为一个指向 “一个拥有 至少一个 id 类型，一个 SEL 类型当作参数并回传不可为空的  id 的函数” 的指针的别名</strong>(如果对 typedef 不太了解的可以看<a href="https://zh.wikipedia.org/wiki/Typedef" target="_blank" rel="noopener">这里</a>)。IMP是最终消息执行所调用的代码，是方法真正实现的代码。</p>
<p>接着我们看 SEL，SEL 类型是一个指针类型，其内容指向objc_selector。但是在 runtime 源码中找不到其定义，所以我们无法了解到这里面写了什么(但是有兴趣的同学可以看<a href="https://blog.csdn.net/jeffasd/article/details/52084639" target="_blank" rel="noopener">这篇文章</a>所写的内容，这文章中大胆的猜测了objc_selector类型定义)，所以我们没办法知道其具体定义，只知道 <strong>SEL 代表着方法的’’标识符’’</strong>。就像”人民大会堂”这个名字就代表着人民大会堂这个建筑一样。</p>
<p>如果我们继续观察class_rw_t中的property_array_t类型和protocol_array_t类型，我们会发现这和list_array_tt类似，只不过property_array_t中保存的是<strong>对象所有的属性</strong>，protocol_array_t保存<strong>对象所遵守的协议</strong>。</p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>我们在讨论类的时候多次出现了”元类“这个概念，我们说类对象的 isa 指针指向元类。但是什么是元类呢？我们引用<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB" target="_blank" rel="noopener">维基的释义</a>——<strong>元类</strong>（英语：metaclass）是一种实例是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB" target="_blank" rel="noopener">类</a>的类。普通的类定义的是特定对象的行为，元类定义的则是特定的类及其对象的行为。</p>
<p>即：类对象的行为在元类中定义。</p>
<p>看到这里你可能会感到疑惑：类对象的行为是什么呢？我们看如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;class method&quot;];</span><br></pre></td></tr></table></figure>
<p>我们知道实例对象的方法保存在类对象中，但是上述代码并不是实例对象调用，而是类调用，那么这个方法也是保存在类中的吗？目前我们还不知道答案，但是我们换一个角度思考。类调用方法既是类对象调用方法，按之前我们分析得到的结果：<strong>对象的方法保存在对象所对应的类中</strong>。类一个一个对象，那么其方法必定也保存在类所对应的类中，即：元类中，但是请注意这并不是一个新的结构，只是一个名词而已其结构还是 objc_class。</p>
<p>元类我们从结构上知道，它也是一个 objc_class 的结构体。所以其中保存着类对象所执行的方法——类方法。既然是元类那么其必定也有 isa 指针，这个指针指向什么呢？请耐心看下去。</p>
<h2 id="对象和类的继承机构"><a href="#对象和类的继承机构" class="headerlink" title="对象和类的继承机构"></a>对象和类的继承机构</h2><p>普通对象中有 isa 指针指向其类，类对象中也有superclass指向其父类，元类中的 superclass 指针指向的也是其父类，就是元类的父类。元类的父类是什么呢？我们看一张图来了解一下(一图胜千言):</p>
<p><img src="/2018/08/15/类和-isa-指针/对象和类的结构.jpg" alt="F46657E4-1C70-45F0-A09D-FBC0A20E0C51"></p>
<p>在这张图中我们可以看到：</p>
<ul>
<li><strong>实例对象的 isa 指针指向其类，类的 isa 指针指向元类，元类的 isa 指针指向根元类(即 NSObject 的元类)，根元类的 isa 指针指向自己。</strong></li>
<li><strong>实例对象的类的 superclass 指向父类，父类的 superclass 指针指向其父类，最终指向 NSObject，NSObject 的 superclass 指针指向 nil。</strong></li>
<li><strong>元类的superclass 指向其类对象父类的元类，并最终指向 NSObject 类的元类，NSObject 的元类的 isa 指针指向 NSObject。</strong></li>
</ul>
<blockquote>
<p>参考资料:</p>
<p>浅谈 Objective-C 中的元类 (meta-class):<a href="https://www.jianshu.com/p/79b06fabb459" target="_blank" rel="noopener">https://www.jianshu.com/p/79b06fabb459</a> </p>
<p>iOS 常见知识点（一）：Runtime：<a href="https://www.jianshu.com/p/965bd18cb056" target="_blank" rel="noopener">https://www.jianshu.com/p/965bd18cb056</a> </p>
<p>What is a meta-class in Objective-C?：<a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></p>
<p>方法缓存与查找：<a href="https://juejin.im/post/5b1b45c36fb9a01e5b10f96b" target="_blank" rel="noopener">https://juejin.im/post/5b1b45c36fb9a01e5b10f96b</a></p>
<p>c++模板中的 typename 和 template 关键字用法:<a href="https://blog.csdn.net/hycoldrain/article/details/3716131" target="_blank" rel="noopener">https://blog.csdn.net/hycoldrain/article/details/3716131</a></p>
<p>OC 中 objc_selector 结构体详解:<a href="https://blog.csdn.net/jeffasd/article/details/52084639" target="_blank" rel="noopener">https://blog.csdn.net/jeffasd/article/details/52084639</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/内存管理语义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/内存管理语义/" itemprop="url">内存管理语义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T15:34:35+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每个属性都有其内存管理语义，要么默认设置，要么主动设置。内存管理语义定义了其属性的所有权。属性所有权仅影响 setter。</p>
<ul>
<li><p>assign： </p>
<p>assign一般用来修饰基本数据类型 int 、 float (基础类型没有引用关系)</p>
<p>意义：如果这个用assign属性修饰的property代表一个指向对象的指针，那么当这个指针指向某个对象时，这个对象的引用计数不应该被改变。也就是说，用assign属性修饰的property，不应该持有一个对象(引用计数不增加)。因为这个property不持有对象，所以它所指向的对象很可能已经在别处被释放了。这时它就有可能成为一枚悬垂指针，访问它指向的内存地址时，可能会发生意想不到的状况。 </p>
</li>
<li><p>strong：</p>
<p>在ARC内存管理模式下，strong是一个代表对象类型的property的默认属性，并且它不能修饰用来代表简单数据类型的property。编译器在合成实例变量时，将使用__strong修饰符。</p>
<p>此特性表明该属性定义了一种”拥有关系“。为这种属性设置新值的时候，会先保留新值然后释放旧值，接着将新值赋值上去。(注意这里的顺序，一定是先保留新值然后释放旧值，不能相反，否则假设新值和旧值是同一个值的话会造成值被释放被设为 nil)。</p>
</li>
<li><p>weak: </p>
<ul>
<li>weak也不能修饰用来代表简单数据类型的property。</li>
<li>编译器将为weak修饰的property生成带__weak所有权修饰符的实例变量。</li>
<li>此特性定义了一种“非拥有关系”。为这个属性设置新值的时候，设置方法既不会保留新值，也不会释放旧值。此特性同 assign 类似，然而在此属性所知的对象被设置摧毁之后，属性值会被设置为 nil。</li>
</ul>
</li>
<li><p>retain： </p>
<ul>
<li>retain (基本等价于 Strong) :</li>
<li>retain不能修饰用来代表简单数据类型的property，否则编译器会报错</li>
<li>如果一个property被retain修饰，这代表着这个property应该持有它所指向的对象。<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW1" target="_blank" rel="noopener">官方文档</a>中展示了一个被retain修饰的property：</li>
</ul>
</li>
<li><p>atomic(默认)：单线程使用 ， 线程安全  ， 速度慢</p>
</li>
<li><p>nonatomic：可多线程使用 ， 线程不安全   ， 速度快</p>
</li>
<li><p>copy：</p>
<ul>
<li><p>copy也不能修饰用来代表简单数据类型的property，否则编译器会报错</p>
</li>
<li><p>如果一个property被copy修饰，那么赋值到这个property的对象，应该是原有对象的一份拷贝且不会增加引用计数。</p>
</li>
<li>对使用 copy 修饰的属性，若是调用了自定义的 setter 则一定要注意要使用 copy 方法。</li>
<li>只有实现了NSCopying协议，并且实现了其中的copyWithZone:方法的对象才能被拷贝。</li>
<li>但是并不是所有的拷贝都产生了新的对象，有些类在实现copyWithZone:方法时，有着它们自己的考虑。比如NSString： NSString 在Copy之后两个对象的内存地址相同</li>
<li><p>深拷贝和浅拷贝——具体请看<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a></p>
<ul>
<li>深拷贝 : 拷贝出来的对象与源对象地址不一致! 这意味着我修改拷贝对象的值对源对象的值没有任何影响.</li>
<li>浅拷贝 : 拷贝出来的对象与源对象地址一致! 这意味着我修改拷贝对象的值会直接影响到源对象.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料:</p>
<ul>
<li>IOS 内存管理机制  <a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">http://blog.devtang.com/2016/07/30/ios-memory-management/</a> </li>
<li>IOS 内存管理机制 <a href="http://www.jianshu.com/p/8b1ed04b3ba9" target="_blank" rel="noopener">http://www.jianshu.com/p/8b1ed04b3ba9</a> </li>
<li>iOS 从创建对象到销毁 <a href="https://juejin.im/entry/58a178060ce463005644ee4a" target="_blank" rel="noopener">https://juejin.im/entry/58a178060ce463005644ee4a</a></li>
<li>assign，retain，strong，weak，unsafe_unretained，还有copy : <a href="http://www.jianshu.com/p/4a1d1921284b" target="_blank" rel="noopener">http://www.jianshu.com/p/4a1d1921284b</a> </li>
<li>oc 属性修饰符讲解: <a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="noopener">http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html</a></li>
<li>打印引用计数 <a href="http://www.jianshu.com/p/e059a54fb5f3" target="_blank" rel="noopener">http://www.jianshu.com/p/e059a54fb5f3</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/iOS-中的指针、指针变量和对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/iOS-中的指针、指针变量和对象/" itemprop="url">iOS-中的指针、指针变量、变量和对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T11:03:02+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-中的指针、指针变量、变量和对象"><a href="#iOS-中的指针、指针变量、变量和对象" class="headerlink" title="iOS-中的指针、指针变量、变量和对象"></a>iOS-中的指针、指针变量、变量和对象</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是 C 语言的一个重要概念。OC 系统类型的变量,自定义类型的变量都是指针。</p>
<p>在很多国内的博客中将指针和指针变量分为两个概念，他们认为<strong>指针是一个变量的地址，而指针变量是保存另一个变量指针的变量</strong>。</p>
<p>而我查了很多资料发现大部分资料上写的，<strong>指针就是一个变量，他是保存另一个变量的地址的变量</strong>。就是国内很多博客中说到的’指针变量‘其实就是指针。关于指针的定义有如下几个可以参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">维基百科</a>)：在计算机科学中，指针（英语：Pointer），是编程语言中的<strong>一类数据类型及其对象或变量</strong>，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。</p>
<p><a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">百度百科</a>：指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。</p>
<p><a href="https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm" target="_blank" rel="noopener">tutorialspoint</a>：指针是一个变量，其值是另一个变量储存单元的直接地址。</p>
<p>我比较倾向的是维基百科的这种说法，指针是一个变量，其值是另一个变量的地址。</p>
<p>这是维基百科关于指针的说明图和说明文字。</p>
<p><img src="/2018/07/20/iOS-中的指针、指针变量和对象/440px-Pointers.svg.png" alt="指针"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 名为 a 的指针，指向一个存储器地址，当中的值为 b。要注意的是，在这个示意状况中使用的计算结构，对指针及非指针，都使用相同的地址空间以及表示法，但是在真实状况中，不同的计算结构可能有不同做法。</span><br></pre></td></tr></table></figure>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><p>对于计算机访问内存的方式有两种：</p>
<ul>
<li>直接访问：直接访问是直接通过定义的变量来获取变量的值。</li>
<li>间接访问：间接访问是通过访问变量的地址来获取变量的值。</li>
</ul>
<p>有一个形象的小例子可以说明直接访问和间接访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a. 直接访问某个地址，就相当于你知道某个物品放在某个抽屉里，然后你去那个抽屉，然后访问你的物品。</span><br><span class="line">b. 间接访问就是，你知道某个抽屉放着一个纸条，纸条写着：某某物品存放于某某另外一个抽屉。</span><br><span class="line"></span><br><span class="line">a里面的抽屉，就是变量，</span><br><span class="line">b里面存放纸条的抽屉，就是指针，指针的值，就是那个纸条，纸条指向另外一个抽屉（变量），另外一个抽屉存放的东西，就是一个变量的值。</span><br><span class="line">// 引用自百度知道&lt;https://zhidao.baidu.com/question/239578288212956844.html&gt;</span><br></pre></td></tr></table></figure>
<p>这样可以很形象的说明直接访问和间接访问的区别。</p>
<h3 id="基本指针运算符"><a href="#基本指针运算符" class="headerlink" title="基本指针运算符"></a>基本指针运算符</h3><p>关于指针的两个基本运算符:</p>
<ul>
<li>取地址运算符&amp;：&amp;是一元运算符，返回操作数的内存地址。</li>
<li>间接寻址运算符 *：也是一元运算符，是&amp;运算符的补充。返回操作数指定地址的变量的值。</li>
</ul>
<p>我们借用<a href="https://blog.csdn.net/senwin2009/article/details/48439361" target="_blank" rel="noopener">这篇文章</a>的例子转为 oc 的例子来说明:</p>
<p>我们先看这个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)swap_int:(int)i1 another:(int)i2</span><br><span class="line">&#123;</span><br><span class="line">    int temp = i1;</span><br><span class="line">    i1 = i2;</span><br><span class="line">    i2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	int p1 = 1;</span><br><span class="line">    int p2 = 10;</span><br><span class="line">    // 传入p1,p2</span><br><span class="line">    [self swap_int:p1 another:p2];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 = %d&quot;,p1);</span><br><span class="line">    NSLog(@&quot;p2 = %d&quot;,p2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个最后输出的结果是啥呢？我们先不急着公布答案，我们先了解一下 oc 中的参数和参数传递。</p>
<p>我们知道 oc 中调用方法有实参和形参之分，我们看看百度百科对其的解释。</p>
<p><a href="https://baike.baidu.com/item/%E5%BD%A2%E5%8F%82" target="_blank" rel="noopener">形参</a>：全称为“形式参数”是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。形参的作用是实现主调函数与被调函数之间的联系，通常将函数所处理的数据，影响函数功能的因素或者函数处理的结果作为形参。没有形参的函数在形参表的位置应该写int main(void) 函数也可以有形参和返回值，其形参也称为命令行参数，由操作系统在启动程序时初始化，其返回值传递给操作系统。</p>
<p><a href="https://baike.baidu.com/item/%E5%AE%9E%E5%8F%82" target="_blank" rel="noopener">实参</a>：实参，actual parameters，全称为”实际参数”是在调用时传递给函数的参数，即传递给被调用函数的值。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p>一句话概括就是：<strong>实参是调用方法时真正传入的参数，而形参是在函数中’接收‘实参的参数。</strong></p>
<p>形参接收实参的过程是这样的：<strong>首先根据形参的类型开辟出一个合适的内存空间用来保存形参，然后将实参所保存的内容拷贝一份给形参，所以实参和形参的地址是不相同的。</strong></p>
<p>就用我们上面的例子来讲，实参是p1,p2而形参是 i1,i2。将实参p1,p2传入方法时，方法首先会开辟出两块内存空间分别用来存放形参i1,i2，接着会将实参p1,p2所保存的内容赋值给相应的形参。所以<strong>p1,i1和p2,i2是对不同的int 变量</strong>，只是<strong>它们所保存的内容恰好相等</strong>而已。所以当你在方法中改变形参p1,p2值的时候并不会去改变实参所保存的内容(它们俩本就是不同的变量)。这个道理对于形参类型是指针也是一样的，只是指针所保存的内容是另一个对象的地址。如果要将转换例子中p1,p2的值该怎么做呢？请继续看下去。</p>
<p>将swap_int改为如下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)swap_int:(int *)i1 another:(int *)i2</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;i1 address %p&quot;,&amp;i1);</span><br><span class="line">    NSLog(@&quot;i2 address %p&quot;,&amp;i2);</span><br><span class="line">    NSLog(@&quot;i1 value address %p&quot;,&amp;(*i1));</span><br><span class="line">    NSLog(@&quot;i2 value address %p&quot;,&amp;(*i2));</span><br><span class="line"></span><br><span class="line">    // 将指针i1所指向地址的变量的值赋值给变量 temp</span><br><span class="line">    int temp = *i1;</span><br><span class="line">    // 将i2所指向地址的变量的值赋值给 i1所指向地址的变量的值。</span><br><span class="line">    *i1 = *i2;</span><br><span class="line">    // 将变量 temp 的值(temp 不是指针，所以其保存的值不是一个地址而是一个正常的值)赋值给i2指针所指向地址的变量的值。</span><br><span class="line">    *i2 = temp;</span><br><span class="line">    // 将 i1,i2均赋值为nil</span><br><span class="line">    i1 = i2 = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    int p1 = 1;</span><br><span class="line">    int p2 = 10;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 address %p&quot;,&amp;p1);</span><br><span class="line">    NSLog(@&quot;p2 address %p&quot;,&amp;p2);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 将 pi 和 p2 的地址作为实参传入(因为这个方法的参数需要传入的是指针，指针对应的对象)</span><br><span class="line">    [self swap_int:&amp;p1 another:&amp;p2];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 = %d&quot;,p1);</span><br><span class="line">    NSLog(@&quot;p2 = %d&quot;,p2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 输出结果:</span><br><span class="line">p1 = 10</span><br><span class="line">p2 = 1</span><br></pre></td></tr></table></figure>
<p>根据刚才参数传递过程的解释，我们发现因为形参是一个新创建的变量，所以传入实参的值并没有办法去改变实参的值。到底要如何去做呢？我们反过来想一想，如果要改变p1,p2的值，其实就是要<strong>改变 p1,p2所在的内存地址中保存的值</strong>。那就是说只要将p1,p2的内存地址给形参，然后<strong>根据内存地址去获取保存在该内存地址中的值</strong>，并且改变它就可以了。所以我们需要使用指针操作符&amp;传入一个内存地址。但是因为传入的是内存地址，所以就不能使用int 类型来保存了。那要使用什么样的类型来保存这个地址呢?根据参数传递，我们知道形参是要开辟出一个新的内存空间来，并将这块内存空间的值设置为传入的实参的值。就是说形参的内容要是一个地址。那不就是一个指针！而且根据传入的实参p1,p2的类型是 int 所以我们确定了形参是int 的指针，就是 int * (注意这里的 * 并不是指针操作符的 *)。接下来我们需要做的就是根据形参获得实参所保存的内容。这里就要用到另一个指针操作符” * “，这个指针操作符是获取指针所保存的内存地址所对应的对象的值。听起来有点拗口，其实上对于该例子就是获取p1,p2变量所保存的内容。最后手动将i1,i2指针指向nil。</p>
<p>我们知道了参数传递事实上就是创建了一个新的内存并拷贝实参的值。如何证明它是创建了一个新的对象呢，如果是创建了一个新的对象，那它是深拷贝还是浅拷贝呢？关于深拷贝与浅拷贝的问题可以看我这篇文章——<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a>。很简单，我们只需要关注那几条打印语句就行了。运行的结果你会发现i1和p1、i2和p2的内存地址永远是不同的，这表明确实是创建了新的对象。我先解释一下”&amp;(*i1)”，代码执行都是从右到左执行的，首先我们先用 * 操作符去获取指针所指向的地址所对应的对象的值，然后根据这个值使用 &amp; 来获取这个值所属的内存地址。这样我们打印出的“i1 value address”和“i2 value address”也是永远和p1,p2的地址是相同的，所以这里我们又可以得到这次的拷贝是一次浅拷贝的结论。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>说到对象呢，就不能不提变量。我们先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;String!&quot;;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个 <strong>NSString 对象，它的名字是 str</strong>。</p>
<p>也可以这么说，上面的代码创建了一个<strong>变量，它的类型是 NSString，它的名字是 str</strong>。</p>
<p>在很多时候我们经常会把变量和对象的的概念给混淆(虽然说他们也没有很明显的区别)。但是区别还是有的，对于一个<strong>变量</strong>来讲，变量注重的是指<strong>编译器开辟出的一块内存</strong>，通常和变量名捆绑出现。我们可以这样去理解：<strong>一个人相当于一变量，而变量名则是其人名</strong>。当一个变量被创建的时候(编译器开辟出一块内存)就相当于人出生，一个人出生可能并没有名字，对于变量而言就是变量被创建可能没有变量名。 对于对象来讲，<strong>对象就是内存中一段有类型的区域</strong>。对象更注重的是对内存类型的描述。严格来说<strong>对象就是用来描述变量的</strong>。</p>
<p>用代码去理解就是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">int i = 1;</span><br></pre></td></tr></table></figure>
<p>这里第一行的1其实就是一个变量，但是它并没有与之关联的变量名。但是它并不能被描述为一个对象，因为他的类型是不确定的。第二行的1也是一个变量，他的变量名是 i。在这里我们就能说它是一个 int 类型的对象其名为 i，其值是1。</p>
<p>关于变量和对象我推荐看<a href="https://blog.csdn.net/yby4769250/article/details/7377526" target="_blank" rel="noopener">这篇文章</a></p>
<p>关于这篇博客我找了很多的资料，但是没有找到比较权威的描述指针、指针变量、变量和对象的说明。所以这篇文章是我看了很多他人的博客加以总结并辅以自己的一些理解而写出来的，内容可能和事实上有偏差，所以我希望有了解的更深入的朋友告错我所在哪里，非常感谢！</p>
<blockquote>
<p>参考资料:</p>
<ul>
<li><p>Objective-C 指针:<a href="https://blog.csdn.net/senwin2009/article/details/48439361" target="_blank" rel="noopener">https://blog.csdn.net/senwin2009/article/details/48439361</a> </p>
</li>
<li><p>Objective-C 中的指针变量：<a href="https://www.jianshu.com/p/e93188a987c6" target="_blank" rel="noopener">https://www.jianshu.com/p/e93188a987c6</a> </p>
</li>
<li><p>iOS 之 OC中指针与对象的区别: <a href="https://www.jianshu.com/p/ca66606342f8" target="_blank" rel="noopener">https://www.jianshu.com/p/ca66606342f8</a> </p>
</li>
<li><p>iOS开发 – C语言基础8（指针）：<a href="https://www.jianshu.com/p/43f84673e8b1" target="_blank" rel="noopener">https://www.jianshu.com/p/43f84673e8b1</a> </p>
</li>
<li><p>tutorialspoint(OC 中的指针):</p>
<p><a href="https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm</a></p>
</li>
<li><p>维基百科——指针:</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)</a></p>
</li>
<li><p>关于指针的浅析:<a href="https://blog.csdn.net/qq_29924041/article/details/53822322" target="_blank" rel="noopener">https://blog.csdn.net/qq_29924041/article/details/53822322</a></p>
</li>
<li><p>C++ 指针运算符（&amp; 和 *）:<a href="http://www.runoob.com/cplusplus/cpp-pointer-operators.html" target="_blank" rel="noopener">http://www.runoob.com/cplusplus/cpp-pointer-operators.html</a></p>
</li>
<li><p>C++变量和对象的区别联系:<a href="https://blog.csdn.net/yby4769250/article/details/7377526" target="_blank" rel="noopener">https://blog.csdn.net/yby4769250/article/details/7377526</a></p>
</li>
<li><p>说说OC参数传递的那些坑：<a href="https://www.jianshu.com/p/d43dac503928" target="_blank" rel="noopener">https://www.jianshu.com/p/d43dac503928</a></p>
</li>
<li><p>二级指针与ARC不为人知的特性：<a href="https://www.jianshu.com/p/6a1cfef75092?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">https://www.jianshu.com/p/6a1cfef75092?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq</a></p>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Wong</p>
              <p class="site-description motion-element" itemprop="description">别在机会来临之时却无法握住。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Wong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
