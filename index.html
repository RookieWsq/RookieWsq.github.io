<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="别在机会来临之时却无法握住。">
<meta property="og:type" content="website">
<meta property="og:title" content="John 的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="John 的技术博客">
<meta property="og:description" content="别在机会来临之时却无法握住。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="John 的技术博客">
<meta name="twitter:description" content="别在机会来临之时却无法握住。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>John 的技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John 的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/02/arm汇编命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/02/arm汇编命令/" itemprop="url">arm汇编命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-02T19:11:50+08:00">
                2021-12-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="arm-汇编"><a href="#arm-汇编" class="headerlink" title="arm 汇编"></a>arm 汇编</h2><h3 id="寄存器组成"><a href="#寄存器组成" class="headerlink" title="寄存器组成"></a>寄存器组成</h3><p>arm64 通用寄存器：x0~x30 一共31 个64bit 寄存器。这 31 个通用的 64bit 寄存器又各包含了一个 32bit 寄存器w0~w30，一个 31 个 32bit 通用寄存器。</p>
<p>通用寄存器：</p>
<table>
<thead>
<tr>
<th style="text-align:left">寄存器名称</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x0~x7</td>
<td>用于传递子程序的参数，使用时不需要保存，多余参数保存在调用者栈中，通过栈传递给被调用函数。其中x0寄存器还可以作为返回值寄存器使用。</td>
</tr>
<tr>
<td style="text-align:left">x8</td>
<td>间接结果寄存器，使用时不需要保存，一般用于传递间接结果的地址，比如函数返回一个大的结构体，x8保存结构体地址。</td>
</tr>
<tr>
<td style="text-align:left">x9~x15</td>
<td>临时寄存器，子程序使用时不需要保存。</td>
</tr>
<tr>
<td style="text-align:left">x16~x17</td>
<td>又名IP0、IP1，内部过程调用寄存器，常用于动态链接中的plt寻址等指令。</td>
</tr>
<tr>
<td style="text-align:left">x18</td>
<td>平台预留寄存器，在不同的操作系统使用不一样。</td>
</tr>
<tr>
<td style="text-align:left">x19~x28</td>
<td>临时寄存器，子程序使用时必须保存。</td>
</tr>
<tr>
<td style="text-align:left">x29</td>
<td>帧指针寄存器（FP），用于连接栈帧，使用时必须保存。</td>
</tr>
<tr>
<td style="text-align:left">x30</td>
<td>链接寄存器（LR），用于保存子程序的返回地址。</td>
</tr>
</tbody>
</table>
<p>特殊作用的几个寄存器：</p>
<ul>
<li>pc 寄存器：用作程序计数器，功能相当于 8086 的 cs+ip 的功能。不是通用寄存器，无法直接访问。</li>
<li>sp 寄存器：别名是SP_EL0，用于存放当前栈顶指针。</li>
<li>fp寄存器：用于存放当前栈底指针，栈顶指针和栈底指针之间的空间是当前栈空间，在 backtrace 时可以查看到方法调用栈。</li>
<li>lr寄存器：当程序调用子程序时，lr 储存程序的返回地址。</li>
<li>程序状态寄存器：正常状态使用CPSR，异常状态使用SPSR，类似 8086 的标志寄存器。</li>
</ul>
<p>注意：没有名为 X31/W31 的寄存器，根据指令不同，寄存器 31 是栈指针(SP)或者零寄存器(32bit：WZR或64bit：XZR)。</p>
<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="指令分组"><a href="#指令分组" class="headerlink" title="指令分组"></a>指令分组</h3><p>指令分为四组：</p>
<ol>
<li>分支和控制：<ul>
<li>分支到子程序，并从子程序返回。</li>
<li>向后分支，以形成循环。</li>
<li>在条件结构中向前分支。</li>
<li>产生和返回异常。</li>
</ul>
</li>
<li>数据处理：这些指令使用通用寄存器进行加减、移位等操作。</li>
<li>寄存器加载和存储：这些指令从内存加载或从单个寄存器或寄存器对的值。</li>
<li>系统寄存器访问：这些指令将系统寄存器的内容移到通用寄存器或从通用寄存器移出。</li>
</ol>
<h3 id="具体指令"><a href="#具体指令" class="headerlink" title="具体指令"></a>具体指令</h3><h4 id="分支和控制指令"><a href="#分支和控制指令" class="headerlink" title="分支和控制指令"></a>分支和控制指令</h4><p>B：无条件转移指令，跳转到一个与 PC 相关的偏移量，类似 8086 的 jmp指令。</p>
<p>BL：无条件转移指令，跳转到 PC 相关的偏移量，并且 X30(PC)+=4。类似 8086 的 call指令，将保存SP、FP、LR和参数寄存器到栈，类似 8086 的 call 指令。</p>
<p>RET：从子程序返回。</p>
<h5 id="转移条件"><a href="#转移条件" class="headerlink" title="转移条件"></a>转移条件</h5><table>
<thead>
<tr>
<th>后缀</th>
<th>标志</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td>Z = 1</td>
<td>相等，上次标志设置结果为零</td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Z = 0</td>
<td>不相等，最后一次标志设置结果非零</td>
</tr>
<tr>
<td><code>CS or HS</code></td>
<td>C = 1</td>
<td>更高或相同，无符号</td>
</tr>
<tr>
<td><code>CC or LO</code></td>
<td>C = 0</td>
<td>较低，无符号</td>
</tr>
<tr>
<td><code>MI</code></td>
<td>N = 1</td>
<td>负的</td>
</tr>
<tr>
<td><code>PL</code></td>
<td>N = 0</td>
<td>正或零</td>
</tr>
<tr>
<td><code>VS</code></td>
<td>V = 1</td>
<td>溢出</td>
</tr>
<tr>
<td><code>VC</code></td>
<td>V = 0</td>
<td>无溢出</td>
</tr>
<tr>
<td><code>HI</code></td>
<td>C = 1 和 Z = 0</td>
<td>更高，无符号</td>
</tr>
<tr>
<td><code>LS</code></td>
<td>C = 0 或 Z = 1</td>
<td>较低或相同，无符号</td>
</tr>
<tr>
<td><code>GE</code></td>
<td>N = V</td>
<td>大于或等于，有符号</td>
</tr>
<tr>
<td><code>LT</code></td>
<td>N != V</td>
<td>小于，已签</td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Z = 0 且 N = V</td>
<td>大于，有符号</td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Z = 1 和 N != V</td>
<td>小于或等于，有符号</td>
</tr>
<tr>
<td><code>AL</code></td>
<td>可以有任何价值</td>
<td>总是。这是未指定后缀时的默认值。</td>
</tr>
</tbody>
</table>
<h4 id="寄存器加载和存储指令"><a href="#寄存器加载和存储指令" class="headerlink" title="寄存器加载和存储指令"></a>寄存器加载和存储指令</h4><p>在 ARM 中一个字(word)是32-bits，双字(dword)是64-bits。</p>
<h6 id="load-加载"><a href="#load-加载" class="headerlink" title="load 加载"></a>load 加载</h6><p>LDR：据基址寄存器值和偏移寄存器值计算内存地址加载数据，从内存中加载一个字(32bit)，并加载到指定寄存器。</p>
<p>LDUR：基址寄存器和立即偏移量计算内存地址，取其 32 或 64 位数据，并对其使用0 补充，并加载到指定寄存器。</p>
<h6 id="store-存储"><a href="#store-存储" class="headerlink" title="store 存储"></a>store 存储</h6><p>STR：根据基址寄存器值和偏移寄存器值计算内存地址，将 32 或 64 位信息从寄存器保存内存。</p>
<p>STUR：根据基址寄存器值和立即偏移量计算地址，将 32 或 64 位信息从寄存器保存内存。</p>
<p>STP：根据基址寄存器值和立即偏移量计算地址，并将两个 32 位字或两个 64 位双字从两个寄存器存储到计算出的地址。</p>
<h4 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h4><p>ADD：加法。</p>
<p>ADC：进位加法。</p>
<p>ADCS：进位加法，设置标志位，并根据加法结果设置条件标志。</p>
<p>SUB：减法。</p>
<p>AND：按位与。</p>
<p>ORR：按位或。</p>
<p>UDIV：无符号除法。</p>
<p>SDIV：带符号除法。</p>
<p>MADD：乘法，<code>MADD &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Wa&gt;</code>类似于<code>Wd = Wn * Wm + Wa</code>，该指令由 MUL 使用。</p>
<p>MUL：乘法，MADD 的别名。</p>
<p>MOV：赋值指令。</p>
<p>CMP：将两个寄存器内容或者立即数相减，根据结果设置标志位，并丢弃结果。</p>
<blockquote>
<p>资料:</p>
<p><a href="https://developer.arm.com/documentation/102374/0101?lang=en" target="_blank" rel="noopener">学习AArch64指令集架构</a></p>
<p><a href="https://support.huaweicloud.com/ref-kunpenggrf/kunpenggrffaq_10_0057.html#kunpenggrffaq_10_0057__table106609423185" target="_blank" rel="noopener">ARM 64通用寄存器-华为云</a></p>
<p><a href="https://developer.arm.com/documentation/dui0801/k/Overview-of-AArch64-state?lang=en" target="_blank" rel="noopener">AArch64 状态概览-armDeveloper</a></p>
<p><a href="https://developer.arm.com/documentation/ddi0602/2021-09" target="_blank" rel="noopener">Arm Armv9-A A64 指令集架构</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/02/Mach-O文件结构初探索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/02/Mach-O文件结构初探索/" itemprop="url">Mach-O文件结构初探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-02T18:42:53+08:00">
                2021-12-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mach-O文件结构初探索"><a href="#Mach-O文件结构初探索" class="headerlink" title="Mach-O文件结构初探索"></a>Mach-O文件结构初探索</h1><h2 id="什么是-Mach-O-文件"><a href="#什么是-Mach-O-文件" class="headerlink" title="什么是 Mach-O 文件"></a>什么是 Mach-O 文件</h2><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）以及 Windows 上的 PE。</p>
<h2 id="Mach-O-构成"><a href="#Mach-O-构成" class="headerlink" title="Mach-O 构成"></a>Mach-O 构成</h2><p>Mach-O文件分成四部分：</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/Mach-O 结构.png" alt="image-20211115214823308" style="zoom:67%;"></p>
<ul>
<li>header：包含文件的目标架构，CPU类型，以及其他标志和信息以便读取文件的其他部分。</li>
<li>Load Command：Load Command跟在 header 之后，指定了文件在加载时将如何在虚拟内存中布局和文件连接特性，还包括符号表（用于动态链接）位置，以及任何要加载的共享库的名字。</li>
<li>segment 和 section：跟在 load command 之后，load command 中的具体描述保存在这部分。</li>
<li>link edit segment：最后一部分是链接编辑段，该段包含链接编辑信息表，如符号表、字符串表等，由动态加载器用于链接可执行文件或Mach-O捆绑包到其依赖库。</li>
</ul>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView 查看 Mach-O.png" alt="image-20211129234917525" style="zoom:75%;"></p>
<h2 id="一、header"><a href="#一、header" class="headerlink" title="一、header"></a>一、header</h2><h3 id="header-概述"><a href="#header-概述" class="headerlink" title="header 概述"></a>header 概述</h3><p>Mach-O 的第一部分 header 中包含的信息描述了Mach-O 结构的概况，包括：目标架构，CPU情况，文件类型，loadCommand 数量，loadCommand 所占用大小(字节为单位)等等。我们接下来从源码出发探寻 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h</a> (文件中分别定义了32 位架构和 64 位架构的头结构，下文我们以 64 位为例)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* 魔数标记 */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* CPU 标记 */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* CPU确切型号 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* 文件类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* load command 数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* load commands 大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 额外标记 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* 保留 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>变量说明：</p>
<ul>
<li><p>magic：本质上是一个 4 字节整型数据，用于标识是 32 位架构还是 64 位架构，并且还能标识Mach-O 文件的大小端序。</p>
<ul>
<li>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> / <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/fat.h" target="_blank" rel="noopener">fat.h</a>中定义。</li>
<li>64 位小端：<code>#define MH_MAGIC_64 0xfeedfacf</code>。</li>
<li>64 位大端：<code>#define MH_CIGAM_64 0xcffaedfe</code>。</li>
<li>32 位小端：<code>#define    MH_MAGIC    0xfeedface</code>。</li>
<li>32 位大端：<code>#define MH_CIGAM    0xcefaedfe</code>。</li>
<li>胖二进制小端：<code>#define FAT_MAGIC    0xcafebabe</code>。</li>
<li>胖二进制大端：<code>#define FAT_CIGAM    0xbebafeca</code>。</li>
</ul>
</li>
<li><p>cputype：本质上一个是4 字节整型数据，用于表示运行 Mach-O 文件平台 CPU 的架构。</p>
<ul>
<li>值在  <a href="https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/machine.h" target="_blank" rel="noopener">machine.h</a> 文件中定义。</li>
<li>早期 arm CPU：<code>#define CPU_TYPE_ARM            ((cpu_type_t) 12)</code>。</li>
<li>arm64 CPU：<code>#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</code>，值为 <code>0100000C</code> 。</li>
<li>64 位英特尔 CPU：<code>#define CPU_TYPE_X86_64         (CPU_TYPE_X86 | CPU_ARCH_ABI64)</code>，值为<code>01000007</code>。</li>
</ul>
</li>
<li><p>cpusubtype：本质上一个是4 字节整型数据，用于在 cputtype 确定的情况下内核运行的确切 CPU 型号。</p>
<ul>
<li>值在  <a href="https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/machine.h" target="_blank" rel="noopener">machine.h</a> 文件中定义。</li>
<li>ARM64平台下：<ul>
<li>ARM64所有型号：<code>#define CPU_SUBTYPE_ARM64_ALL           ((cpu_subtype_t) 0)</code>。</li>
<li>ARM64_v8：<code>#define CPU_SUBTYPE_ARM64_V8            ((cpu_subtype_t) 1)</code>。</li>
<li>ARM64e：<code>#define CPU_SUBTYPE_ARM64E              ((cpu_subtype_t) 2)</code>。</li>
</ul>
</li>
<li>X86平台下：<ul>
<li>X86 所有型号：<code>#define CPU_SUBTYPE_X86_ALL             ((cpu_subtype_t)3)</code>。</li>
<li>X86 下 64位所有：<code>#define CPU_SUBTYPE_X86_64_ALL          ((cpu_subtype_t)3)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>filetype：表示 Mach-O 文件的类型。</p>
<ul>
<li><p>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中定义。</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/header-filetype.png" alt="image-20211128013604436"></p>
</li>
<li><p>MH_OBJECT:目标文件——通过对源代码编译得到的(中间)结果。目标文件（.o）、静态库文件(.a），静态库其实就是N个.o合并在一起。</p>
</li>
<li><p>MH_EXECUTE：标准可执行文件。</p>
</li>
<li><p>MH_DYLIB：动态库文件，*.dylib，.framework/xx。</p>
</li>
<li><p>MH_DYLINKER：动态链接编辑器，/usr/lib/dyld。注意 dyld 负责加载 MH_EXECUTE、MH_DYLIB和部分MH_BUNDLE文件(<a href="https://github.com/opensource-apple/dyld/blob/master/src/dyld.cpp" target="_blank" rel="noopener">dyld 源码</a>)。</p>
</li>
<li><p>MH_BUNDLE：插件，非独立的二进制文件，要加载至其他二进制文件才能发挥作用。和 DYLIB类型文件的区别在于：这些二进制文件是可执行文件显示地加载的，通常是调用 NSBundle(Objective-C)或 CFBundle(C)。</p>
</li>
<li><p>MH_DSYM：存储着二进制文件符号信息的文件，*.dSYM/Contents/Resources/DWARF/xx（常用于分析APP的崩溃信息）。</p>
</li>
</ul>
</li>
<li><p>ncmds：load command 数量(number of load commands)。</p>
</li>
<li><p>sizeofcmds：load command所占用的内存大小(字节为单位)。</p>
</li>
<li><p>flags：额外标记，表示Mach-O文件格式的某些可选特性的状态。</p>
<ul>
<li>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中定义。</li>
<li>MH_NOUNDEFS：该对象文件不包含未定义的符号。</li>
<li>MH_INCRLINK：对象文件是针对基础文件的增量链接的输出，不能被再次链接。</li>
<li>MH_DYLDLINK：该文件是动态链接器的输入，不能再次静态链接。</li>
<li>MH_TWOLEVEL：该模块使用两级命名空间绑定。</li>
<li>MH_FORCE_FLAT：可执行程序强迫所有模块使用平面名称空间绑定。</li>
<li>MH_WEAK_DEFINES：最终的链接模块包含外部弱符号。</li>
<li>MH_PREBOUND：该文件有其动态未定义引用的预绑定。</li>
<li>MH_PIE：当这个位被设置时，操作系统将在一个随机地址加载主可执行文件(<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5" target="_blank" rel="noopener">ASLR 技术</a>)。 只在MH_EXECUTE文件类型中使用。</li>
<li>MH_HAS_TLV_DESCRIPTORS：包含一个类型为S_THREAD_LOCAL_VARIABLES的section。</li>
</ul>
</li>
<li><p>reserved：保留给未来用。</p>
</li>
</ul>
<p>接下来我们通过实例来查看header 的具体构成：</p>
<h3 id="header-查看"><a href="#header-查看" class="headerlink" title="header 查看"></a>header 查看</h3><ol>
<li><p>使用 GUI 工具 MachOView：</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView-header.png" alt="image-20211128185142510"></p>
<p>由图可知该 MachO 文件类型是 NH_EXECUTE ，有 66 个 load command 等一系列信息。</p>
</li>
<li><p>file 命令查看文件类型及架构：<code>file &lt;filepath&gt;</code>，例如：<code>file /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</p>
</li>
<li><p>通过 lipo 命令查看所支持的架构：</p>
<p>lipo命令路径：<code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</p>
<p>开源地址：<a href="https://opensource.apple.com/tarballs/cctools/" target="_blank" rel="noopener">cctools/misc/lipo.c</a>。</p>
<p>lipo命令格式：</p>
<ul>
<li><p>查看帮助：<code>man lipo</code>。</p>
</li>
<li><p>查看支持多少种 CPU架构：</p>
<ul>
<li>格式：<code>lipo -info 文件路径</code> 。</li>
<li>例子：<code>lipo -info /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</li>
</ul>
</li>
<li>合并多个架构：<ul>
<li>格式：<code>lipo [-arch 指定架构] -create 文件1 文件2 -output 输出文件</code>。</li>
<li>-arch 指定架构参数可选，如果指定的话会将文件 1 文件 2 中的指定架构从输入文件中复制到输出文件。</li>
</ul>
</li>
<li>提取指定架构：<ul>
<li>格式：<code>lipo 文件路径 -thin 指定架构 -output 输出文件</code>。</li>
</ul>
</li>
<li>移除特定架构：<ul>
<li>格式：<code>lipo 文件路径 -remove 指定架构 -output 输出文件</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="二、Load-Command"><a href="#二、Load-Command" class="headerlink" title="二、Load Command"></a>二、Load Command</h2><h3 id="Load-Command概述"><a href="#Load-Command概述" class="headerlink" title="Load Command概述"></a>Load Command概述</h3><p>跟在 header 之后的就是 Load Command，Load Command负责描述指令在内存中的布局情况和文件连接特性，还包括符号表（用于动态链接）位置，以及任何要加载的共享库。</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView-load command-overview.png" alt="image-20211128221136653" style="zoom: 67%;"></p>
<p>LoadCommand 中的加载指令有很多种，<code>LC_SEGMENT_64</code>、<code>LC_DYLD_INFO_ONLY</code>、<code>LC_UUID</code>等等。接下来我们通过具体实例查看和分析 LoadCommand 实际组成。</p>
<h3 id="Load-Command-查看"><a href="#Load-Command-查看" class="headerlink" title="Load Command 查看"></a>Load Command 查看</h3><p>在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中声明了Load Command 指令的基础结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* load command类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* load command的字节长度 64位架构的值是 8 的倍数   32 位架构的值是 4 的倍数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cmd：指令类型。定义在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中：</p>
<table>
<thead>
<tr>
<th>指令(定义在<a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>指令值(定义在<a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>指令对应的函数(定义在 <a href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/kern/mach_loader.c" target="_blank" rel="noopener">mach_loader.c</a> )</th>
<th>对应的数据结构(定义在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_SEGMENT_64</td>
<td>0x19</td>
<td>load_segment</td>
<td>segment_command_64</td>
<td>定义一个 64 位段，将其映射到加载该文件的进程的地址空间。它还包括该段所包含的所有部分。</td>
</tr>
<tr>
<td>LC_DYLD_INFO_ONLY</td>
<td>0x80000022</td>
<td>由 dyld 处理</td>
<td>dyld_info_command</td>
<td>告知 dyld 加载 image 所需的偏移信息(Dynamic Loader Info包含具体信息)。</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td>0x2</td>
<td>由 dyld 处理</td>
<td>symtab_command</td>
<td>为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义的和未定义的 external 符号被链接器所使用。</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td>0xb</td>
<td>由 dyld 处理</td>
<td>dysymtab_command</td>
<td>指定动态链接器使用的额外符号表信息。</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>0xe</td>
<td>load_dylinker</td>
<td>dylinker_command</td>
<td>指定内核在加载该文件所链接的动态共享库的路径。</td>
</tr>
<tr>
<td>LC_UUID</td>
<td>0x1b</td>
<td>load_uuid</td>
<td>uuid_command</td>
<td>产生一个唯一的 128 位随机数来标识当前可执行文件或其 dSYM 文件。</td>
</tr>
<tr>
<td>LC_VERSION_MIN_IPHONEOS</td>
<td>0x25</td>
<td>load_version</td>
<td>version_min_command</td>
<td>指定当前可执行文件最低可运行系统版本。</td>
</tr>
<tr>
<td>LC_SOURCE_VERSION</td>
<td>0x2A</td>
<td></td>
<td>source_version_command</td>
<td>用来构建二进制文件的源版本</td>
</tr>
<tr>
<td>LC_MAIN</td>
<td>0x80000028</td>
<td>load_main</td>
<td>entry_point_command</td>
<td>定义程序入口，设置程序主线程的入口点地址和栈大小。</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO_64</td>
<td>0x2C</td>
<td>由 dyld 处理</td>
<td>encryption_info_command_64</td>
<td>指示加壳时加密段偏移和大小。</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>0xc</td>
<td>由 dyld 处理</td>
<td>dylib_command</td>
<td>指示需要加载的额外的动态库的信息，包括：库版本、库路径等。可以使用命令”otool -L xxx”查看。</td>
</tr>
<tr>
<td>LC_LOAD_WEAK_DYLIB</td>
<td>0x80000018</td>
<td>由 dyld 处理</td>
<td>dylib_command</td>
<td>建立在LC_LOAD_DYLIB功能的基础上，如果未找到指定的库，就忽略这个库。</td>
</tr>
<tr>
<td>LC_RPATH</td>
<td>0x8000001C</td>
<td>由 dyld 处理</td>
<td>rpath_command</td>
<td>Runpath Search Paths，包含一个路径，在运行时应该被添加到当前的运行路径中，用于寻找@rpath前缀的dylibs。</td>
</tr>
<tr>
<td>LC_FUNCTION_STARTS</td>
<td>0x26</td>
<td>由 dyld 处理</td>
<td>linkedit_data_command</td>
<td>指示函数起始地址表。</td>
</tr>
<tr>
<td>LC_DATA_IN_CODE</td>
<td>0x29</td>
<td>由 dyld 处理</td>
<td>linkedit_data_command</td>
<td>指示定义在代码段内的非指令的表。</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td>0x1d</td>
<td>load_code_signature</td>
<td>linkedit_data_command</td>
<td>定义代码签名信息。</td>
</tr>
</tbody>
</table>
<p>接下来我们着重分析几个加载命令：</p>
<h4 id="1-LC-SEGMENT-64"><a href="#1-LC-SEGMENT-64" class="headerlink" title="1.LC_SEGMENT_64"></a>1.LC_SEGMENT_64</h4><p>LC_SEGMENT_64命令是最重要的加载命令之一。这条命令负责将 segment 映射到内存中。</p>
<p>segument 定义了Mach-O文件中的字节范围，以及这些字节在动态链接器加载应用程序时被映射到虚拟内存的地址和内存保护属性。</p>
<p>segument 提供的信息结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* 表示LC_SEGMENT_64 值为0x19 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* load command 所占用的字节大小 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment 名称 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* segment 映射到虚拟内存的偏移 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* segment 映射到虚拟内存的大小 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* segment 在当前架构文件中的偏移  */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* segment 在当前架构文件中所对应的文件的大小 */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* segment 的最高内存保护级别，用八进制表示(4=r，2=w，1=x) */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* segment 最初始的内存保护级别 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* segment 中 section 的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 标记位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LC_SEGMENT_64的执行逻辑：内核将从偏移量 fileoff 出的 filesize 字节加载到虚拟内存中，这块虚拟内存起始地址为 vmaddr 长度是 vmsize。并且每个 segment 的页面的权限都由 initprot 进行初始化。segment 权限可以改变，但是最高不能超过 maxprot 所规定的的权限级别。级别权限在 <a href="osfmk/mach/vm_prot.h">osfmk/mach/vm_prot.h</a> 中定义。</p>
<p>LC_SEGMENT_64能加载如下几个段：</p>
<ul>
<li><strong>PAGEZERO：静态链接器创建了 `</strong>PAGEZERO<code>段作为可执行文件的第一个段。这个段位于虚拟内存0 处，占据虚拟内存大小是64位架构下：0x100000000 。并且由于</code>__PAGEZERO`段中没有数据，所以它在文件中不占空间。</li>
<li>__TEXT：包含可执行代码和其他只读数据，并且静态链接器将该 segment 的虚拟内存权限设置为不可写入。</li>
<li>__DATA：包含可读写数据，静态链接器设置上个页面的虚拟内存权限为允许读和写。</li>
<li>__OBJC：包含Objective-C语言运行时支持库所使用的数据。</li>
<li>__IMPORT： 段包含了符号存根和指向未在可执行文件中定义的符号的非懒惰指针。这个段只为针对IA-32结构的可执行文件而产生。</li>
<li>__LINKEDIT：包含动态链接器使用的原始数据，如符号、字符串和重定位表项。</li>
</ul>
<p>对于一些 segment (<code>__TEXT</code>、<code>__OBJC</code>、<code>__DATA</code>)来说，有时候其中包含的信息也被分解成不同的 section。section 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment 名字 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* section 映射到虚拟内存的偏移 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	size;		<span class="comment">/* section 的字节数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* section 在当前架构文件中的偏移 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section 的字节对齐大小 n，计算结果为2的n次方 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* 重定位入口的个数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* section 的类型和属性*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* 保留位 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* 保留位 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* 保留位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>__TEXT的 section：</p>
<table>
<thead>
<tr>
<th>segment,section</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__TEXT,__text</code></td>
<td>程序可执行的代码</td>
</tr>
<tr>
<td><code>__TEXT,__stubs</code></td>
<td>用于动态链接的桩</td>
</tr>
<tr>
<td><code>__TEXT,__stubs</code></td>
<td>用于动态链接的桩</td>
</tr>
<tr>
<td><code>__TEXT,__const</code></td>
<td>const关键字修饰的常量</td>
</tr>
<tr>
<td><code>__TEXT,__objc_methname</code></td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td><code>__TEXT,__ustring</code></td>
<td>unicode字符串</td>
</tr>
<tr>
<td><code>__TEXT,__cstring</code></td>
<td>C 中的常量字符串</td>
</tr>
<tr>
<td><code>__TEXT,__objc_classname</code></td>
<td>Objective-C 类名</td>
</tr>
<tr>
<td><code>__TEXT,__objc_methtype</code></td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td><code>__TEXT,__gcc_except_tab</code></td>
<td>gcc异常表</td>
</tr>
<tr>
<td><code>__TEXT,__unwind_info</code></td>
<td>用于确定异常发生时栈所对应的信息</td>
</tr>
<tr>
<td><code>__TEXT,__eh_frame</code></td>
<td>调试符号信息</td>
</tr>
</tbody>
</table>
<p>__DATA 的 section：</p>
<table>
<thead>
<tr>
<th>segment,section</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__DATA,__const</code></td>
<td>初始化可重新定位的常量变量。</td>
</tr>
<tr>
<td><code>__DATA,__cfstring</code></td>
<td>程序中使用的 CoreFoundation 字符串(CFStringRefs)</td>
</tr>
<tr>
<td><code>__DATA,__classlist</code></td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td><code>__DATA,__nlcslist</code></td>
<td>保存了Objective-C 的categories的 +load函数列表。</td>
</tr>
<tr>
<td><code>__DATA,__catlist</code></td>
<td>Objective-C 分类信息</td>
</tr>
<tr>
<td><code>__DATA,__protolist</code></td>
<td>包含Objective-C所有协议列表</td>
</tr>
<tr>
<td><code>__DATA,__imageinfo</code></td>
<td>保存了Objective-C 镜像信息。</td>
</tr>
<tr>
<td><code>__DATA,__selrefs</code></td>
<td>保存了Objective-C 方法调用者的信息。</td>
</tr>
<tr>
<td><code>__DATA,__objc_classrefs</code></td>
<td>保存了 Objective-C 被使用的类的引用信息。</td>
</tr>
<tr>
<td><code>__DATA,__objc_superrefs</code></td>
<td>保存了 Objective-C 调用了 super 方法的类的引用。</td>
</tr>
<tr>
<td><code>__DATA,__objc_ivar</code></td>
<td>保存了 Objective-C 中的 ivar 指针。</td>
</tr>
<tr>
<td><code>__DATA,__objc_data</code></td>
<td>存储的就是<code>objc_class</code>的所有成员</td>
</tr>
<tr>
<td><code>__DATA,__data</code></td>
<td>储存可变变量。</td>
</tr>
</tbody>
</table>
<h4 id="2-LC-MAIN"><a href="#2-LC-MAIN" class="headerlink" title="2.LC_MAIN"></a>2.LC_MAIN</h4><p>这条命令的作用是设置程序主线程的入口点地址和栈大小。</p>
<h4 id="3-LC-CODE-SIGNATURE"><a href="#3-LC-CODE-SIGNATURE" class="headerlink" title="3.LC_CODE_SIGNATURE"></a>3.LC_CODE_SIGNATURE</h4><p>可执行文件进行签名之后会添加此条 load command。</p>
<h2 id="三、segment-和-section"><a href="#三、segment-和-section" class="headerlink" title="三、segment 和 section"></a>三、segment 和 section</h2><p>这部分所包含的信息是 load command 数据的具体描述。</p>
<h2 id="四、link-edit-segment"><a href="#四、link-edit-segment" class="headerlink" title="四、link edit segment"></a>四、link edit segment</h2><p>该段包含链接编辑信息表，如符号表、字符串表等，由动态加载器用于链接可执行文件或Mach-O捆绑包到其依赖库。</p>
<blockquote>
<p>资料：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001519" target="_blank" rel="noopener">Mach-O Programming Topics</a></p>
<p><a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener">osx-abi-macho-file-format-reference</a></p>
<p><a href="https://www.leewong.cn/2020/08/30/Mach-O/" target="_blank" rel="noopener">Mach-O 探究</a></p>
<p><a href="https://devyang.space/2020/01/10/%E4%BB%8Ellvm%E7%9C%8BmachO/" target="_blank" rel="noopener">从LLVM看MachO</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/11/Instrument文档翻译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/11/Instrument文档翻译/" itemprop="url">Instrument文档翻译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-11T17:11:59+08:00">
                2021-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Instrument文档翻译"><a href="#Instrument文档翻译" class="headerlink" title="Instrument文档翻译"></a>Instrument文档翻译</h1><h2 id="关于Instrument"><a href="#关于Instrument" class="headerlink" title="关于Instrument"></a>关于Instrument</h2><h3 id="Instruments概述"><a href="#Instruments概述" class="headerlink" title="Instruments概述"></a>Instruments概述</h3><p>Instrument是 Xcode 工具集中的一个强大且灵活的性能分析和测试工具。它能够分析iOS，watchOS和 macOS的 app，以便您能够更好的理解和优化其行为并提高其性能。在您 app 开发的最初就将 Instrument 加入您的工作流当中能够在app 开发早期就帮助您发现问题以便减少后来的时间。</p>
<p>在Instrument中您使用的特殊工具被称作instruments，他们能够跟踪您app进程和硬件设备等不同方面。instruments将会手机数据以作分析，并将分析结果以图标的形式呈现出来。</p>
<p>Instruments与其他性能和调试工具不同的是，instruments允许你收集多种不同类型的数据并将其并排展示。这养能够轻易的分辨可能被遗漏的趋势。举个例子，由于多个开放的网络连接，您 app 出现巨大的内存增长时，通过同时使用Allocations和Connections这俩instruments工具，你能够识别出因未关闭而导致内存暴增的连接。</p>
<p>通过高效使用Instrument，你能够</p>
<ul>
<li>检查一个或多个 app 或进程</li>
<li>检查类似 WIFI和蓝牙这类设备特性</li>
<li>在模拟器或者真机上做性能分析</li>
<li>跟踪代码中出现的问题</li>
<li>对您的 app 进行性能分析</li>
<li>在您 app 中找到类似内存泄漏，弃用内存和僵尸对象</li>
<li>识别出使您 app 提高电源效率的方法</li>
<li>进行的常规系统级别的问题分析</li>
<li>将 Instrument 配置信息作为模板保存</li>
</ul>
<p>尽管他已嵌入并可以与Xcode 一同使用，Instruments还是一个独立的软件，这意味着在需要的时候Instruments可以独立使用。</p>
<p><a href="https://help.apple.com/instruments/developer/mac/current/" target="_blank" rel="noopener">Instruments开发帮助</a></p>
<h3 id="关于跟踪-trace-的文档"><a href="#关于跟踪-trace-的文档" class="headerlink" title="关于跟踪(trace)的文档"></a>关于跟踪(trace)的文档</h3><p>跟踪文档常被用来作为组织和配置用于分析的instruments，数据收集的发起，和查看分析结果。你可以通过启动Instruments之后选择分析模板或者直接从Xcode，Dock，命令行启动分析的方式来创建一个新的跟踪文档。您同样可以保存和重新打开您已经配置过的instruments并收集过数据的跟踪文档。一个跟踪文档可以通过多个窗格和区域的方式呈现出极其详尽的信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/51452EE2-B973-4C3C-A19F-A398AD0E5A59.png" alt="51452EE2-B973-4C3C-A19F-A398AD0E5A59"></p>
<p>跟踪文档包括如下多个主区域</p>
<ul>
<li>工具栏：允许但不限于您开始，暂停和结束数据分析，添加instruments，隐藏或者显示窗格。查看<a href="https://help.apple.com/instruments/mac/10.0/#/dev546b5b54" target="_blank" rel="noopener">关于跟踪文档工具栏</a></li>
<li>时间线窗格：以图形化模式展示指定跟踪(trace)所记录的数据的概要。查看<a href="https://help.apple.com/instruments/mac/10.0/#/devc12c5417" target="_blank" rel="noopener">关于跟踪文档时间线窗格</a></li>
<li>详情窗格：展示在您跟踪文档中使用instruments所收集的数据的详细信息。查看<a href="https://help.apple.com/instruments/mac/10.0/#/dev9b08bd72" target="_blank" rel="noopener">关于跟踪文档详情窗格</a></li>
<li>检查器窗格：包含关于当前数据记录的信息概要和instruments具体的扩展详情。查看<a href="https://help.apple.com/instruments/mac/10.0/#/devd72c957d" target="_blank" rel="noopener">关于跟踪文档检查器窗格</a></li>
</ul>
<h3 id="关于跟踪文档工具栏"><a href="#关于跟踪文档工具栏" class="headerlink" title="关于跟踪文档工具栏"></a>关于跟踪文档工具栏</h3><p>跟踪文档工具栏允许但不限于您开始，暂停和结束数据分析，添加instruments，隐藏或者显示窗格。</p>
<p>工具栏包含如下主要对象：</p>
<ul>
<li>分析控件：允许您记录，暂停和停止数据收集。</li>
<li>目标设备列表：允许您选择您希望分析的设备。</li>
<li>目标进程列表：允许您选择一个或多个进程用于分析。</li>
<li>活动查看器：展示跟踪文档的运行数量和当前跟踪(trace)的流逝时间。</li>
<li>添加Instrument按钮(+)：展示或隐藏包含所有可用instruments库模列表。在列表中你可以单独选择将它们添加到跟踪文档中。</li>
<li>查看按钮：显示或隐藏详情和检查器窗格。</li>
</ul>
<h3 id="关于跟踪文档时间线窗格"><a href="#关于跟踪文档时间线窗格" class="headerlink" title="关于跟踪文档时间线窗格"></a>关于跟踪文档时间线窗格</h3><p>时间线窗格以图形化模式展示指定跟踪(trace)所记录的数据的概要。在这个窗格中任意一个instrument，CPU核心或线程都有其各自跟踪(trace)，这个跟踪能够提供所收集到数据的图形化表格。</p>
<p>虽然这个窗格的信息是只读的，但是你能够通过滑动数据来选择需要仔细查看的指定区域，并插入标记以突显您感兴趣的点。你可以通过改变缩放级别，或者使用<a href="https://help.apple.com/instruments/mac/10.0/#/deva13e2923b" target="_blank" rel="noopener">显示配置弹出框</a>来改变一个独立instruments的显示配置来更改图形信息显示方式。instrument有一个可选择的过滤器栏来控制过滤数据的显示方式。例如，一个简单的instrument能够通过线程来过滤数据。</p>
<p>当你调查问题的时候可以通过将时间线固定到隔窗底部的方式来保持重要信息的显示。举个例子，你能够固定将Leaks instrument固定在窗格底部，接着通过滑动其他instruments来查找和发现可能发生内存泄漏的地方。被固定的instruments不会在多个运行之间保存。</p>
<p><img src="/2021/04/11/Instrument文档翻译/3EB44883-494C-4B0C-8C4C-06EFE03313A4.png" alt="3EB44883-494C-4B0C-8C4C-06EFE03313A4"></p>
<p>策略视图</p>
<p>点击筛选视图中的策略按钮在时间线中单独或同时显示instruments或CPU核心或线程数据。</p>
<p><img src="/2021/04/11/Instrument文档翻译/82A15CE7-10F3-4DDA-B79B-E5F9E8951416.png" alt="82A15CE7-10F3-4DDA-B79B-E5F9E8951416"></p>
<p>ALL：在时间线中展示instruments，线程和CPU核心数据。</p>
<p>CPUs：显示CPU核心列表，并在时间线窗格中单独展示随着时间改变它们的使用情况。只有当一个跟踪文档中包含记录了CPU数据的instruments时，才可用。</p>
<p><img src="/2021/04/11/Instrument文档翻译/64707226-3F58-4156-8C51-7C205735C864.png" alt="64707226-3F58-4156-8C51-7C205735C864"></p>
<p>Instruments：在时间线窗格中展示instruments列表和其数据。</p>
<p>当你在列表中选择了instrument，你可以在监控窗格中删除或者配置它。当你创建一个跟踪文档时instruments列表是默认可见的。</p>
<p><img src="/2021/04/11/Instrument文档翻译/4AFEA707-9FC7-45C4-9243-225D355F2E9F.png" alt="4AFEA707-9FC7-45C4-9243-225D355F2E9F"></p>
<p>Threads：在时间窗格中显示线程列表和其所使用的数据。只有在跟踪文档所包含的instruments记录了线程数据时才可见。</p>
<p><img src="/2021/04/11/Instrument文档翻译/74EABEE3-8F29-43D6-8D85-95E9CF8A382C.png" alt="74EABEE3-8F29-43D6-8D85-95E9CF8A382C"></p>
<h3 id="关于显示配置弹窗"><a href="#关于显示配置弹窗" class="headerlink" title="关于显示配置弹窗"></a>关于显示配置弹窗</h3><p>使用显示配置弹窗来配置在时间线中需要展示的数据和其展示格式。</p>
<p>在显示配置弹窗中可用的显示设置根据instrument而异。这些设置能帮助你：</p>
<ul>
<li>控制数据在时间线中的出现。例如：Activity instrument允许你切换总线程，虚拟机大小，和其他系统统计信息的显示。</li>
<li>调整被记录信息在时间线中的呈现方式。例如，instrument可能能让你在峰图和框图中切换。</li>
</ul>
<p>要打开显示配置窗口，请在跟踪文档的时间线窗格中点击instrument图标。当指针移到图标上方时，支持显示配置弹出框的instrument会显示一个指示器。</p>
<h3 id="关于跟踪文档详情窗格"><a href="#关于跟踪文档详情窗格" class="headerlink" title="关于跟踪文档详情窗格"></a>关于跟踪文档详情窗格</h3><p>详情窗格中展示在跟踪文档中使用instruments所收集到的数据的详情信息。正在分析时可以在时间线窗格中选择独立的instruments来查看所收集到的数据。</p>
<p>详情窗格由导航栏，数据收集区域和筛选配置栏三个区域构成。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane.png" alt="img"></p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>导航栏在详情窗格的顶部，它能够帮助你快速浏览收集到的数据。</p>
<p>你能够在导航栏中切换数据类型并查看不同的级别的数据。</p>
<ul>
<li>Instrument：当前时间线窗格中所选择的instrument的图标。点击它能够查看instrument的控制台。</li>
<li>Detail type list：能够在不同类型数据之间切换。对不同的Instrument其显示选项有差异。对于多数instruments，它们都包含了例如数据概要，调用树和控制台。</li>
<li>Detail tree：对您在详情窗格中数据查看时对其层级持续的跟踪。点击tree分支来选择与层级相符的数据。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_navigation_bar.png" alt="img"></p>
<h4 id="数据收集区"><a href="#数据收集区" class="headerlink" title="数据收集区"></a>数据收集区</h4><p>数据收集区展示所选instrument收集的所有数据，并通常以表格形式展现。不同instrument之间在这里展现的内容也会有显著不同。例如，Activity Monitor显示进程，CPU和线程，以及更多信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_collected_data_table.png" alt="img"></p>
<p>通常，在这个区域中的独立符号和数据点包含了导航按钮(<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACWElEQVRYw+2XZ4siQRCG9///EXNAVMQsooIJFQOCYkJBPyiiKMZanoZZ2r05xvO8deFWKJjQ9dYz1VXd7Zu8+Pf2A/DtAa7Xq2y3WxmPx9JqtaRcLksul5NsNiuZTEYZ1zzjHWMYiw++DwHgeLlcZL/fy3K5lOFwKJVKRVKplIRCIfH5fOLxeMTtdivjmme8Ywxj8cEXDbR+B2MKgMPhcJDFYiH1el2SyeRNYKfTaWo6CD74ooEWmncDQI1ju92WWCymhB0Oh9jt9ruMsfjgiwZaaN4FQKpIHfQI+P3+PwquQ+CLBlpomk3DLwCbzUbNHyk0vtxms5kGcblcEggElFELOig+RiaoCzQpTEuA0Wikqpl5tPpyAufzeSkUChIMBlUdfPbhHi0Kk+6wBKCNIKaYrNIciUSk0+lIr9dTENyTdjKjg6CFJtqWAMbXkzorgHg8LpPJRNbrtUynU2k2m2rqDAhjHFpolkolawAWFIhJpy7A1yGuW7ValdVqJefzWVX5fD6XRqOhFqdwOCxer/ejRdFE2xKAVc3odT3V3W5XBdCN4MfjUVW3AUG1DwYDKRaLEo1GPyDQRNsSAHoqWgdIJBIym83kdDrdGEH11jJAgGC+0+m0mg600ET7IQB6mTaiRXXb7XYq4FMBzKaAAqrVatLv92+MrJD2p06BWRFCDwSCulHVBHxqEf7LNkT7+y9ELJcsmy9bitkwjM3I2GD+djNC6+7NyNiOqfqXbMfPOpCQkYcOJM88kpHFh45kZodSWujLDqWfYVh2Oah82bH855/RfwXwDvGnbAtXk4lSAAAAAElFTkSuQmCC" alt="img">)，当你指向它的时候它才会出现。您可以点击按钮进入数据的更深层。当你点击进入时，在导航栏的详情树会随之更新并指向您所在的层级。</p>
<h4 id="筛选配置栏"><a href="#筛选配置栏" class="headerlink" title="筛选配置栏"></a>筛选配置栏</h4><p>在详情窗格底部的筛选配置栏能够帮你筛选所收集到的数据并配置数据显示的方式。</p>
<ul>
<li>Filter field：允许您以指定条件筛选所收集到的数据。点击筛选按钮区域会出现一些筛选选项。你同样可以通过在展示配置弹窗中调整显示设置的方式收集更多的数据。</li>
<li>Display configuration controls：通过筛选，排序和数据挖掘来优化显示结果。instrument之间的控制会有差异，包括不同的结果选择菜单和用于数据显示的弹窗。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_filter_config_bar.png" alt="A screenshot of the filter and display configuration bar showing the filter field on the left followed by a configuration drop-down, and buttons that show popovers with other display configuration options."></p>
<h3 id="关于跟踪文档的监视器窗格"><a href="#关于跟踪文档的监视器窗格" class="headerlink" title="关于跟踪文档的监视器窗格"></a>关于跟踪文档的监视器窗格</h3><p>监视器窗口包含在当前详情窗格当前运行的信息。这些信息包含当前记录的信息，并对于一些instruments还会包含当前所选数据的额外详情。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_navigation_bar.png" alt="img"></p>
<h4 id="运行信息区域"><a href="#运行信息区域" class="headerlink" title="运行信息区域"></a>运行信息区域</h4><p>运行区域展示详情窗格中当前的运行信息。包含目标，记录时间，记录所用到的设置。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_run_information.png" alt="A screenshot of the run information area of the detail pain inspector showing the recording information and recording settings for the current recording."></p>
<h4 id="额外详情区域"><a href="#额外详情区域" class="headerlink" title="额外详情区域"></a>额外详情区域</h4><p>额外详情区域常被用来展示特定instrument的关于在详情窗格中选中数据的额外信息，例如完整的栈跟踪。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_extended_detail.png" alt="img"></p>
<h3 id="关于库面板"><a href="#关于库面板" class="headerlink" title="关于库面板"></a>关于库面板</h3><p>库面板提供了可用instrument的完整列表，并能让你添加到跟踪文档中。在面板中你可以浏览instrument描述也可以筛选出指定的instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette.png" alt="img"></p>
<p>要显示库面板，请点击Window &gt; Library或按快捷键(Command-L)，还可以通过点击跟踪文档工具栏中Instrument的加号按钮(+)。</p>
<h3 id="关于标记面板"><a href="#关于标记面板" class="headerlink" title="关于标记面板"></a>关于标记面板</h3><p>标记面板中展示当前活动的跟踪文档中您需要在时间线窗格中添加的标记列表。</p>
<p>在标记文档中你可以通过选择标记来快速在时间线中导航到指定位置。你同样可以在一个较大的标记列表中筛选出指定标记，展示或隐藏标记和查看您标记的时间戳信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_flags_window.png" alt="img"></p>
<h3 id="关于分析模板"><a href="#关于分析模板" class="headerlink" title="关于分析模板"></a>关于分析模板</h3><p>在Instruments中你可以选择分析模板来分析您的app。分析模板是跟踪文档为了执行通用跟踪使用instruments已经预配置和设置过的。</p>
<p>在Instruments启动时或在Xcode中初始化一个跟踪或者创造新的跟踪文档的时候分析模板就已经可已使用。当您拥有更高级或者自定义的需求的时候也可以创造您自己的分析模板。</p>
<h3 id="关于分析模板选择框"><a href="#关于分析模板选择框" class="headerlink" title="关于分析模板选择框"></a><img src="/2021/04/11/Instrument文档翻译/instruments_profilingtemplateselection_dialog.png" alt="img">关于分析模板选择框</h3><p>在Instruments启动时你会看到一个模板列表，并可以从中选择，这列表是instruments预先设置好的集合。这个列表里包含标准的模板集合，同样也包含了你自定义的模板。</p>
<p>分析选择框由如下几个主要的要素组成：</p>
<ul>
<li>Target device list(目标设备列表)：点击这个可以选择您需要分析的载体设备。</li>
<li>Target process list(目标进程列表)：点击这个可以选择一个或者多个需要分析的进程。</li>
<li>Filter buttons(筛选按钮)：点击这些按钮在模板列表中筛选出标准模板，自定义模板和最近使用的模板。</li>
<li>Search field(搜索框)：通过输入文本来快速筛选出您需要的模板。它能够搜索模板的标题和描述。</li>
<li>Template list(模板列表)：可能被您输入的内容筛选过的模板列表。</li>
<li>Template description(模板描述)：当前所选中的模板的简短的描述，这段描述可能能够帮助您选择出符合您需求的模板。</li>
<li>Choose button(选择按钮)：点击它可以会基于你当前选择的来创建分析文档。 </li>
</ul>
<p>​       当你按住Option按键的时候它会变成分析(Profile)按钮。点击分析按钮会基于你当前选择的模板创建一个新的文档并直接开始分析。</p>
<ul>
<li>Open button(打开按钮)：点击它可以打开之前保存的分析文档，而不是以一个全新的模板开始。</li>
<li>Cancel button(取消按钮)：点击它关闭模板选择框。</li>
</ul>
<p>注意：你可以随时通过选择File &gt; New或者按下Command-N来呼出分析模板选择框。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profilingtemplate_dialog.png" alt="img"></p>
<h3 id="关于引用窗口"><a href="#关于引用窗口" class="headerlink" title="关于引用窗口"></a>关于引用窗口</h3><p>引用窗口被用来控制各种Instruments相关的行为设置。</p>
<p>在引用窗口中。你可以调整启动，保存和其他的相关设置。你同样可以调整记录设置，CPU设置和符号引用。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_general.png" alt="img"></p>
<h2 id="启动Instruments"><a href="#启动Instruments" class="headerlink" title="启动Instruments"></a>启动Instruments</h2><h3 id="从Xcode中启动Instruments"><a href="#从Xcode中启动Instruments" class="headerlink" title="从Xcode中启动Instruments"></a>从Xcode中启动Instruments</h3><p>在Xcode中启动Instruments最直接的方法。</p>
<ul>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu.png" alt="img"></p>
<h3 id="从Docker中启动Instruments"><a href="#从Docker中启动Instruments" class="headerlink" title="从Docker中启动Instruments"></a>从Docker中启动Instruments</h3><p>当Xcode运行的时候可以在Docker中的Xcode图标中启动Instruments。</p>
<ol>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/dock_xcode_contextualmenu_instruments.png" alt="img"></p>
<p>这样Instruments就启动了。</p>
<h3 id="将Instruments添加到Docker中"><a href="#将Instruments添加到Docker中" class="headerlink" title="将Instruments添加到Docker中"></a>将Instruments添加到Docker中</h3><p>你可以将Instruments添加到Docker中来随时快速访问。实现添加最简单的方法就是启动Instruments然后将其固定在Docker中。</p>
<ol>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu2.png" alt="img">、Instruments启动并在Docker中出现了Instruments的图标。</p>
<ol>
<li>在Docker中右键点击Instruments图标，接着选择Options &gt; 在程序坞中保留。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_contextual_menu_options_keepindock.png" alt="img"></p>
<h3 id="添加Instruments到Launchpad"><a href="#添加Instruments到Launchpad" class="headerlink" title="添加Instruments到Launchpad"></a>添加Instruments到Launchpad</h3><p>Launchpad会自动显示您在应用程序文件夹内的 App。由于Instruments并不是应用程序文件夹内的程序(至少不是直属与应用程序文件夹内，它是在Xcode 中的，而 Xcode 直属与应用程序文件夹)，因此Instruments不会在Launchpad中出现。当然你可以通过对Instruments创建一个别名并将其放入Applications文件夹。</p>
<ol>
<li><p>在Xcode中，选择 Xcode > Open Developer Tool &gt; Instruments。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu.png" alt="img"></p>
<p>Instruments图标在您 Docker 中出现。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_app_icon_small.png" alt="img"></p>
</li>
<li><p>在 Docker 中右键点击Instruments图标，之后选择选项 -&gt; 在文件夹中显示。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_contextual_menu_options.png" alt="img"></p>
</li>
<li><p>按住 option 键并将Instruments图标拖动到您的应用程序文件夹目录中。一个Instruments的别名就已经创建成功并添加到您的应用程序文件夹中了。</p>
</li>
<li><p>删除Instruments别名文件名中的别名前缀。</p>
<p>Instruments现在将会出现在你的Launchpad中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/launchpad_instruments.png" alt="img"></p>
</li>
</ol>
<h3 id="从命令行中启动Instruments"><a href="#从命令行中启动Instruments" class="headerlink" title="从命令行中启动Instruments"></a>从命令行中启动Instruments</h3><p>你可以在OS X中通过终端使用开放命令打开包括Instruments在内的任意软件。</p>
<ol>
<li><p>打开终端(在/Applications/Utilities/)。</p>
</li>
<li><p>运行如下命令：</p>
<p>open /Applications/Xcode.app/Contents/Applications/Instruments.app</p>
</li>
</ol>
<p>Instruments被运行了。</p>
<p>注意：你可以使用两个命令行工具的任意一个来分析您的 app，而无需显示Instruments用户图形界面。</p>
<ul>
<li>instruments——此实用程序使用指定的模板对应用程序进行配置。可以将结果保存到文件中，然后在主要的仪器应用程序中手动打开以进行查看和分析。在<a href="https://help.apple.com/instruments/mac/current/#/devb14ffaa5" target="_blank" rel="noopener">使用instruments命令行工具分析</a>中查看更多。</li>
</ul>
<h2 id="创建，保存和打开跟踪文档"><a href="#创建，保存和打开跟踪文档" class="headerlink" title="创建，保存和打开跟踪文档"></a>创建，保存和打开跟踪文档</h2><h3 id="创建一个跟踪文档"><a href="#创建一个跟踪文档" class="headerlink" title="创建一个跟踪文档"></a>创建一个跟踪文档</h3><p>在使用Instruments开始分析之前，你需要创建跟踪文档。</p>
<ol>
<li>打开Instruments</li>
<li>当出现的分析模板选择框中选择目标设备和进程。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profiling_dialog_target.png" alt="img"></p>
<ol>
<li>选择期望的分析模板</li>
<li>点击Choose</li>
</ol>
<p>从您选择的模板中使用预配置好的instruments创建了一个新的跟踪文档。</p>
<p>提示：要在您创建跟踪文档之后立即自动开始分析，请在模板选择框中按住 option 键。当你如上述所述操作时，Choose按钮会变为Profile按钮。点击Profile按钮立即开始分析跟踪文档。</p>
<p>如果你找不到您所需要模板或者想从头开始创建自己的模板，在模板选择提示框中选择空白模板。</p>
<h3 id="保存一个跟踪文档"><a href="#保存一个跟踪文档" class="headerlink" title="保存一个跟踪文档"></a>保存一个跟踪文档</h3><p>当你创建了一个跟踪文档，你能够保存上次引用。Instruments将以 .trace 扩展名保存保存跟踪文档文件。</p>
<ol>
<li><p>创建一个跟踪文档。<a href="#创建一个跟踪文档">在创建跟踪文档中查看</a></p>
</li>
<li><p>选择 File &gt; Save. Or, choose File &gt; Save 当你希望将之前保存的跟踪文档保存成新的文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_menu.png" alt="img"></p>
</li>
<li><p>输入文件名</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_dialog.png" alt="img"></p>
</li>
<li><p>选择文件保存目录</p>
</li>
<li><p>点击保存</p>
</li>
</ol>
<h3 id="将跟踪文档保存为分析模板"><a href="#将跟踪文档保存为分析模板" class="headerlink" title="将跟踪文档保存为分析模板"></a>将跟踪文档保存为分析模板</h3><p>如果你创建了一个跟踪文档，并且可能会在之后分析其他app时用到这个模板，你可以将它保存为自定义模板以便你不用每次运行Instruments时都重新创建。</p>
<ol>
<li><p>创建或打开跟踪文档。</p>
</li>
<li><p>选择 File &gt; Save As Template。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_menu.png" alt="img"></p>
</li>
<li><p>输入模板名称。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_dialog.png" alt="img"></p>
</li>
<li><p>选择模板保存目录。</p>
<p>将您模板保存在/Users/<username>/Library/Application Support/Instruments/Templates目录下以保证它能够在Instruments模板窗口中的的自定义部分中可用。</username></p>
</li>
<li><p>为模板选择一个图标。</p>
</li>
<li><p>输入模板的描述。</p>
</li>
<li><p>点击保存。</p>
<p>当你保存了模板，这个模板会自动出现在模板选择框中的Custom模板组中出现。下次当你创建一个跟踪文档时，可以将其作为您分析的起点。</p>
</li>
</ol>
<h3 id="打开跟踪文档"><a href="#打开跟踪文档" class="headerlink" title="打开跟踪文档"></a>打开跟踪文档</h3><p>打开已保存的跟踪文档来查看之前运行的结果或者对其进行额外的分析。</p>
<p>按如下操作之一来打开跟踪文档：</p>
<ul>
<li><p>在文件夹中双击 .trace 文档文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/trace_document.png" alt="img"></p>
</li>
<li><p>将 .trace 文档文件拖入Instruments软件图标中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_drag_and_open_trace_doc.png" alt="img"></p>
</li>
<li><p>打开Instruments并按如下步骤来操作：</p>
<ol>
<li><p>选择 File &gt; Open (或按快捷键Command + O)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_file_open_menu.png" alt="img"></p>
</li>
<li><p>找到所保存的 .trance 文档文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_open_trace_doc_dialog.png" alt="img"></p>
</li>
<li><p>点击open。</p>
</li>
</ol>
</li>
</ul>
<p>这样跟踪文档就在Instruments中显示。</p>
<h3 id="关闭跟踪文档"><a href="#关闭跟踪文档" class="headerlink" title="关闭跟踪文档"></a>关闭跟踪文档</h3><p>当你使用跟踪文档完毕时，关闭它。</p>
<ol>
<li>选择 File &gt; Close(或按下Command + W)</li>
<li>当你的跟踪文档中包含尚未保存的数据，请选择是否保存更新文档。</li>
</ol>
<h2 id="目标设备和进程"><a href="#目标设备和进程" class="headerlink" title="目标设备和进程"></a>目标设备和进程</h2><h3 id="目标设备和进程-1"><a href="#目标设备和进程-1" class="headerlink" title="目标设备和进程"></a>目标设备和进程</h3><p>目标设备列表能在每个跟踪文档中的工具栏中看到，这个列表允许你跟踪文档运行中的任何时候更改指定设备和进程。</p>
<ul>
<li><p>点击目标设备列表或目标进程列表并选择指定目标和进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetspecificprocess_menuitem.png" alt="img"></p>
<p>部分instruments能以所有进程为目标。如果逆向选择全部进程，请在目标进程列表中选择全部进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetallprocesses_menuitem.png" alt="img"></p>
<p>如果目标进程并不在列表中，在目标进程列表中选择Choose Target。之后会显示一个弹窗，在这个弹窗内你可以浏览所有进程。你也可以在这个弹窗中为一个进程配置环境变量。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_choosetarget_menuitem.png" alt="img"></p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_choosetargetdialog.png" alt="img"></p>
</li>
</ul>
<p>提示：如果一个你已被设置为目标的app，但是并没有主动运行app，instruments会自动将其运行。</p>
<h3 id="以iOS设备作为目标"><a href="#以iOS设备作为目标" class="headerlink" title="以iOS设备作为目标"></a>以iOS设备作为目标</h3><p>为了将iOS设备作为目标，请把设备连接到开发Mac上。一旦连接，设备会出现在设备列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetiosdevice.png" alt="img"></p>
<p>注意：在你能使用Instruments分析iOS设备之前，你的设备必须已经拥有了能够搜集数据的开发环境。关于提供开发环境，请在<a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/index.html" target="_blank" rel="noopener">App分发指南上</a>查看<a href="https://developer.apple.com/library/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingProfiles/MaintainingProfiles.html#//apple_ref/doc/uid/TP40012582-CH30-SW61" target="_blank" rel="noopener">创建Provision 开发文件</a>。</p>
<h3 id="启动iOS设备无线分析"><a href="#启动iOS设备无线分析" class="headerlink" title="启动iOS设备无线分析"></a>启动iOS设备无线分析</h3><p>Instruments能够使用无线的方式来从iOS设备上收集数据。</p>
<ol>
<li><p>请确保您iOS设备已经连接到开发Mac上。</p>
<p><img src="/2021/04/11/Instrument文档翻译/graphic_computerconnectedtodevice.png" alt="img"></p>
</li>
<li><p>按住Option按键，并点击目标设备列表。</p>
</li>
<li><p>选择您需要开启无线分析的移动设备。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targets_enablewireless.png" alt="img"></p>
</li>
<li><p>再次点击设备目标列表并打开它，为您设备选择无线版本并选择进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targtetlist_selectwirelessprocess.png" alt="img"></p>
</li>
</ol>
<p>现在您应该可以在您设备商以无线的形式分析进程。</p>
<p>无线调试模式费事如下情况十分有用：</p>
<ul>
<li>Accelerometers(加速度计)：在所有方向是移动设备，而非只在一条线上。</li>
<li>Accessories(配件)：将您的USB配件插入插槽并进行测试。</li>
</ul>
<p>当你在设备上使用无线分析时，对设备关机会导致停止收集数据。你必须重新将设备连接到电脑上才能继续数据收集。</p>
<p><strong>重点：</strong>在Instruments收集数据之前，您的设备必须要有开发环境。并且您必须在无线网络访问端口上启用Bonjour和multicast。请在<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Discovering,Browsing,AndAdvertisingNetworkServices/Discovering,Browsing,AndAdvertisingNetworkServices.html#//apple_ref/doc/uid/TP40010220-CH9-SW7" target="_blank" rel="noopener">Bonjour服务预览</a>中查看。且记录数据所用 Mac 和设备必须都处于同一个子网中。</p>
<h3 id="准备Apple-Watch分析"><a href="#准备Apple-Watch分析" class="headerlink" title="准备Apple Watch分析"></a>准备Apple Watch分析</h3><p>在你使用instruments以Apple Watch作为目标之前，必须先对其进行分析。</p>
<ol>
<li><p>确保Apple Watch已与开发iPhone配对过。</p>
</li>
<li><p>退出Instruments。</p>
</li>
<li><p>打开Xcode。</p>
</li>
<li><p>将已于Apple Watch配对的iPhone连接到开发Mac上。</p>
<p><img src="/2021/04/11/Instrument文档翻译/graphic_computerconnectedtodevice.png" alt="img"></p>
</li>
<li><p>选择Window &gt; Devices(或按下Shift+Command+2)打开Xcode中设备窗口。</p>
</li>
<li><p>等待设备出现在列表窗口中。</p>
</li>
<li><p>等待Apple Watch作为iPhone配对设备出现。</p>
</li>
<li><p>等待Xcode将Apple Watch标记为准备完成。这个过程可能会花费好几分钟。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_devices_pairedwatch.png" alt="img"></p>
</li>
<li><p>断开iPhone连接。</p>
</li>
<li><p>再次连接iPhone。</p>
</li>
</ol>
<p>当你的Apple Watch完成分析准备，重启Instruments，然后Apple Watch会出现在目的设备列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetwatch.png" alt="img"></p>
<p>注意：在您分析Apple Watch的时候，你的开发iPhone充当代理，在Instruments和Apple Watch之间传递信息。</p>
<h2 id="访问和使用Instruments"><a href="#访问和使用Instruments" class="headerlink" title="访问和使用Instruments"></a>访问和使用Instruments</h2><h3 id="显示模板库"><a href="#显示模板库" class="headerlink" title="显示模板库"></a>显示模板库</h3><p>库模板中显示所有你能够添加到跟踪文档上的instruments。库中包含所有内置和您可能自定义好instruments。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette.png" alt="img"></p>
<ul>
<li><p>请按如下操作之一：</p>
<ul>
<li><p>在跟踪文档中点击Instrument工具栏上的加号按钮(+)。</p>
</li>
<li><p>选择Window &gt; Library(或按下Command+L)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在模板库中筛选出指定instrument"><a href="#在模板库中筛选出指定instrument" class="headerlink" title="在模板库中筛选出指定instrument"></a>在模板库中筛选出指定instrument</h3><p>模板库列表十分的长，尤其是当您添加过您自己的自定义模板时。请使用位于模板库列表底部的筛选输入框内容来根据名字，描述或者关键字快速查找指定instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette_filterterm.png" alt="img"></p>
<h3 id="将一个instrument添加到跟踪文档"><a href="#将一个instrument添加到跟踪文档" class="headerlink" title="将一个instrument添加到跟踪文档"></a>将一个instrument添加到跟踪文档</h3><p>无论你创建的跟踪文档是根据模板创建的还是空白的，都能够通过添加新的instruments来扩展其功能。</p>
<ol>
<li><p>打开目标跟踪文档。</p>
</li>
<li><p>显示模板库。</p>
</li>
<li><p>找到所需要的instruments。</p>
</li>
<li><p>将instruments从模板库中拖拽出来添加到跟踪文档中策略窗格里的instrument列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_addinstrument.png" alt="img"></p>
</li>
</ol>
<h3 id="在跟踪文档中移除一个instrument"><a href="#在跟踪文档中移除一个instrument" class="headerlink" title="在跟踪文档中移除一个instrument"></a>在跟踪文档中移除一个instrument</h3><p>在您不再需要instruments的时候，你可以轻易的将其从跟踪文档中移除。</p>
<ol>
<li><p>打开您需要的跟踪文档。</p>
</li>
<li><p>在策略窗格的instruments列表中选中您需要删除的instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_selectedinstrument.png" alt="img"></p>
</li>
<li><p>按下delete(删除)键或者选择 Instrument &gt; Delete [Instrument名] Instrument</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_deleteinstrument_menu.png" alt="img"></p>
</li>
<li><p>当出现提示时，点击 ok 确认您真要将instrument移除。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_deleteinstrumentconfirmation_dialog.png" alt="img"></p>
</li>
</ol>
<h3 id="配置instrument的显示设置"><a href="#配置instrument的显示设置" class="headerlink" title="配置instrument的显示设置"></a>配置instrument的显示设置</h3><p>在录制跟踪(trace)时，Instruments会在时间线窗格中展示选中instrument结果的概览并在详情窗格中显示结果详情。这些结果会在不同的instrument之间有所差异。它们可能会包含像概览，调用树和样本列表。通常这里会展示很多的数据，导航会非常耗时。为了帮助您能够快速获取正确的信息，Instruments通常同样的，这也根据Instrument类型不同而有差距)能够让你对其调整，并在时间线窗格和详情窗格中过滤出信息。</p>
<ul>
<li>在时间线中配置显示设置</li>
</ul>
<ol>
<li><p>将鼠标移动到时间线中instrument图标上。如果该仪器支持不同的显示配置，则图标旁边会出现一个指示器</p>
</li>
<li><p>点击图标弹出<a href="https://help.apple.com/instruments/mac/current/#/deva13e2923b" target="_blank" rel="noopener">显示设置框</a>。</p>
</li>
<li><p>选择所需显示配置。时间线会在选择之后更新。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_config_popover.png" alt="A screenshot showing a trace document with the display configuration popover for the activity monitor instrument."></p>
</li>
<li><p>点击弹窗之外的区域来关闭它。</p>
</li>
</ol>
<h3 id="配置详情显示设置"><a href="#配置详情显示设置" class="headerlink" title="配置详情显示设置"></a>配置详情显示设置</h3><ul>
<li><p>使用在详情窗格底部的控件<a href="https://help.apple.com/instruments/mac/current/#/devadf729aef" target="_blank" rel="noopener">筛选和配置栏</a>来配置显示设置。不同instrument之间控件和配置选项会有所差异。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_filter_config_bar.png" alt="A screenshot of the filter and display configuration bar showing the filter field on the left followed by a configuration drop-down, and buttons that show popovers with other display configuration options."></p>
</li>
</ul>
<h2 id="记录，暂停和开始跟踪"><a href="#记录，暂停和开始跟踪" class="headerlink" title="记录，暂停和开始跟踪"></a>记录，暂停和开始跟踪</h2><h3 id="记录跟踪"><a href="#记录跟踪" class="headerlink" title="记录跟踪"></a>记录跟踪</h3><p>当你准备好分析您的 App 时，请开始收集。在收集期间，在跟踪文档中的instruments会根据其配置来监听您的App。当开始收集时，时间线窗格和详情窗格将会更新用以提供展示所捕获的实时数据的视图。</p>
<p>请按如下操作之一进行操作：</p>
<ul>
<li><p>点击在跟踪文档工具栏的收集按钮(<img src="/2021/04/11/Instrument文档翻译/inline_record_button.png" alt="img" style="zoom:50%;">)。</p>
<ul>
<li><p>选择 File &gt; Record Trace(或者按下 Command+R )。</p>
</li>
<li><p>再次按下 Command+R 将会停止收集。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_recordtrace_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="配置收集选项"><a href="#配置收集选项" class="headerlink" title="配置收集选项"></a>配置收集选项</h3><p>在收集选项弹窗选择全局收集选项，例如，将推迟结果处理推迟到开始收集之后和自定义instrument选项，来改善数据收集。</p>
<p>举个例子，你可能会希望调整Time Profiler instrument的样本速率或者使用Allocations instrument分析时放弃事件以释放内存。想如上所述的自定义选项会根据instrument的不同而有差异。很多instruments能控制其本身所生成信息的信息类型。</p>
<ul>
<li><p>配置全局收集选项</p>
<ol>
<li><p>选择 File &gt; Recording Options 来打开录制选项弹窗。</p>
<p><img src="/2021/04/11/Instrument文档翻译/FAB7CADB-6C17-439F-8811-CF7511D35243.png" alt="FAB7CADB-6C17-439F-8811-CF7511D35243"></p>
</li>
<li><p>点击 Global options 。</p>
</li>
<li><p>自定义所需选项。</p>
<p>选项包括：</p>
<p>Time limit:instruments收集数据的时间数值的最大值，以秒为单位。</p>
<p>Window limit:保存数据的最长时间，以秒为单位。如果录制超过了你作为window limit定义的时间(举个例子，长于四秒)，只有所用时长的最后四秒的数据才会被保存。</p>
<p>Deferred mode:选择以在数据收集完毕之后延迟数据分析。它能带来更快更精准的数据集合，因为更多系统资源被直接记录的过程。在数据收集期间在时间线和详情窗格不会有数据显示。</p>
</li>
<li><p>点击关闭或者录制按钮来保存选项。</p>
<p>点击录制按钮来使用新的选项开始跟踪。</p>
</li>
</ol>
</li>
</ul>
<h3 id="暂停跟踪"><a href="#暂停跟踪" class="headerlink" title="暂停跟踪"></a>暂停跟踪</h3><p>如果需要的话你可以暂停跟踪，并在之后继续。</p>
<p>注意:当收集暂停时，被暂停的App不会响应输入。</p>
<ul>
<li><p>按如下之一进行操作：</p>
<ul>
<li>在跟踪文档的工具栏按下暂停按钮(<img src="/2021/04/11/Instrument文档翻译/pause.png" alt="img" style="zoom:60%;">)。</li>
<li>选择 File &gt; Pause Trace(或按下Shift+Command+R))。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/11ACD438-6F73-4A25-A067-0E5099AB9423.png" alt="11ACD438-6F73-4A25-A067-0E5099AB9423"></p>
</li>
</ul>
<h3 id="停止跟踪"><a href="#停止跟踪" class="headerlink" title="停止跟踪"></a>停止跟踪</h3><p>在你已经搜集到了你想要的数据之后，停止收集来让你能够开始对所收集的数据进行分析。</p>
<ul>
<li><p>按如下之一操作进行:    </p>
<ul>
<li><p>在跟踪文档的工具栏上按下停止按钮<img src="/2021/04/11/Instrument文档翻译/inline_stop_button.png" alt="img" style="zoom:67%;">。</p>
</li>
<li><p>选择 File &gt; Stop Trace (或者按下Command-R)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_stoptrace_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在-Xcode-构建和产品菜单中分析您的-App"><a href="#在-Xcode-构建和产品菜单中分析您的-App" class="headerlink" title="在 Xcode 构建和产品菜单中分析您的 App"></a>在 Xcode 构建和产品菜单中分析您的 App</h3><p>Xcode 构建菜单允许您对您的 app 进行运行、测试和分析等操作。它同样也可以使用instruments分析您的 App。</p>
<ol>
<li><p>在 Xcode 中打开项目。</p>
</li>
<li><p>进行如下之一操作：</p>
<ul>
<li><p>在Xcode 主页面中点击并长按构建按钮，并在出现的菜单中选择Profile。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_toolbar_build_menu_profile_option.png" alt="img"></p>
</li>
<li><p>选择 Product &gt; Profile (或按下Command-I)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_product_menu_profile_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
<p>Instruments启动并出现模板选择提示框。注意此时您的 app 会在自动在设备和进程列表中被选中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profiling_template_window_initiatedbyxcode.png" alt="img"></p>
<h3 id="在-Xcode-构建和产品菜单中启动分析时使用默认模板"><a href="#在-Xcode-构建和产品菜单中启动分析时使用默认模板" class="headerlink" title="在 Xcode 构建和产品菜单中启动分析时使用默认模板"></a>在 Xcode 构建和产品菜单中启动分析时使用默认模板</h3><p>如果你经常需要使用同一个模板来分析您的 App，你可以对 Xcode 项目进行设置，并让其在启动分析时使用指定模板。</p>
<ol>
<li>启动 Xcode 并开启您的项目。</li>
<li>进行如下操作之一来打开计划编辑弹窗：</li>
</ol>
<ul>
<li><p>选中在 Xcode 主页面工具栏设备目标列表中的Edit Scheme。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_targetdevice_list_editscheme_option.png" alt="img"></p>
</li>
<li><p>选择 Product &gt; Scheme &gt; Edit Scheme 或按下 Command + (小于号)&lt;。</p>
</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_product_menu_editscheme_menu.png" alt="img"></p>
<ol>
<li>在编辑弹窗的侧边栏中选择 profile。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_scheme_editor_dialog_sidebar_profile_option.png" alt="img"></p>
<ol>
<li>在Instrument下出现的菜单中选择你需要的模板。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_scheme_editor_dialog_profile_option_instrument_popup.png" alt="img"></p>
<ol>
<li><p>点击 close。</p>
</li>
<li><p>启动分析。请查看 在<a href="https://help.apple.com/instruments/mac/current/#/dev54a36a4b" target="_blank" rel="noopener">Xcode 构建和产品菜单中分析您的 App</a>。</p>
<p>Xcode 构建您的项目，Instruments启动并以scheme editor中配置过的模板开始分析您的App。</p>
</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_activitymonitorprofilingfromxcode.png" alt="img"></p>
<h3 id="debug时从-Xcode-仪器中分析"><a href="#debug时从-Xcode-仪器中分析" class="headerlink" title="debug时从 Xcode 仪器中分析"></a>debug时从 Xcode 仪器中分析</h3><p>当您测试和 debug App 的时候，Xcode debug 导航区中包含了一些列仪表来监视您的 App。这些仪表监视多种元素，包括 CPU 使用量，内存和电量消耗，这些能够提示你影响性能，能量消耗等潜在问题。如果您在测试应用时发现希望进一步调查的趋势，则可以将监控转换为仪器以进行更详细的分析。</p>
<ol>
<li><p>打开一个 App 项目并运行。</p>
</li>
<li><p>当你App 已经运行，使用如下操作之一来显示debug 导航区：</p>
<ul>
<li><p>在导航栏的选择栏中选择 Debug 导航按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_navigatorselector_bar_debugnaviagator_button.png" alt="img"></p>
</li>
<li><p>选择View &gt; Navigators &gt; Show Debug Navigator (或按下 Command + 6)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_view_menu_debugnavigator_menu.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>在 debug 导航区中点击需要的仪器。</p>
</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_debug_navigator_selectedgauge.png" alt="img"></p>
<ol>
<li><p>在主编辑区中点击仪器的 Profile in Instruments 按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_gauge_profileininstruments_button.png" alt="img"></p>
<p>注意：并不是每个仪器都拥有 Profile in Instruments 按钮。举个例子，Energy Impact 仪器拥有一系列按钮来初始化不同的 Instruments 。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_timeprofiler_gauge_profileininstruments_button.png" alt="img"></p>
</li>
<li><p>当如下提示出现，选择是将应用当前运行的实例转移到仪器上，还是停止应用，然后用仪器启动新的实例。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_profileininstrruments_alert.png" alt="img"></p>
<p>在这两种情况下，请注意 Xcode 停止分析您的应用、启动文书并启动分析。如果您选择transfer，仪器将以当前状态开始分析应用。</p>
</li>
</ol>
<h3 id="在-Dock-中启动分析"><a href="#在-Dock-中启动分析" class="headerlink" title="在 Dock 中启动分析"></a>在 Dock 中启动分析</h3><p>你能够通过触发在Dock上的Instruments App 图标中的Time Profiler来后台自动录制确切的事件。</p>
<p>在 Dock 收集 Time Profiler 数据。</p>
<ol>
<li><p>Instruments打开后，右键 Dock 上的Instruments图标。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_app_icon_small.png" alt="img"></p>
</li>
<li><p>在出现的菜单中选择您需要开始分析的进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_menu.png" alt="img"></p>
<p>选项包括：</p>
<ul>
<li><em>System Time Profile</em>：开始分析所有系统进程。</li>
<li><em>Time Profile Specific Process</em>：在子菜单中选择指定的进程开始Time Profiler instrument。</li>
<li><em>Automatically Time Profile Spinning Applications</em>：自动分析在未来被阻隔的App。</li>
<li><em>Allow Tracing of Any Process (10 hours)</em>：在接下来的十小时内跟踪任意进程，在此十小时内需要绕过密码进入。</li>
</ul>
</li>
</ol>
<p>注意：以这种方式记录的数据以 .dtps 格式保存到  ~/Library/Application Support/Instruments/Unimported/.。</p>
<h3 id="使用instruments命令行工具启动分析"><a href="#使用instruments命令行工具启动分析" class="headerlink" title="使用instruments命令行工具启动分析"></a>使用instruments命令行工具启动分析</h3><p>使用仪器命令行工具使用指定的模板来描述应用，而无需启动仪器。在分析过程中收集的数据保存在 .trace 文件中到指定目录中。分析完成后，您可以使用仪器打开记录的数据文件，查看数据的可视化表示。</p>
<ol>
<li><p>打开在 /Applications/Utilities. 中的终端。</p>
</li>
<li><p>输入一个 instruments 命令来收集数据。</p>
<p>举个例子，以下命令配置了带有分配模板的应用，并将结果保存到.trace文件中的桌面。</p>
<p><code>instruments -t &quot;Allocations&quot; -D ~/Desktop/*YourTraceFileName*.trace *PathToYourApp*</code></p>
</li>
<li><p>打开 Instruments ，并选择File &gt; Open。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_fileopen_menu.png" alt="img"></p>
</li>
<li><p>找到你保存的 .trace 文件，并打开。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_opentracefile_dialog.png" alt="img"></p>
</li>
</ol>
<p>打开保存的文件后，仪器会自动将相关文书添加到跟踪文档中，并将它们填充到收集的数据中。您可以查看和分析数据，以便查找应用的任何问题。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_loadedtrace_file.png" alt="img"></p>
<p><strong>instruments</strong>选项</p>
<p>instruments提供了以下一组配置选项，用于定义要收集的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Configuration option</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-t template</code></td>
<td style="text-align:left">分析 App 时，所要用到的模板名字或者是模板路径。</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code></td>
<td style="text-align:left">返回所有已安装的模板的列表。</td>
</tr>
<tr>
<td style="text-align:left"><code>-D document</code></td>
<td style="text-align:left">.trace 文档的保存路径。如果路径已存在，则新数据会覆盖旧数据。</td>
</tr>
<tr>
<td style="text-align:left"><code>-l #</code></td>
<td style="text-align:left">指定收集的时间，以毫秒为单位。如果不提供则会无限录制下去，知道 App 被手动终止。</td>
</tr>
<tr>
<td style="text-align:left"><code>-i #</code></td>
<td style="text-align:left">被用于录制的 instrument 的索引。</td>
</tr>
<tr>
<td style="text-align:left"><code>-p pid</code></td>
<td style="text-align:left">需要被收集的 App 的进程 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>application</code></td>
<td style="text-align:left">需要被收集的 App 的路径。</td>
</tr>
<tr>
<td style="text-align:left"><code>-w hardware device</code></td>
<td style="text-align:left">需要被设为目标的设备的 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>-e variable value</code></td>
<td style="text-align:left">在分析时需要被应用的一个环境变量。</td>
</tr>
<tr>
<td style="text-align:left"><code>argument</code></td>
<td style="text-align:left">要传递到正在配置的应用程序的命令行参数。如果需要，可以指定多个参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>-v</code></td>
<td style="text-align:left">在分析时启用详细的日志记录。</td>
</tr>
</tbody>
</table>
<h3 id="延时启动分析"><a href="#延时启动分析" class="headerlink" title="延时启动分析"></a>延时启动分析</h3><p>对于特长的跟踪，延迟模式造成的延迟可能非常显著。仅为需要极其精确的数据收集的痕迹设置延期模式，从而避免此延迟。</p>
<ol>
<li><p>选择 File &gt; Recording Options。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_recordoptions_menu.png" alt="img"></p>
</li>
<li><p>在出现的弹窗中选择Deferred Mode 复选框接着按下 OK。</p>
<p>如果在Instruments设置中中启用”始终使用递延模式”，则此选项将禁用。</p>
</li>
</ol>
<p>通过将数据分析推迟到退出正在测试的应用之前，提高性能相关数据的准确性。通常，仪器会在应用运行时分析和显示数据，从而允许您在收集数据时查看数据。通过占用 CPU 时间和内存进行实时分析会减慢目标过程，从而获得可能无法反映该过程通常表现的测量结果。在延期模式下运行文书会延迟数据分析，直到数据收集完成，无论是在应用完成运行后还是在单击”停止”之后。在延期模式下，您被阻止与正在收集数据的仪器交互。</p>
<p>在延期模式下，仪器完成数据收集后，仪器处理数据并将其显示在屏幕上。延迟数据分析为数据收集过程的后期阶段增加了时间，但它有助于确保与性能相关的数据准确无误。</p>
<h3 id="在延迟模式下启动Instruments"><a href="#在延迟模式下启动Instruments" class="headerlink" title="在延迟模式下启动Instruments"></a>在延迟模式下启动Instruments</h3><p>通过将数据分析推迟到退出正在测试的应用之前，提高性能相关数据的准确性。通常，仪器会在应用运行时分析和显示数据，从而允许您在收集数据时查看数据。通过占用 CPU 时间和内存进行实时分析会减慢目标过程，从而获得可能无法反映该过程通常表现的测量结果。在延期模式下运行文书会延迟数据分析，直到数据收集完成，无论是在应用完成运行后还是在单击”停止”之后。在延期模式下，您被阻止与正在收集数据的仪器交互。</p>
<ol>
<li><p>选择Instruments &gt; Preferences。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_preferences_menu.png" alt="img"></p>
</li>
<li><p>在录制窗格中，选择 Always use deferred mode 复选框。</p>
<p><img src="https://help.apple.com/instruments/mac/current/en.lproj/Art/instruments_prefs_recording_deferred_option.png" alt="img"></p>
</li>
</ol>
<p>在延期模式下，仪器完成数据收集后，仪器处理数据并将其显示在屏幕上。延迟数据分析为数据收集过程的后期阶段增加了时间，但它有助于确保与性能相关的数据准确无误。</p>
<h2 id="导航所收集的数据"><a href="#导航所收集的数据" class="headerlink" title="导航所收集的数据"></a>导航所收集的数据</h2><h3 id="在时间线窗格中放大或者缩小"><a href="#在时间线窗格中放大或者缩小" class="headerlink" title="在时间线窗格中放大或者缩小"></a>在时间线窗格中放大或者缩小</h3><p>如果你使用跟踪文档收集了很多的数据，你可以对在详情窗格中的详情数据的显示区域进行扩大或者缩小，这样你能够专注于指定数据的子集。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_zooming.png" alt="img"></p>
<h4 id="扩大或者缩小您的数据"><a href="#扩大或者缩小您的数据" class="headerlink" title="扩大或者缩小您的数据"></a>扩大或者缩小您的数据</h4><ul>
<li>进行如下之一的操作<ul>
<li>捏住触控板选择放大或者缩小。</li>
<li>滑动鼠标滚轮同时按下Option 按键并将鼠标指向跟踪视图上，来放大。</li>
<li>按下Option按键并拖动您希望分离出的数据，来放大。</li>
<li>按下Control按键并拖动数据来缩小。</li>
</ul>
</li>
</ul>
<h4 id="选中所有在时间线窗格中的数据"><a href="#选中所有在时间线窗格中的数据" class="headerlink" title="选中所有在时间线窗格中的数据"></a>选中所有在时间线窗格中的数据</h4><ul>
<li><p>选择 view > Snap Track To Fit (或者按下 Control-Command-Z)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_snaptracktofit_menuitem.png" alt="img">、</p>
</li>
</ul>
<h4 id="增加在时间线窗格中显示的数据"><a href="#增加在时间线窗格中显示的数据" class="headerlink" title="增加在时间线窗格中显示的数据"></a>增加在时间线窗格中显示的数据</h4><ul>
<li><p>选择 View &gt; Increase Deck Size (或者按下 Command+加号)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_increasedecksize_menuitem.png" alt="img"></p>
<p>instrument当前所选中的跟踪增加了高度，这能让你查看的更加详细。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_largertrack.png" alt="img"></p>
</li>
</ul>
<h4 id="减少在时间线窗格中显示的数据"><a href="#减少在时间线窗格中显示的数据" class="headerlink" title="减少在时间线窗格中显示的数据"></a>减少在时间线窗格中显示的数据</h4><ul>
<li>选择View &gt; Decrease Deck Size (或者按下 Command+减号)。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_decreasedecksize_menuitem.png" alt="img"></p>
<p>instrument当前所选中的跟踪减少了高度。</p>
<h3 id="在详情窗格中筛选一段数据"><a href="#在详情窗格中筛选一段数据" class="headerlink" title="在详情窗格中筛选一段数据"></a>在详情窗格中筛选一段数据</h3><p>Instruments会收集大量数据用于分析。您可以通过设置详情窗格只显示指定时间段的事件来快速筛选数据。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_selectedrange.png" alt="img"></p>
<h4 id="选择时间区域用于查看"><a href="#选择时间区域用于查看" class="headerlink" title="选择时间区域用于查看"></a>选择时间区域用于查看</h4><ul>
<li>在不使用任何按键的情况下拖动部分数据。只有您拖动的数据才会显示。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_selectingrange.png" alt="img"></p>
<p>在Instruments中时间线窗格高亮部分的内容，都是您指定的范围。</p>
<h4 id="清除所选区域"><a href="#清除所选区域" class="headerlink" title="清除所选区域"></a>清除所选区域</h4><ul>
<li>进行如下操作期中之一：<ul>
<li>点击时间线窗格中所选区域以外。</li>
<li>选择 View &gt; Clear Inspection Range 。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_clearinspectionrange_menu.png" alt="img"></p>
<h3 id="在时间线窗格中设置标记"><a href="#在时间线窗格中设置标记" class="headerlink" title="在时间线窗格中设置标记"></a>在时间线窗格中设置标记</h3><p>标记让你能够快速的在时间线窗格中访问点。你能够为每个标记都添加名字和描述。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_flags.png" alt="img"></p>
<ul>
<li><p>在时间线窗格中的当前位置设置一个标记</p>
<ul>
<li><p>选择 Edit &gt; Add Flag  (或者按下 Command + ↓)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_addflag_menu.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>在时间线标记中导航</p>
<ol>
<li><p>选择 Window &gt; Manage Flags (或按下 Shift-Command-T )来显示标记面板。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_manageflags_menu.png" alt="img"></p>
</li>
<li><p>点击标记面板中的一个标记来导航到时间线窗格。</p>
</li>
</ol>
</li>
<li><p>删除标记</p>
<ul>
<li>将标记点拖拽出时间线导航栏。</li>
</ul>
</li>
<li><p>隐藏标记点</p>
<ol>
<li><p>选择 Window &gt; Manage Flags (或按下 Shift-Command-T)来显示标记面板。</p>
</li>
<li><p>在标记面板中反选标记边上的复选框来隐藏时间线窗格中的标记点。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_flags_palette_disabledflag.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
<h3 id="固定和取消固定时间线"><a href="#固定和取消固定时间线" class="headerlink" title="固定和取消固定时间线"></a>固定和取消固定时间线</h3><ul>
<li><p>固定时间线</p>
<ol>
<li><p>如果目标时间线未选中，将鼠标移动到该时间线的左侧。</p>
</li>
<li><p>点击加号按钮 (<img src="/2021/04/11/Instrument文档翻译/pin_add_button.png" alt="img" style="zoom:67%;">)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/timeline_pin_add.png" alt="Screenshot showing the timeline pane with the mouse over the Frames Per Second instrument that shows the pin button."></p>
</li>
</ol>
</li>
<li><p>取消固定时间线</p>
<p><img src="/2021/04/11/Instrument文档翻译/timeline_pin_delete.png" alt="Screenshot showing the timeline pane with the mouse over the pinned Frames Per Second instrument that shows the unpin button"></p>
</li>
</ul>
<h3 id="在详情窗格中查看不同类型的数据"><a href="#在详情窗格中查看不同类型的数据" class="headerlink" title="在详情窗格中查看不同类型的数据"></a>在详情窗格中查看不同类型的数据</h3><p>在一些instruments中你可以在详情窗格中展示多种格式的数据。举个例子，在Activity Monitor中，你可以查看到数据概览，父子信息和一些样本的列表。</p>
<ul>
<li><p>对详情窗格中导航栏列表里的详情列表类型选择合适的模式。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_detailtypelist.png" alt="img"></p>
<p>instrument支持哪种数据要依赖于instrument所收集到的数据的类型。</p>
<p>对于一些详情类型，像 Allocations 称为 call tree 模式，你可以使用确切详情窗格中的下箭头来进一步深入到与其相对应的层级中。点击三角形会展开或者收起行信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_calltreeexpanded.png" alt="img"></p>
<p>提示：按住option并点击三角形来递归展开到当前行的子节点发生数据更改的位置。按住Shift-Option点击左键来展开当前行的所有字节点。</p>
<p>当查看调用树时(call tree)，多数instruments都包含 hide system calls 和 invert the call tree选项。这些选项在inspector窗格的显示设置中的调用树区域(call tree area)可以找到。Hiding system calls能够让你快速筛选出您 App 中的调用方法。Inverting the call tree 能够让你最先查看到最后的调用。</p>
</li>
</ul>
<h3 id="使用额外详情区域"><a href="#使用额外详情区域" class="headerlink" title="使用额外详情区域"></a>使用额外详情区域</h3><p>对于一些instruments，其检查区域中的额外详情区域能够展示在当前详情窗格中所选中条目的额外信息。这些额外的详情信息可以包括一些结果的描述或者是被记录的事件或调用跟踪和信息被记录的时间或者是其他信息。</p>
<ul>
<li><p>请按如下操作之一进行操作：</p>
<ul>
<li><p>选择 View &gt; Inspectors &gt; Show Extended Detail or Hide Extended Detail (或按下 Command - 1)。</p>
</li>
<li><p>点击指示器窗格顶部的额外详情按钮 (<img src="/2021/04/11/Instrument文档翻译/instruments_extendeddetail_button_inline.png" alt="img" style="zoom:67%;">)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_navigation_bar.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<p>你可以通过点击额外详情区域中栈跟踪区域顶部的折叠按钮<img src="/2021/04/11/Instrument文档翻译/inline_hidesystemcalls_button.png" alt="img" style="zoom:67%;"> 来隐藏系统调用方法。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_extendeddetail_pane_hiddensystemcalls.png" alt="Hiding system calls in the extended detail area of the inspector pane"></p>
<h3 id="访问多次运行的跟踪数据"><a href="#访问多次运行的跟踪数据" class="headerlink" title="访问多次运行的跟踪数据"></a>访问多次运行的跟踪数据</h3><p>一个跟踪文档能够为你的 app 收集多次运行的数据。这样做时，这并不会抛弃之前所收集的数据。在工具栏的活动区域(Activity area)展示出总共运行的次数，当前运行，和当前运行的时间。更改当前运行会为trace document中每一个instrument更新为当前运行的数据。数据只会在跟踪文档选中的运行期间的instruments展示。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_strategy_pane_multipleruns.png" alt="img"></p>
<ul>
<li>移动到下一次运行<ul>
<li>选择 Instrument &gt; Next Run ，点击在活动区域顶部工具栏中的 Previous Run 按钮或者按下 Command + {。</li>
</ul>
</li>
<li>移动到之前的运行<ul>
<li>选择 Instrument &gt; Previous Run ，点击在活动区域顶部工具栏中的 Next Run 按钮或者按下 Command + }。</li>
</ul>
</li>
</ul>
<h3 id="在Instruments中访问源代码"><a href="#在Instruments中访问源代码" class="headerlink" title="在Instruments中访问源代码"></a>在Instruments中访问源代码</h3><p>如果您拥有的 Xcode 项目源代码能够列出跟踪栈中的符号，Instruments能够打开 Xcode ，以便你能够对其进行任何所需的更改。</p>
<ol>
<li>在详情窗格中找到您代码的图标(<img src="/2021/04/11/Instrument文档翻译/inline_usercode_icon.png" alt="img" style="zoom:67%;">表示用户)。</li>
<li>右键条目，并在所出现的弹窗中选择 Reveal in Xcode 。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_usersourcecode_popover.png" alt="Screenshot showing the popover for opening the user symbol in Xcode"></p>
<p>为了更轻松地查找代码符号，您可以通过展示窗口底部的<a href="https://help.apple.com/instruments/mac/current/#/devadf729aef" target="_blank" rel="noopener">筛选和配置栏</a>中 instrument 的显示设置来从系统库中筛选出符号。</p>
<h2 id="配置instruments"><a href="#配置instruments" class="headerlink" title="配置instruments"></a>配置instruments</h2><h3 id="将数据映射到源码中"><a href="#将数据映射到源码中" class="headerlink" title="将数据映射到源码中"></a>将数据映射到源码中</h3><p>Instruments需要关于您项目的精确信息以提供最棒的结果。如果系统能够查看所有与您项目相关的符号你可以获取最完整的数据。在跟踪文档通过Instruments分析工具所产生而显示的是地址而非符号时，你可以手动提供缺失信息。地址所对应的符号被包含在dSYM文件中。通常Instruments会通过你在Instruments偏好设置中指定的路径索引来自动寻找dSYM文件。然而，您可以在Instruments无法自动找到 dSYM时指定其正确的路径。一旦您这样做了，Instruments能将地址映射到其相关联的符号和行信息。</p>
<h4 id="为跟踪文档查找dSYM路径"><a href="#为跟踪文档查找dSYM路径" class="headerlink" title="为跟踪文档查找dSYM路径"></a>为跟踪文档查找dSYM路径</h4><ol>
<li><p>选择 File &gt; Symbols 。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_file_menu_symbols_menuitem.png" alt="img"></p>
<p>这个选项只有在运行了一个跟踪或者载入之前运行的跟踪结果时才会出现。</p>
</li>
<li><p>选择缺失符号的可执行的库或者框架。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_symbols_dialog_binaries.png" alt="img"></p>
</li>
<li><p>点击查找按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_symbols_dialog_locatedysmpath_button.png" alt="img"></p>
</li>
<li><p>在出现的弹窗中选择您的符号或者包含它的文件夹。</p>
</li>
<li><p>点击 open。</p>
</li>
</ol>
<p>为了在跟踪文档中正确显示符号，Instruments需要访问指定符号文件，这个符号文件是在您测试的可执行文件构建之后生成的。因此当您在一台电脑上构建并在另一台电脑上测试性能时，您可能需要手动查找dSYM文件。</p>
<p>在符号弹窗中的筛选栏能让你通过可执行文件、不完整的二进制文件和框架中筛选。同样您也能够通过在搜索框中输入文本来搜索特定的二进制或框架。</p>
<p>注意：默认情况下，Xcode会在构建路径中将symbols保存为dSYM文件。Xcode 通过将扩展添加到可执行名称创建默认的 dSYM 捆绑路径。为了在 Xcode 中创建dSYM文件，进入您项目中的Build Settings(构建设置)，然后选中在Build Options栏中的 Debug Information Format &gt; Dwarf with dSYM File 。</p>
<p>注意：通常，当显示的不是符号而是地址而，地址以黑色显示在左边，在细节窗格中以灰色显示库。您可以通过定位适当的 dSYM 文件来识别这些地址。</p>
<p>如果地址为灰色且未列出拥有库，则无法显示符号名称。没有库名称的灰色地址意味着在记录跟踪时，您无权查看有关该过程的信息。这通常发生在构建设置中的代码签名标识设置为发布生成的发布/分发标识时。您的发布生成应使用与调试生成相同的设置（通常为”iOS 开发人员”）。</p>
<h3 id="设置通用选项"><a href="#设置通用选项" class="headerlink" title="设置通用选项"></a>设置通用选项</h3><p>使用在选项窗口中的通用窗格来配置Instruments的类似启动选项，键盘快捷键和警告选项等基础行为。</p>
<p>选择 Instruments &gt; Preferences 并点击 General。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_general.png" alt="img"></p>
<p>你能够设置如下选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Compress run data</td>
<td style="text-align:left">将每次运行都以 zip 格式保存</td>
</tr>
<tr>
<td style="text-align:left">Enforce initial deck height</td>
<td style="text-align:left">当instrument文档被重新加载并使用模板默认高度时可以防止回复自定义高度。取消选择时，保存并回复当前高度。</td>
</tr>
<tr>
<td style="text-align:left">Sort process lists by identifier</td>
<td style="text-align:left">对所有Instruments App 列表内容以进程 ID 排序。当未选中时，默认以字母排列。</td>
</tr>
<tr>
<td style="text-align:left">Always snap track to fit at end of run</td>
<td style="text-align:left">在运行结束时自动将跟踪缩放到跟踪文档中，以适应窗口中的所有数据。</td>
</tr>
<tr>
<td style="text-align:left">Reset “Don’t Ask Me” Warnings</td>
<td style="text-align:left">重新发布对话警告您以前选择不显示。文书有几个警告对话框，您可以通过在对话框中选择”不要再次显示此消息”复选框来禁用这些对话框。要重新发布所有这些警告对话，请单击重置”不要问我”警告按钮。</td>
</tr>
</tbody>
</table>
<h3 id="设置收集选项"><a href="#设置收集选项" class="headerlink" title="设置收集选项"></a>设置收集选项</h3><p>使用在选项窗口中的 Recording 窗格来配置跟踪在跟踪文档中显示的样式。</p>
<ul>
<li><p>选择 Instruments &gt; Preferences 并点击 Recording。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_recording.png" alt="img"></p>
</li>
</ul>
<p>你能够配置如下选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Recording location</td>
<td style="text-align:left">为新创建的Instruments 文档指定一个位置。默认是一个临时的路径。在这个弹出菜单中自定义一个不同的路径。</td>
</tr>
<tr>
<td style="text-align:left">Background sampling duration</td>
<td style="text-align:left">Sets the length of a sample trace operating in the background. Type a numeric value in the field. Defaults to 5 seconds.</td>
</tr>
<tr>
<td style="text-align:left">Global keyboard shortcuts</td>
<td style="text-align:left">Opens the Keyboard &gt; Shortcuts &gt; Services pane in the System Preferences app, as shown in the Keyboard &gt; Shortcuts &gt; Services pane in System Preferences. From here, you can assign keyboard shortcuts to development services, such as a service that automatically opens an Xcode project in Instruments and profiles it with the System Trace profiling template.</td>
</tr>
<tr>
<td style="text-align:left">Always use deferred mode</td>
<td style="text-align:left">Performs data analysis for all traces after data collection is complete.</td>
</tr>
<tr>
<td style="text-align:left">Automatically time profile spinning applications</td>
<td style="text-align:left">Automatically monitors for a spinning process while a trace is recorded. This can be a process other than the one being recorded. If detected, Instruments starts the Time Profiler instrument on the spinning process.</td>
</tr>
<tr>
<td style="text-align:left">DTrace max buffer size</td>
<td style="text-align:left">Sets the size of the DTrace kernel buffer (in megabytes). The default is 25 MB.</td>
</tr>
<tr>
<td style="text-align:left">DTrace max backtrace depth</td>
<td style="text-align:left">Sets the maximum stack depth that is captured when using a DTrace instrument. The default is 128 frames.</td>
</tr>
<tr>
<td style="text-align:left">Permit zero match probes</td>
<td style="text-align:left">Prevents an error when a specified DTrace probe is not found.</td>
</tr>
<tr>
<td style="text-align:left">Preserve intermediate files</td>
<td style="text-align:left">Prevents Instruments from removing intermediate DTrace data output files from the disk.</td>
</tr>
<tr>
<td style="text-align:left">Flag runtime messages</td>
<td style="text-align:left">Adds flags to the timeline for DTrace runtime status and error messages encountered during a recording.</td>
</tr>
</tbody>
</table>
<p>参考资料</p>
<blockquote>
<p>Instruments Help:<a href="https://help.apple.com/instruments/mac/current/#/dev7b09c84f5" target="_blank" rel="noopener">https://help.apple.com/instruments/mac/current/#/dev7b09c84f5</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/iOS推送-APNs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/02/iOS推送-APNs/" itemprop="url">iOS推送(APNs)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T20:44:21+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS推送-APNs"><a href="#iOS推送-APNs" class="headerlink" title="iOS推送(APNs)"></a>iOS推送(APNs)</h1><h2 id="什么是APNs"><a href="#什么是APNs" class="headerlink" title="什么是APNs"></a>什么是APNs</h2><p>iOS 在系统层面与苹果 APNs（Apple Push Notification service）服务器建立连接，应用通过观察者模式向 iOS 系统注册关注的消息，系统收到 APNs Server 消息后转发到相应的应用程序，整个过程很清晰，并且所有 APP 都共用同一个系统级的连接，减少了系统开销，虽然 APNs 能无障碍的访问，但实际使用过程中，发现延时和丢消息的情况偶有发生。</p>
<h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><ul>
<li><strong>本地通知：</strong>应用在本地配置通知详细信息并将其传递给系统，然后系统会根据所配置的通知内容选择适当的时机推送。</li>
<li><strong>远程通知：</strong>使用公司服务器或者第三方服务器通过 APNs 来将数据推送给用户设备。</li>
</ul>
<p><strong>本地通知：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/本地推送.jpg" alt="本地推送.jpg"></p>
<p><strong>远程通知:</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/远程推送.jpg" alt="远程推送.jpg"></p>
<p>本地通知和远程通知对用户来说看起来是一样的。两种类型的通知都具有相同的由系统提供的默认外观。在某些情况下可以自定义外观，可以使用如下选项之一来发送通知：</p>
<ul>
<li>通知横幅。</li>
<li>应用程序右上角的角标。</li>
<li>一个有声音的横幅或者有声音的角标。</li>
</ul>
<h2 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h2><p><strong>远程推送流程：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送流程.png" alt="简单推送流程.jpg"></p>
<p><strong>流程描述：</strong></p>
<ol>
<li><strong>服务器将消息先发送到苹果的 APNs。</strong></li>
<li><strong>APNs 将消息推送到用户设备。</strong></li>
<li><strong>由 iOS 系统将收到的消息传递给相应的 App。</strong></li>
</ol>
<p>首先我们着重观察这两个角色 Provider 和 APNs。</p>
<p>Provider：可以理解为我们的业务服务器，他的需要做以下几件事情：</p>
<ul>
<li>在 APNs 中接收全球唯一的、与应用对应的设备令牌(Device Token)和与其相关的数据。</li>
<li>根据通知系统的设计与业务来确定何时远程推送需要推送到每个设备。</li>
<li>构建远程通知并向 APNs 发送推送请求，每个请求都包含<strong>通知载荷</strong>和<strong>被传输的信息</strong>。APNs 接着代表您向目标设备发送相应通知。</li>
</ul>
<p>对于业务服务器向 APNs 发送的每一个远程通知请求，都必须遵守如下要求：</p>
<ol>
<li>构造一个包含通知载荷的 JSON 字典。</li>
<li>添加有效载荷、一个全球唯一的设备令牌和其他需要被交付的HTTP / 2请求信息。</li>
<li>通过持久、安全的通道向APNs发送包含加密凭证或证书的令牌。</li>
</ol>
<h3 id="有效载荷-payload"><a href="#有效载荷-payload" class="headerlink" title="有效载荷(payload)"></a>有效载荷(payload)</h3><p>Provider 给 APN 发送的每个通知都需要包含一个有效载荷。有效载荷包含要发送到应用程序的任何自定义数据，并包含一些系统默认的信息，这些默认信息是高度系统用何种方式通知用户。需要将有效载荷构造为 JSON 字典，并将其作为 HTTP/2消息的正文发送。</p>
<p>以下示例说明了 JSON 字典的结构以及可以包含在通知中的键。有效载荷中最重要的部分就是<code>aps</code>字典，其中包括了 Apple定义的键，这些键用在 APP 中控制推送消息所需要展示的样式。</p>
<p>请注意在以下所有的示例中，均有一个自定义的键<code>acme</code>，这个键只是作为演示作用出现。</p>
<p><strong>示例 1.</strong>只包含推送内容的简单推送样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Message received from Bob&quot; &#125;,</span><br><span class="line">    &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例1.png" alt="简单推送示例1"></p>
<p><strong>示例 2.</strong>以下有效载荷中包含了标题、副标题、消息内容并将 App 应用角标设置为 5。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &#123;</span><br><span class="line">            &quot;title&quot; : &quot;Game Request&quot;,</span><br><span class="line">            &quot;subtitle&quot; : &quot;This is subtitle&quot;</span><br><span class="line">            &quot;body&quot; : &quot;Bob wants to play poker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;badge&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme1&quot; : &quot;bar&quot;,</span><br><span class="line">    &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例2.png" alt="简单推送示例2"></p>
<p><strong>示例 3.</strong>以下有效载荷中包含了通知标题、应用角标和播放的声音。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &quot;You got your emails.&quot;,</span><br><span class="line">        &quot;badge&quot; : 9,</span><br><span class="line">        &quot;sound&quot; : &quot;bingbong.aiff&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme1&quot; : &quot;bar&quot;,</span><br><span class="line">    &quot;acme2&quot; : 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例3.png" alt="image-20190902210414660"></p>
<p><strong>示例 4.</strong>添加指定的本地化键值内容来告诉 App 应该展示为什么语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &#123;</span><br><span class="line">            &quot;loc-key&quot; : &quot;GAME_PLAY_REQUEST_FORMAT&quot;,</span><br><span class="line">            &quot;loc-args&quot; : [ &quot;Jenna&quot;, &quot;Frank&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sound&quot; : &quot;Call.wav&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme&quot; : &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的Apple预定义的键值对请查阅<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html#//apple_ref/doc/uid/TP40008194-CH17-SW1" target="_blank" rel="noopener">有效载荷键参考</a>。</p>
<h3 id="设备令牌-device-token"><a href="#设备令牌-device-token" class="headerlink" title="设备令牌(device token)"></a>设备令牌(device token)</h3><p>设备令牌是由 Apple 创建的一串特定数据，这一串特定的数据可以将其分配给指定设备上的指定应用()。只有 Apple 能够对其解码并读取设备令牌内容。每个应用程序在向 APN 注册时都会收到其唯一的设备令牌，然后必须将其发送给我们对应的业务服务器。当业务服务器需要发起推送请求的时候必须包含该设备令牌，该请求以指定设备为目标。</p>
<p>APN 在以下情况下可能会分发新的设备令牌：</p>
<ul>
<li>用户在新设备上安装应用。</li>
<li>用户从备份中回复设备。</li>
<li>用户重新安装操作系统。</li>
<li>其他系统定义的事件</li>
</ul>
<h3 id="如何获取设备令牌"><a href="#如何获取设备令牌" class="headerlink" title="如何获取设备令牌"></a>如何获取设备令牌</h3><h4 id="设备和-APN-的连接"><a href="#设备和-APN-的连接" class="headerlink" title="设备和 APN 的连接"></a>设备和 APN 的连接</h4><p><img src="/2019/09/02/iOS推送-APNs/service_device_ct.png" alt="service_device_ct.jpg"></p>
<p>APN 与设备交互的原理如下：</p>
<ol>
<li>当设备启动时会与 APNs 开始建立 TLS 连接。</li>
<li>APN 向设备返回 APNs 证书。</li>
<li>操作系统成功认证该证书之后将设备证书发送给 APNs。</li>
<li>最后 APNs 验证设备证书，与设备建立信任。</li>
</ol>
<p>通过设备与 APNs 建立 TLS 连接之后，设备上的应用程序可以向 APNs 注册以接受其特定的<strong>设备令牌</strong>以进行远程通知。</p>
<p>由于设备令牌是用以标志特定设备指定应用程序的唯一标示，所以业务服务器必须存储该设备令牌。</p>
<p><strong>管理设备令牌过程如下图所示：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/token_generation.png" alt="token_generation.jpg"></p>
<p>在设备与 APNs 建立连接之后，获取用于特定应用程序的设备令牌的流程如下：</p>
<ol>
<li>应用程序向 APNs 注册以进行远程通知。如果应用程序已经注册并且用于特定应用程序的设备令牌未更改，则系统将会快速将现有令牌返回到应用程序，此过程将跳至步骤3。</li>
<li>当需要新的设备令牌的时候，APNs 使用设备证书中包含的信息生成一个令牌。它使用令牌密钥加密令牌并将其返回到设备中。</li>
<li>收到令牌后，应用程序必须以二进制或者十六进制格式转发给你的业务服务器。若无此令牌，业务服务器无法向设备发送通知。</li>
</ol>
<p>在业务服务器接收到了设备令牌，此时业务服务器可以开始向 APNs发送通知请求，谨记每个请求必须包含着设备令牌。其流程如下所示：</p>
<p><img src="/2019/09/02/iOS推送-APNs/token_trust.png" alt="token_trust.jpg"></p>
<h4 id="Provider-与-APNs-的连接"><a href="#Provider-与-APNs-的连接" class="headerlink" title="Provider 与 APNs 的连接"></a>Provider 与 APNs 的连接</h4><p>Provider和 APNs 建立连接有两种方式：</p>
<ul>
<li>基于令牌建立连接。</li>
<li>基于证书建立连接。</li>
</ul>
<h5 id="基于令牌建立连接"><a href="#基于令牌建立连接" class="headerlink" title="基于令牌建立连接"></a>基于令牌建立连接</h5><p><img src="/2019/09/02/iOS推送-APNs/service_provider_ct.png" alt="service_provider_ct.jpg"></p>
<p>在开发者账号中进行配置，生成唯一的服务器 Token，使用该 Token 与 APNs 建立连接。</p>
<p><strong>基于 Token 的连接可以向包含这个证书的账号下的所有 app 发送推送。</strong></p>
<h5 id="基于证书建立连接"><a href="#基于证书建立连接" class="headerlink" title="基于证书建立连接"></a>基于证书建立连接</h5><p><img src="/2019/09/02/iOS推送-APNs/service_provider_ct_certificate.png" alt="service_provider_ct_certificate_2x.png"></p>
<p>基于证书的服务器连接只支持某一个特定的应用。证书需要在服务器上根据bundle 提前生成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/09/02/iOS推送-APNs/APNs-Push.jpg" alt="äºè§£iOSæ¶æ¯æ¨éä¸æå°±å¤ï¼å²ä¸æå¨iOS Pushææ¯è¯¦è§£_19.jpg"></p>
<ul>
<li>1) 首先是应用程序注册消息推送；</li>
<li>2) iOS跟APNS Server要deviceToken。应用程序接受deviceToken；</li>
<li>3) 应用程序将deviceToken发送给PUSH服务端程序；</li>
<li>4) 服务端程序向APNS服务发送消息；</li>
<li>5) APNS服务将消息发送给iPhone应用程序。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《Local and Remote Notification Programming Guide》：<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1</a></p>
<p>《什么是消息推送》：<a href="https://blog.csdn.net/qq_34531925/article/details/80250317" target="_blank" rel="noopener">https://blog.csdn.net/qq_34531925/article/details/80250317</a></p>
<p>《iOS 必知必会 - APNs篇》：<a href="https://www.jianshu.com/p/13185cba2abf" target="_blank" rel="noopener">https://www.jianshu.com/p/13185cba2abf</a></p>
<p>《了解iOS消息推送一文就够：史上最全iOS Push技术详解》：<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=1762&amp;highlight=%CD%C6%CB%CD" target="_blank" rel="noopener">http://www.52im.net/forum.php?mod=viewthread&amp;tid=1762&amp;highlight=%CD%C6%CB%CD</a></p>
<p>《苹果远程推送通知 APNs 详解》：<a href="https://segmentfault.com/a/1190000012019282" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012019282</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/年度总结——追寻危机感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/年度总结——追寻危机感/" itemprop="url">年度总结——追寻危机感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T21:40:53+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>白驹过隙白云苍狗，寒来暑往日月如梭………….(后面省略一万字)。文章断断续续写了好久，因为不知道从何开始讲起。我们现在就从我刚工作开始讲起吧。</p>
<p>说实在话，我的第一份工作也来的非常巧合。在大三结束前几个月我自认为学了点 iOS 开发的皮毛就到处投实习生简历，结果现实用事实告诉了我我当时连学到一点皮毛都算不上。甚至写几个简单的自定义视图都磕磕绊绊的。不过凑巧的是同学投中了一家公司约去面试，然后带上了我。一顿面试笔试结束之后同学不幸落选，而我却意外地进入到了人生的第一家公司里工作。刚开始的那段时间真的是让我真真切切感受到了”刘姥姥进大观园”时的感受。长连接、UIDynamic、实时通讯和大量的自定义视图。让我非常感兴趣也让我非常惊恐——公司里要求那么高不会不会无法通过实习期？此前，我还在校园里念书学习的时候并没有丝毫的这种紧张感和危机感。可能是因为真正要开始工作了，感受到了一个无形的担子压在了我的身上，就像一个落水的人只能向着远方的岸边奋力的游去。于是在那段时间里我在宿舍中唯一做的就是看代码，然后跟着敲一遍。遇到不懂得就去谷歌(当时还不知道如何查官方文档)。并且由于我刚开始学的是 Swift，但是到了公司之后发现实际上使用的仍然是 Objective-C 开发。当时的我也只能不断的告诉自己需要花费更多的时间才能够跟随的上公司的步伐，勤能补拙、人一己百。就这样我慢慢的踏出了开发的第一步。也正是因为那段时光让我和谷歌达成了“搜索战略协议“，并且也养成了一个好习惯——在能够谷歌的情况下绝对不问师傅。</p>
<p>不过既然今年是博客搭建的第一年，那么今年的总结不妨就从博客开始说起吧。</p>
<p>博客是去年的三月份就已经搭建好了，但是那段时间忙着大学毕业论文，所以虽然搭建了博客但是并没有投入使用。等到第一篇博客发布也是答辩完成——两个月后了。答辩完成前我先去找了一份工作，主要做的是房产中介 App 的开发。从这个时间开始一直到今年的一月份，刚开始的两到三个月内基本上都在维护和迭代旧版本的 App。再之后来了新的产品经理之后一直到离职位置均保持着一个月一个 App 的进度。包括重构老版本 App 和开发新 App。开发速度还有往上提提的空间，我一直想着要建一个本地私有库一直都没有完成，这算是一大遗憾。说到遗憾，其实去年对自己的表现评价一下的话也就最多只能打一个基础分六十分。因为去年有太多太多的 flag 尚未完成，又继续拖到了今年：</p>
<ul>
<li>建立本地私有库并记录自己的经历。</li>
<li>写一篇关于 RAC 的博客。</li>
<li>完成<code>iOS 中的 weak</code>。</li>
<li>完成<code>GPUImage 使用心得</code>。</li>
<li>完成<code>UIView和 CALayer</code>。</li>
<li>看完<code>精通 Objective-C</code>。</li>
</ul>
<p>确实有太多太多的设想和为自己设立的目标都未完成。连这篇博客都是初五晚上才堪堪写完。这一切都要归咎于自己对自己还不够严苛、不够自律并且执行力和行动力不足。最近偶然间看到一篇文章里面说道这么一句话——<strong>成大事者：事不拖，话不多，人不作！</strong>这句话总结的是曾国藩一生的做人做事之道。我还没到足够的高度来评价曾国藩，但是单论这句话中的事不脱却是说的极好的。从大学毕业真正踏入社会开始，我看见过很多朋友同事在计划或者工作任务未完成的时候说的都是——“我真的太懒了”、“我有拖延症”等等。这些无法是一个人工作未完成的理由。你不克服它你就不得丝毫寸进！我再写这篇博客的时候我在知乎上搜了一下<a href="https://www.zhihu.com/question/20357585" target="_blank" rel="noopener">如何克服严重的拖延症</a>这个话题的关注者人数是<strong>81768</strong>，而<a href="https://www.zhihu.com/topic/19555404/hot" target="_blank" rel="noopener">iOS 开发</a>的关注者是<strong>99329</strong>。光这两个数字就能说明拖延症并不在少数。这可不是一个好的征兆！所以我认为<strong>事不拖</strong>是一个成功者必须具备的条件之一。而话不多和人不作目前保持观望态度。</p>
<p>一言蔽之，去年的我需要更大的执行力和行动力。所以我对今年制定的第一个目标是——<strong>拥有更加强大的执行力和行动力。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/接口安全及签名规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/17/接口安全及签名规范/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-17T15:49:58+08:00">
                2019-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口安全及签名规范"><a href="#接口安全及签名规范" class="headerlink" title="接口安全及签名规范"></a>接口安全及签名规范</h1><h2 id="0-敏感数据本地加密后传输"><a href="#0-敏感数据本地加密后传输" class="headerlink" title="0.敏感数据本地加密后传输"></a>0.敏感数据本地加密后传输</h2><ul>
<li>数据安全:所有敏感数据如：登录密码、支付密码、手机号等在传输过程之中需要加密。</li>
<li>加密方式:HMAC+MD5+key 。</li>
<li>流程<ul>
<li>用户注册：在用户注册的时候判断用户是否允许注册，若允许注册则由服务器产生加密所使用的 key并保存到数据库中，在客户端保存该 key(可以加密也可以明文)。调用注册接口进行注册时，传递加密后的密码，由服务器存入数据库。</li>
<li>用户登录：在用户登录的时候，若是客户端不存在 key，则需要向服务端获取。</li>
<li>一个用户一个 key，该 key 推荐定时更新。</li>
<li>若某客户端无可以，此时需要向服务端获取。但是服务端允许直接返回 key，而是服务端请求具有 key 的另外客户端询问是否授权。此时服务器需要维护一个用户所登录的设备集合。</li>
</ul>
</li>
</ul>
<p>类似用户密码、手机号等敏感数据在传输过程中需要加密，加密的方式选择RSA/SHA1/MD5/HMAC在敏感数据加盐后再加密用以保护。</p>
<h2 id="1-使用-token-标志用户"><a href="#1-使用-token-标志用户" class="headerlink" title="1.使用 token 标志用户"></a>1.使用 token 标志用户</h2><p>api_token、user_token、refresh_token</p>
<h2 id="2-网络请求添加签名"><a href="#2-网络请求添加签名" class="headerlink" title="2.网络请求添加签名"></a>2.网络请求添加签名</h2><ul>
<li><p>请求头</p>
<ul>
<li>sign : 密文主体</li>
<li>timestamp : 当前时间戳整形</li>
<li>nonce : 随机字符串用于签名和防重放</li>
<li>Authorization : 用户 token</li>
</ul>
<p>签名规则</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">nonce:</span>需要为不能重复的字符串，需要定义加密方法，例如<span class="symbol">:nonce=</span>时间戳+设备ip地址+设备 Mac 地址然后 MD5。服务端需要保存此值用于之后防重放(多个网络请求需要保存多个值，需要保存成集合)。请注意该集合需要被清理，具体的清理时间。这里我们使用nonce=MD5(时间戳+UUID)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.首先在请求头添加 sign 字段用于表示该网络请求所发起的时间。</span><br><span class="line"><span class="number">2</span>.将网络请求参数根据参数名的 ASCII 码从小到大进行排序，再使用 URL键值对的形式(即key1=value1&amp;key2=value2…请注意此处当参数为最后一个的时候将不需要拼接&amp;符号)拼接成字符串StringA。</span><br><span class="line"><span class="number">3</span>.在 StringA 最后拼接上 timestamp 、 token 、 nonce，接着对拼接之后的字符串进行 MD5/RSA 加密，再将加密结果得到的字符串全部转为大写并存入sign字段。</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 注意：POST/</span>GET请求需要使用相同的加密方法。 </span><br><span class="line">/<span class="regexp">/ 若是参数中存在字典或者数组，请将其转换为 JSON 字符串再进行拼接</span></span><br></pre></td></tr></table></figure>
<p>范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ulr:				https://baidu.com/login</span><br><span class="line">params:				</span><br><span class="line">&#123;</span><br><span class="line">    latitude = 121.58299,</span><br><span class="line">    longitude = 29.85297,</span><br><span class="line">    udi = 55;</span><br><span class="line">&#125;</span><br><span class="line">timestamp:			1547867794</span><br><span class="line">nonce:				b2a6675a75ed2d0b39da3e2f03805790	</span><br><span class="line">StringA:		    latitude=121.58299&amp;longitude=29.85297&amp;udi=55</span><br><span class="line"></span><br><span class="line">拼接后字符串:			</span><br><span class="line">latitude=121.58299&amp;longitude=29.85297&amp;udi=551547867794eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIgb2a6675a75ed2d0b39da3e2f03805790</span><br><span class="line"></span><br><span class="line">Authorization:		</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIg</span><br><span class="line"></span><br><span class="line">sign:	规则:sign = MD5((StringA + timestamp + token + nonce).upperCase())	</span><br><span class="line">sign:   13541B7DBF0092DE2D9DDEF4009DBE74</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-接口防重放功能"><a href="#3-接口防重放功能" class="headerlink" title="3.接口防重放功能"></a>3.接口防重放功能</h2><ol>
<li><p>使用物理防火墙。例如：指定某请求在给定时间内允许访问几次</p>
</li>
<li><p>代码防重放(timestamp + nonce)</p>
<ol>
<li>在用户登录或者更新用户信息的时候使用某一接口(例如：ClienPing)获取 App 本地时间和服务器时间的差值，服务器需要保存此差值，用于防重放功能。</li>
<li>在签名验证步骤之前判断用户发起的网络请求中的时间戳和服务器的时间戳差值(例如有效时间是一分钟)是否在允许的范围之内。</li>
<li>在判断时间有效之后需要服务端需要在用户的 nonce 集合中判断是否已经存在了该值，如果存在则拒绝该网络请求。否则记录该 nonce 值，并允许该请求。</li>
<li>清理 nonce 集合，需要定制nonce集合清理的时机(可以选择一定大小和一定时机清理)，例如:若有效时间设置为一分钟，则判断某用户某一次请求时其 nonce 集合的最后修改时间是否早于该请求一分钟，若是，则删除集合，否则继续添加。</li>
</ol>
</li>
<li><p>服务器验证顺序</p>
<p>1 先验证sign签名是否合理，证明请求参数没有被中途篡改<br>2 再验证timestamp是否过期，证明请求是在最近60s被发出的<br>3 最后验证nonce是否已经有了，证明这个请求不是60s内的重放请求</p>
</li>
</ol>
<h2 id="4-接口验证不通过返回状态码"><a href="#4-接口验证不通过返回状态码" class="headerlink" title="4.接口验证不通过返回状态码"></a>4.接口验证不通过返回状态码</h2><ul>
<li>401</li>
<li>402</li>
<li>403</li>
</ul>
<blockquote>
<p>参考资料：</p>
<p>深入了解Token认证的来龙去脉:<a href="https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc</a></p>
<p>Web签名加密:<a href="https://www.cnblogs.com/letcafe/p/loginSecurity.html" target="_blank" rel="noopener">https://www.cnblogs.com/letcafe/p/loginSecurity.html</a></p>
<p>JWT:<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/01/iOS-CALayer-教程-入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/iOS-CALayer-教程-入门/" itemprop="url">iOS CALayer 教程:入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T16:18:16+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-CALayer-教程-入门"><a href="#iOS-CALayer-教程-入门" class="headerlink" title="iOS CALayer 教程:入门"></a>iOS CALayer 教程:入门</h1><blockquote>
<p>原文链接:<a href="https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started" target="_blank" rel="noopener">CALayer Tutorial for iOS: Getting Started</a></p>
<p>作者:Michael Ciurus</p>
<p>最近在研究 CALayer 和 UIView 之间的联系和区别，看完这篇文章介绍的 <code>CALayer</code>子类和其使用介绍的挺详细的，所以翻译一下这篇文章。</p>
<p>译者注：原文中 layer 可能在文章中被翻译为’图层’，corner radius 被翻译为’角半径’</p>
</blockquote>
<p>在这篇教程中，你将会学习到什么是<code>CALayer</code>，并且能看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p><strong>升级说明</strong>：本教程已由<a href="https://www.raywenderlich.com/u/michalciurus" target="_blank" rel="noopener">Michael Ciurus</a>升级到 iOS11，Swift4和Xcode9。原教程作者是<a href="https://www.raywenderlich.com/u/scotteg" target="_blank" rel="noopener">Scott Gardner</a>。</p>
<p>可能正如你知道的，在 iOS App 中你看到的所有的东西都是View。有button view,table view,slider view,甚至是包含其他视图的父视图。</p>
<p>你可能不知道的是每个在 iOS 中的每个 view都由一个另外的名为图层——<code>CALayer</code>的类提供支持。</p>
<p>在本篇教程中，你将会了解到什么是<code>CALayer</code>并且知道它是如何工作的。你同样也会看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p>本文章的前提是你已经了解了作为 iOS App 的基础和Swift，包括使用 storyboard构建 UI。</p>
<blockquote>
<p><strong>注意：</strong>如果你并不擅长这个，别担心。我们关于这个主题我们有多个教程和书籍，例如 <a href="http://www.raywenderlich.com/77176/learn-to-code-iOS-apps-with-swift-tutorial-4" target="_blank" rel="noopener">Learn to Code iOS Apps with Swift</a>and <a href="http://www.raywenderlich.com/store/iOS-apprentice" target="_blank" rel="noopener">The iOS Apprentice</a>。</p>
</blockquote>
<h2 id="CALayer-和UIView-有何关系？"><a href="#CALayer-和UIView-有何关系？" class="headerlink" title="CALayer 和UIView 有何关系？"></a>CALayer 和UIView 有何关系？</h2><p><code>UIView</code>处理非常多的事情，例如：布局、响应事件等。有一点很有意思，<code>UIView</code>并不直接参与处理绘制或者动画，而是<code>UIView</code>将其交付给它的兄弟——<code>Core Animation</code>来处理。事实上<code>UIView</code>是<code>CALayer</code>的包装容器。当你在一个<code>UIView</code>上设置了<code>bounds</code>之后，视图只是将<code>bounds</code>设置在了其背后的<code>CALayer</code>上。如果你在<code>UIView</code>上调用了<code>layoutIfNeed</code>方法，该方法会转发给其根<code>CALayer</code>。每个<code>UIView</code>都有一个能够拥有<code>subLayers</code>的根<code>CALayer</code>。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/uiview.png" alt="uiview"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>最简单的了解<code>layer</code>是什么的途径就是在看它们在实际运用中的效果。你将会从一个简单的项目开始使用layers。<a href="https://koenig-media.raywenderlich.com/uploads/2017/08/LayerStarterProject.zip" target="_blank" rel="noopener">下载</a>这个简单的只在中心插入了视图的 App。</p>
<p>在 <strong>ViewController.swift</strong>中使用如下代码替换其内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> viewForLayer: <span class="type">UIView</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> layer: <span class="type">CALayer</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> viewForLayer.layer</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setUpLayer()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setUpLayer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    layer.backgroundColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line">    layer.borderWidth = <span class="number">100.0</span></span><br><span class="line">    layer.borderColor = <span class="type">UIColor</span>.red.cgColor</span><br><span class="line">    layer.shadowOpacity = <span class="number">0.7</span></span><br><span class="line">    layer.shadowRadius = <span class="number">10.0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如之前提到的，每一个<code>UIView</code>都有一个<code>layer</code>与其关联，并且你能够是用<code>.layer</code>获得它。以上代码的第一件事情就是创建了一个名为<code>layer</code>的计算属性来访问<code>viewForLayer</code>的<code>layer</code>。</p>
<p>代码中同样也调用了<code>setUpLayer()</code>方法，用以设置图层的一些属性——阴影、蓝色的背景颜色和巨大的红色边框颜色。等会你将会学习到更多关于<code>setUpLayer()</code>方法，但是现在首先要做的事情是构建并运行iOS模拟器来查看你自己定义的图层。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-1-281x500.png" alt=""></p>
<p>只使用了短短几句代码就实现了酷炫的效果，对吧？并且由于所有的<code>view</code>都是由<code>layer</code>提供支持的，所以你可以在你的 app 中对所有的视图做如上操作。</p>
<h2 id="基础CALayer属性"><a href="#基础CALayer属性" class="headerlink" title="基础CALayer属性"></a>基础<code>CALayer</code>属性</h2><p><code>CALayer</code>拥有一些列的方法让你可以自定义外观。回想一下你刚才所做的事情:</p>
<ul>
<li>将其图层的背景颜色从默认的无颜色设置为蓝色。</li>
<li>改变图层的<code>borderWidth</code>从默认的0设置为100来赋予其边框。</li>
<li>改变其边框颜色，从默认的黑色改变为红色。</li>
<li>并且最后，改变其<code>shadowOpacity</code>属性，从默认的0(完全透明)到0.7，来赋予其阴影。仅这一点就会使得阴影显示出来，然后下一步增加了其阴影半径，从默认的3到10。</li>
</ul>
<p>这还只是您可以在<code>CALayer</code>设置的部分属性。接下来我们继续尝试两个属性。在<code>setUpLayer()</code>的底部添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>在<code>CALayer</code>中的<code>contents</code>属性允许你使用图片设置其内容，所以在这里你是使用名为’star’的图片设置了其图层内容。该图片已经在初始项目中提供。</p>
<p>构建并运行然后花点时间欣赏一下那令人惊叹的艺术品:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-2-179x320.png" alt="CALayerPlayground-2"></p>
<p>为什么五角星会在被定位在中心呢？这是因为你将<code>kCAGravityCenter</code>设置到了其属性<code>contentsGravity</code>上。正如你所预料的那样，你同样能够将其位置设置为顶部、顶部偏右、右侧、底部偏右、底部、底部偏左、左侧和顶部偏左。</p>
<h2 id="改变图层的外观"><a href="#改变图层的外观" class="headerlink" title="改变图层的外观"></a>改变图层的外观</h2><p>初始项目包含了<code>tap</code>和<code>pinch</code>的手势识别器。</p>
<p>将<code>tapGestureRecognized(_:)</code>方法改变为如下所示:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">  layer.shadowOpacity = layer.shadowOpacity == <span class="number">0.7</span> ? <span class="number">0.0</span> : <span class="number">0.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码将告诉<code>viewForLayer</code>的图层当视图响应<code>tap</code>时，将其图层的阴影不透明在0和0.7之间切换。</p>
<p>你可能会问，那视图呢？当然你也可以覆写<code>CALayer</code>的 <code>hitTest(_:)</code> 来做同样的事情，并且你也会在本文的后面看到这种方式。但是<code>hitTest</code>是图层能做的全部了，因为图层无法响应手势识别器。这就是为什么你在视图中创建<code>tap</code>的手势识别器。</p>
<p>现在将 <code>pinchGestureRecognized(_:)</code> 中的实现改为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UIPinchGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> offset: <span class="type">CGFloat</span> = sender.scale &lt; <span class="number">1</span> ? <span class="number">5.0</span> : -<span class="number">5.0</span></span><br><span class="line">  <span class="keyword">let</span> oldFrame = layer.frame</span><br><span class="line">  <span class="keyword">let</span> oldOrigin = oldFrame.origin</span><br><span class="line">  <span class="keyword">let</span> newOrigin = <span class="type">CGPoint</span>(x: oldOrigin.x + offset, y: oldOrigin.y + offset)</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="type">CGSize</span>(width: oldFrame.width + (offset * -<span class="number">2.0</span>), height: oldFrame.height + (offset * -<span class="number">2.0</span>))</span><br><span class="line">  <span class="keyword">let</span> newFrame = <span class="type">CGRect</span>(origin: newOrigin, size: newSize)</span><br><span class="line">  <span class="keyword">if</span> newFrame.width &gt;= <span class="number">100.0</span> &amp;&amp; newFrame.width &lt;= <span class="number">300.0</span> &#123;</span><br><span class="line">    layer.borderWidth -= offset</span><br><span class="line">    layer.cornerRadius += (offset / <span class="number">2.0</span>)</span><br><span class="line">    layer.frame = newFrame</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你基于用户的<code>pinch</code>来创建一个正的或者一个负的偏移量，并接着调整图层<code>frame</code>中的大小、边框宽度和边框的角半径。</p>
<p>一个图层(layer)的角半径默认是零，这就意味着此时是标准的拥有90度角的正方形。可以通过增加角半径来创建圆角。想要将正方形转变为圆形？只需要将其角半径设置为其宽度的一半。</p>
<p>构建并运行，然后尝试点击和捏合你的视图:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-3-179x320.png" alt="CALayerPlayground-3"></p>
<p>只需要一点润色你就可以自己拥有一个非常漂亮的头像。</p>
<h2 id="很棒的CALayer-之旅"><a href="#很棒的CALayer-之旅" class="headerlink" title="很棒的CALayer 之旅"></a>很棒的CALayer 之旅</h2><p><code>CALayer</code>不仅仅只拥有方法和属性可以设置，它还有一系列具有特有方法和属性子类。</p>
<p>有什么比查看教程更好的符合raywenderlich.com风格的方式来了解这些很棒的 API 呢?</p>
<p>在本文接下来的部分中，你需要如下准备：</p>
<ul>
<li><a href="https://github.com/raywenderlich/LayerPlayer" target="_blank" rel="noopener">The Layer Player Source Code</a></li>
<li><a href="http://bit.ly/AppStoreLayerPlayer" target="_blank" rel="noopener">The Layer Player App (可选)</a></li>
</ul>
<p>这是一个拥有你将在本文中学习到的十种不同<code>CALayer</code>子类范例的便捷 App。这里有许多很棒的例子：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/starter-480x285.png" alt="Layer Player screenshots"></p>
<p>当你浏览下面每个例子之前，我建议你先使用一下上述<code>CALayer</code>的 App，并且看看源码。在本文的剩余部分中，你并不需要真正写任何代码，所以请放心坐下并防松阅读。</p>
<h2 id="范例1：CALayer"><a href="#范例1：CALayer" class="headerlink" title="范例1：CALayer"></a>范例1：CALayer</h2><p>你已经看过了使用<code>CALayer</code>的例子，并且设置了一些它的属性。</p>
<p>以下还有一些之前尚未提到过的内容：</p>
<ul>
<li><strong>图层能够拥有子图层</strong>。就类似视图能够拥有子视图一样，图层能够拥有子图层。你可以使用这个来创建一些酷炫的效果。</li>
<li><strong>图层属性具有动画效果</strong>。当你改变了图层的属性，默认情况下会对其进行动画处理。你也可以根据自己的时间来自定义动画行为。</li>
<li><strong>图层是轻量级的</strong>。图层相较于视图来说更加轻量级，因此它能够带来更高的性能。</li>
<li><strong>图层拥有大量使用的属性</strong>。你已经在之前看到过其部分的属性了，现在让我们看更多属性。</li>
</ul>
<p>你接下来将会看到<code>CALayer</code>的一个完整属性列表，其中有部分你还尚未接触过，它们非常方便！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layer = <span class="type">CALayer</span>()</span><br><span class="line">layer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>正如你之前看到的，上述代码是创建了一个<code>CALayer</code>实例，并将<code>someView</code>的<code>bounds</code>赋值给它。接着将图片设置为图层的内容并将其在图层内居中。请注意，此处使用的是底层Quartz图片数据(<code>CGImage</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layer.magnificationFilter = kCAFilterLinear</span><br><span class="line">layer.isGeometryFlipped = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当图片通过<code>contentsGravity</code>被扩大尺寸时使用如上滤镜，这可以用于调整尺寸(调整大小、调整宽高比和调整宽高比填充)和位置(例如：中心、顶部、顶部偏右、右侧等)。</p>
<p>如上的变更并不具有动画效果，并且如果<code>isGeometryFlipped</code>并非被设置为<code>true</code>。那么该图层的几何位置和阴影将会上下颠倒。我们接着继续：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layer.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">11</span>/<span class="number">255.0</span>, green: <span class="number">86</span>/<span class="number">255.0</span>, blue: <span class="number">14</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">layer.opacity = <span class="number">1.0</span></span><br><span class="line">layer.isHidden = <span class="literal">false</span></span><br><span class="line">layer.masksToBounds = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>你将图层的颜色设置为Ray 最喜欢的绿色阴影。这能够使得图层不透明并且可见。同时，你告诉图层不要遮罩其本身内容，这意味着当其本身尺寸大小小于其内容(五角星形图片)时，图片不会被裁剪。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layer.cornerRadius = <span class="number">100.0</span></span><br><span class="line">layer.borderWidth = <span class="number">12.0</span></span><br><span class="line">layer.borderColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>将图层的角半径设置为其宽度的一半，这样来创建出一个圆形带边框的图层。请注意这里的图层颜色将被设置为Quartz颜色的引用(<code>CGColor</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layer.shadowOpacity = <span class="number">0.75</span></span><br><span class="line">layer.shadowOffset = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">layer.shadowRadius = <span class="number">3.0</span></span><br><span class="line">someView.layer.addSublayer(layer)</span><br></pre></td></tr></table></figure>
<p>你创建了阴影并且将<code>shouldRasterize</code>属性设置为<code>true</code>(稍后讨论)，接着将图层添加到视图层次中。</p>
<p>最终结果如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayer-250x250.png" alt="CALayer"></p>
<p><code>CALayer</code>拥有两个额外属性，这两个额外的属性可以提升其性能：<code>shouldRasterize</code> 和 <code>drawsAsynchronously</code>。</p>
<p><code>shouldRasterize</code>默认是<code>false</code>，并且当其被设置为<code>true</code>的时候能够提升性能，这是因为图层只需要被渲染一次。这对于那些在屏幕内具有动画效果但是外观不会改变的对象十分有用。</p>
<p><code>drawsAsynchronously</code>与<code>shouldRasterize</code>洽洽相反。<code>shouldRasterize</code>默认也是<code>false</code>。当图层内容被反复绘制的时候将该属性设置为<code>true</code>将会提升性能，例如当你使用<code>emitter layer</code>持续渲染具有动效的粒子。(在随后的<code>CAEmitterLayer</code>例子中可以看到)</p>
<blockquote>
<p>一句忠告：在设置<code>drawsAsynchronously</code>或<code>shouldRasterize</code>之前先考虑其意义。对比在开启和关闭这两项特性时的性能，这样你能够真正了解这两项性能是否真的能够带来性能上的提升。如果误用，可能会导致性能急转直下。</p>
</blockquote>
<p>现在将你的注意力转移到<strong>Layer Player</strong>上。它包含了多个控件来控制<code>CALayer</code>的属性:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/1-180x320.png" alt="CALayer properties"></p>
<p>试试调节各个控件吧，这是一个很棒的方式来让你了解<code>CALayer</code>到底能够做什么！</p>
<blockquote>
<p>注意：图层并不是响应连的一部分，因此他们并不向视图一样响应直接响应手势和触摸，正如你在CALayerPlayground项目中看到的那样。</p>
<p>然而你可以对其进行点击测试(hit test)，正如你在<code>CATransformLayer</code>实例代码中看到的那样。当你看到<code>CAReplicatorLayer</code>时你将会看到你同样可以对图层的动画进行自定义。</p>
</blockquote>
<h2 id="范例2：CAScrollLayer"><a href="#范例2：CAScrollLayer" class="headerlink" title="范例2：CAScrollLayer"></a>范例2：CAScrollLayer</h2><p><code>CAScrollLayer</code>展示一个可滑动图层的一部分。<code>CAScrollLayer</code>相当基础并且无法直接响应触摸或者用户点击事件来检测可滑动视图的边界，但是它可以做一些有意思的事情，例如：可以防止滑动超出其边界范围。</p>
<p><code>UIScrollView</code>并未使用<code>CAScrollLayer</code>来完成其工作，而是使用直接改变其图层边界的方式代替它。</p>
<p><code>CAScrollLayer</code>能够将其本身设置为横向或者纵向滑动或者横向纵向均可滑动，并且可以通过编程的方式来告诉它滑动到一个特殊的点或者区域。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> scrollingViewLayer: <span class="type">CAScrollLayer</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> scrollingView.layer <span class="keyword">as</span>! <span class="type">CAScrollLayer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  scrollingViewLayer.scrollMode = kCAScrollBoth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">panRecognized</span><span class="params">(<span class="number">_</span> sender: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newPoint = scrollingView.bounds.origin</span><br><span class="line">  newPoint.x -= sender.translation(<span class="keyword">in</span>: scrollingView).x</span><br><span class="line">  newPoint.y -= sender.translation(<span class="keyword">in</span>: scrollingView).y</span><br><span class="line">  sender.setTranslation(<span class="type">CGPoint</span>.zero, <span class="keyword">in</span>: scrollingView)</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  scrollingViewLayer.scroll(to: newPoint)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> sender.state == .ended &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollingViewLayer.scroll(to: <span class="type">CGPoint</span>.zero)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中：</p>
<ol>
<li>计算属性用于返回<code>scrollingView</code>的图层为<code>CAScrollLayer</code>。</li>
<li>将滑动模式设置为横向纵向均可滑动。</li>
<li>当滑动手势被识别，一个新的点会在此时被创建出来并且滑动图层会以使用<code>UIView</code>动画的方式滑动到这个点。注意<code>scroll(to:)</code>并没有自带动画效果。</li>
</ol>
<p>Layer Player演示了一个拥有图片视图的CAScrollLayer，这个图片视图带有一个图片，这个图片超过其滑动视图的边界。当你运行上述代码，并移动视图，其结果应该如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAScrollLayer.gif" alt="CAScrollLayer"></p>
<p> Layer Player包含了两个控件用以锁定水平滑动或者竖直滑动。</p>
<p>以下是一些当你使用(或者不适用)<code>CAScrollLayer</code>的经验之谈:</p>
<ul>
<li>当你想要一些轻量级并且只能通过代码来滑动，那么不妨考虑一下使用<code>CAScrollLayer</code>。</li>
<li>如果你想要用户能够滑动，可能使用<code>UIScrollView</code>更好。想要了解更多这方面的东西，请点击我们的课程 <a href="http://www.raywenderlich.com/93104/video-tutorial-swift-scroll-view-school-part-0-introduction" target="_blank" rel="noopener">18-part video tutorial series</a>。</li>
<li>如果你是滑动一个非常巨大的图片，请考虑使用<code>CATiledLayer</code>(稍后将会带来讲解)。</li>
</ul>
<h2 id="范例3：CATextLayer"><a href="#范例3：CATextLayer" class="headerlink" title="范例3：CATextLayer"></a>范例3：CATextLayer</h2><p><code>CATextLayer</code>能够简单并且快速渲染普通字符串或者属性字符串(attributed strings)。和<code>UILabel</code>不同的是<code>CATextLayer</code>无法拥有<code>UIFont</code>，它只能使用<code>CTFontRef</code>或者<code>CGFontRef</code>。</p>
<p>在如下的代码块中，能够改变字体、字体大小、颜色、对其方式、文字截断方式以及其动画效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> textLayer = <span class="type">CATextLayer</span>()</span><br><span class="line">textLayer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="type">String</span>(</span><br><span class="line">  repeating: <span class="string">"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit </span></span><br><span class="line"><span class="string">             congue dictum. "</span>,</span><br><span class="line">  <span class="built_in">count</span>: <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">textLayer.string = string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">textLayer.font = <span class="type">CTFontCreateWithName</span>(fontName, fontSize, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">textLayer.foregroundColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line">textLayer.alignmentMode = kCAAlignmentLeft</span><br><span class="line">textLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">someView.layer.addSublayer(textLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码说明:</p>
<ol>
<li>创建<code>CATextLayer</code>实例并且将<code>someView</code>的视图边界设置给它。</li>
<li>创建重复的字符串文本，并将其设置给文字图层(text layer)。</li>
<li>创建字体，并将字体设置到文字图层上(text layer)。</li>
<li>设置图层能够换行并且左对齐，(你可以对其方式设置为自然对其方式、右对齐、居中、和文本对其)并且将其<code>contentsScale</code>到屏幕，然后将它加入视图层。</li>
</ol>
<p>所有图层类，不止是<code>CATextLayer</code>渲染放大因子(scale factor)默认为1。当图层依附于视图(view)时，图层会自动拥有一个适应当前屏幕所最合适的放大因子。你需要手动为图层创建确切的<code>contentsScale</code>，或者他们的放大因素为1，但是会在 retain 屏幕上显示像素化。</p>
<p>如果添加到方形<code>UIView</code>中，被创建出的文字图层可能会如下所示:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-250x250.png" alt="CATextLayer"></p>
<p>当你希望使用省略号代表被剪切的文本时，截断(Truncation)是你可以使用的非常合适的设置。截断(Truncation)默认是无(none)，但是你也可以设置为起始位置、中间位置和结束位置：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-StartTruncation.png.png" alt="起始位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-MiddleTruncation.png.png" alt="中间位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-EndTruncation.png" alt="结束位置"></p>
<p>Layer Player拥有多个控件来改变<code>CATextLayer</code>的值:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/3-180x320.png" alt="CATextLayer 属性"></p>
<h2 id="范例4：AVPlayerLayer"><a href="#范例4：AVPlayerLayer" class="headerlink" title="范例4：AVPlayerLayer"></a>范例4：AVPlayerLayer</h2><p><code>AVPlayerLayer</code>向AVFoundation中添加了一个美妙好用的图层。它拥有一个<code>AVPlayer</code>来播放音视频多媒体文件(<code>AVPlayerItem</code>)。如下是一个创建<code>AVPlayerLayer</code>的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player: <span class="type">AVPlayer</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> playerLayer = <span class="type">AVPlayerLayer</span>()</span><br><span class="line">  playerLayer.frame = someView.bounds</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"someVideo"</span>, withExtension: <span class="string">"m4v"</span>)</span><br><span class="line">  player = <span class="type">AVPlayer</span>(url: url!)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  player.actionAtItemEnd = .<span class="keyword">none</span></span><br><span class="line">  playerLayer.player = player</span><br><span class="line">  someView.layer.addSublayer(playerLayer)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                         selector: #selector(playerDidReachEnd),</span><br><span class="line">                                         name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                         object: player.currentItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的接要点如下:</p>
<ul>
<li>创建一个新的播放图层(playerLayer)并设置其边界</li>
<li>使用音视频文件创建播放器(player)</li>
<li>告诉播放器当其播放停止时不做任何额外的操作。额外的操作包括有暂停或播放下一个音视频文件，如果情况允许的话。</li>
<li>注册一个多媒体播放器停止播放的通知。(并将控制器作为观察者在控制器析构的时候移除)。</li>
</ul>
<p>接着，当播放按钮被点击时，播放音视频文件并且设置按钮标题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">playButtonTapped</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> playButton.titleLabel?.text == <span class="string">"Play"</span> &#123;</span><br><span class="line">    player.play()</span><br><span class="line">    playButton.setTitle(<span class="string">"Pause"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    player.pause()</span><br><span class="line">    playButton.setTitle(<span class="string">"Play"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在播放器播放结束时将播放光标移动到初始位置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">playerDidReachEnd</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> playerItem = notification.object <span class="keyword">as</span>! <span class="type">AVPlayerItem</span></span><br><span class="line">  playerItem.seek(to: kCMTimeZero, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意这里只是一个让你入门的简单示例，在真实的项目中，通常不建议切换按钮的标题。</p>
<p>使用以上代码创建出来的 <code>AVPlayerLayer</code> 和他的 <code>AVPlayer</code> 将会以<code>AVPlayerItem</code>实例的第一帧呈现，类似如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AVPlayerItem.png" alt="AVPlayerItem"></p>
<p><code>AVPlayerLayer</code>有两个额外的属性:</p>
<ul>
<li><code>videoGravity</code>设置视频显示的尺寸调整行为。</li>
<li><code>isReadyForDisplay</code>检查视频是否已经可以准备播放。</li>
</ul>
<p>从另一方面来说，<code>AVPlayer</code>拥有很多额外的属性和方法。其中有一个需要<code>rate</code>属性需要注意，它表示播放速率以0~1的速率为例。0表示暂停，1表示以正常速率播放(1x)。</p>
<p>然而设置<code>rate</code>同样表示以此速率开始播放。换句话来说调用<code>pause()</code>和将<code>rate</code>设置为0所做的事一样，同理调用<code>play()</code>和设置<code>rate</code>为1也是一致的。</p>
<p>那关于快进、慢放或者是倒放操作呢？ <code>AVPlayer</code> 也能让你满意。将<code>rate</code>设置为任何大于1的数等同于要求播放器将播放速率设置为其值乘以正常速度，举个例子，将<code>rate</code>设置为2表示两倍速。</p>
<p>正如你假设的那样，将<code>rate</code>设置为负值表示将播放速率乘以正常速度倒放。</p>
<p>在以任意非正常速度播放之前会有适当的变量来验证该<code>AVPlayerItem</code>是否能够以该速度播放:</p>
<ul>
<li><code>canPlayFastForward</code>：对于任何大于1的数。</li>
<li><code>canPlaySlowForward</code>：对于任何大于0小于且不包含1的数。</li>
<li><code>canPlayReverse</code>：对于-1。</li>
<li><code>canPlaySlowReverse</code>：大于-1小于0但不包含0。</li>
<li><code>canPlayFastReverse</code>：对于任意小于-1的数。</li>
</ul>
<p>大多数视频通常可以以各种快进速度播放，但它们倒放的典型情况较少。和其他范例一样，Layer Player同样也有播放控件:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/4-180x320.png" alt="AVPlayerLayer properties"></p>
<h2 id="范例5：CAGradientLayer"><a href="#范例5：CAGradientLayer" class="headerlink" title="范例5：CAGradientLayer"></a>范例5：CAGradientLayer</h2><p><code>CAGradientLay</code>让混合两种或更多颜色变得简单，使其更加合适作为背景。为了配置它，你需要设置一个<code>CGColor</code>的数组和用以指定CAGradientLayer起始位置和结束位置的<code>startPoint</code>、<code>endPoint</code>。</p>
<p>请注意 <code>startPoint</code> 和<code>endPoint</code>并不是一个确切的点。相反它们声明于单位坐标空间上，并且它们会在图层被绘制的时候去映射图层边界。也就是说x 的值为1的时候表示该点位于图层的右边缘，y 的值为1的时候表示该点位于图层的底部边缘。</p>
<p><code>CAGradientLayer</code>有一个<code>type</code>字段，虽然<code>kCAGradientLayerAxial</code>是唯一的选项，它能线性的过渡数组中的颜色。</p>
<p>这意味着如果你在<code>startPoint</code>和<code>endPoint</code>绘制一条线(A)，渐变将沿着垂直于A的假想线（B）发生，沿B的所有点都是相同的颜色：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AxialGradientLayerType.gif" alt="AxialGradientLayerType"></p>
<p>另外，你也可以使用0~1之间的数来控制<code>locations</code>，这些值可以指定<code>colors</code>数组中使用的下一个颜色的相对相对起始位置。</p>
<p>如果忘了指定<code>locations</code>属性，则其默认是均分图层用以使用相同的间隔显示颜色。如果<code>locations</code>被设置了，则其数量必须要与<code>colors</code>数量一致，否则会发生一些预想不到的问题。</p>
<p>如下是创建渐变图层的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cgColor</span><span class="params">(red: CGFloat, green: CGFloat, blue: CGFloat)</span></span> -&gt; <span class="type">CGColor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UIColor</span>(red: red/<span class="number">255.0</span>, green: green/<span class="number">255.0</span>, blue: blue/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame = someView.bounds</span><br><span class="line">gradientLayer.colors = [cgColor(red: <span class="number">209.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">102.0</span>, blue: <span class="number">34.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">218.0</span>, blue: <span class="number">33.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">221.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">17.0</span>, green: <span class="number">51.0</span>, blue: <span class="number">204.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">34.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">102.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">68.0</span>)]</span><br><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">1</span>)</span><br><span class="line">someView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码中，你创建了一个渐变图层并将<code>someView</code>的bounds 设置给它，然后设置其<code>colors</code>数组，设置起始位置和结束位置，接着将其加到视图的图层层次结构上。以下是可能出现的结果:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAGradientLayer-250x250.png" alt="CAGradientLayer"></p>
<p>多么五彩缤纷啊！你能够编写一只蝴蝶，从应用程序中飘出来搔痒你的鼻子。 ：]</p>
<p>Layer Player提供了多个用于更改起始位置、结束位置、颜色和位置。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/5-180x320.png" alt="AVPlayerLayer controls"></p>
<h2 id="范例6：CAReplicatorLayer"><a href="#范例6：CAReplicatorLayer" class="headerlink" title="范例6：CAReplicatorLayer"></a>范例6：CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>会在指定时间内以指定次数复制某个图层，这可以让你你创建一些酷炫的效果。</p>
<p>每个图层副本都可以改变其颜色和位置，并且可以延迟创建它们用以为replicator layer创建一些动画效果。为了赋予replicator layer 3D 效果还可以给设置他们的深度(Depth)。以下是一个例子:</p>
<p>首先创建一个<code>CAReplicatorLayer</code>并将<code>someView</code>的大小位置赋值给它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> replicatorLayer = <span class="type">CAReplicatorLayer</span>()</span><br><span class="line">replicatorLayer.frame = someView.bounds</span><br></pre></td></tr></table></figure>
<p>接下来设置复制器图层(replicator layer)所拷贝的副本的数量(instanceCount)并延时绘制。同样的要将复制器图层(replicator layer)设置为2D 模式(<code>preservesDepth = false</code>)然后将实例颜色设置为白色。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicatorLayer.instanceCount = <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceDelay = <span class="type">CFTimeInterval</span>(<span class="number">1</span> / <span class="number">30.0</span>)</span><br><span class="line">replicatorLayer.preservesDepth = <span class="literal">false</span></span><br><span class="line">replicatorLayer.instanceColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>下一步将对每个连续的副本实例设置其各自的红色/绿色/蓝色的颜色偏移量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicatorLayer.instanceRedOffset = <span class="number">0.0</span></span><br><span class="line">replicatorLayer.instanceGreenOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceBlueOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceAlphaOffset = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>上述属性每个默认都是零，并且这样赋值的方式有效的在所有实例中保留了其颜色的值。然而在这个例子中，最初的实例颜色被设置为白色，这意味着红色/绿色/蓝色均已为1。因此设置绿色和蓝色的值为负值，这允许红色更加突出。类似的将alpha 偏移设置到连续拷贝副本的 alpha 属性。</p>
<p>在这之后创建一个形变(transform)来以圆形旋转每个连续的拷贝副本。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> angle = <span class="type">Float</span>(<span class="type">Double</span>.pi * <span class="number">2.0</span>) / <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceTransform = <span class="type">CATransform3DMakeRotation</span>(<span class="type">CGFloat</span>(angle), <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">someView.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure>
<p>然后为拷贝器图层(replicator layer)创建一个可使用的图层实例并将其设置上大小和边界(frame)，因此首个被创建的实例将会被绘制到横坐标的中心(center x)并且位于<code>someView</code>边界的顶部(top of <code>someView</code>‘s bounds)。同样的设置图层实例的颜色并将创建的图层实例添加到复制器图层(replicator layer)上:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instanceLayer = <span class="type">CALayer</span>()</span><br><span class="line"><span class="keyword">let</span> layerWidth: <span class="type">CGFloat</span> = <span class="number">10.0</span></span><br><span class="line"><span class="keyword">let</span> midX = someView.bounds.midX - layerWidth / <span class="number">2.0</span></span><br><span class="line">instanceLayer.frame = <span class="type">CGRect</span>(x: midX, y: <span class="number">0.0</span>, width: layerWidth, height: layerWidth * <span class="number">3.0</span>)</span><br><span class="line">instanceLayer.backgroundColor = <span class="type">UIColor</span>.white.cgColor</span><br><span class="line">replicatorLayer.addSublayer(instanceLayer)</span><br></pre></td></tr></table></figure>
<p>现在创建以不透明度从1到0的渐隐动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fadeAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"opacity"</span>)</span><br><span class="line">fadeAnimation.fromValue = <span class="number">1.0</span></span><br><span class="line">fadeAnimation.toValue = <span class="number">0.0</span></span><br><span class="line">fadeAnimation.duration = <span class="number">1</span></span><br><span class="line">fadeAnimation.repeatCount = <span class="type">Float</span>.greatestFiniteMagnitude</span><br></pre></td></tr></table></figure>
<p>并在最后设置图层实例的不透明度为0，这样能让图层实例在被绘制和设置其颜色透明度钱前保持透明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instanceLayer.opacity = <span class="number">0.0</span></span><br><span class="line">instanceLayer.add(fadeAnimation, forKey: <span class="string">"FadeAnimation"</span>)</span><br></pre></td></tr></table></figure>
<p>如下是上述代码的结果：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAReplicatorLayer.gif" alt="CAReplicatorLayer"></p>
<p>Layer Player包含了很多控件可以让你来操纵<code>CAReplicatorLayer</code>的大部分属性。</p>
<h2 id="范例7：CATiledLayer"><a href="#范例7：CATiledLayer" class="headerlink" title="范例7：CATiledLayer"></a>范例7：CATiledLayer</h2><p><code>CATiledLayer</code>对一小块图层中内容异步绘制。当你同时只能看一个很大图片或者其他内容中的一小部分(tile)时，这是非常有用的。因为你不必非要等到其内容全部加载到内存中才可以看到。</p>
<p>如下有几种方式来响应绘图。其一是重写<code>UIView</code>并使用<code>CATiledLayer</code>反复绘制小块内容(tile)直到填充满view的background，类似如下:</p>
<p>一个控制器展示一个<code>TiledBackgroundView</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">  @IBOutlet weak var tiledBackgroundView: TiledBackgroundView! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被重写的<code>TiledBackgroundView</code>视图的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class TiledBackgroundView: UIView &#123;</span><br><span class="line">  </span><br><span class="line">  let sideLength: CGFloat = 50.0</span><br><span class="line">  </span><br><span class="line">  // 1</span><br><span class="line">  override class var layerClass: AnyClass &#123;</span><br><span class="line">    return CATiledLayer.self</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    super.init(coder: aDecoder)</span><br><span class="line">    srand48(Int(Date().timeIntervalSince1970))</span><br><span class="line">    let layer = self.layer as! CATiledLayer</span><br><span class="line">    let scale = UIScreen.main.scale</span><br><span class="line">    layer.contentsScale = scale</span><br><span class="line">    layer.tileSize = CGSize(width: sideLength * scale, height: sideLength * scale)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  override func draw(_ rect: CGRect) &#123;</span><br><span class="line">    let context = UIGraphicsGetCurrentContext()</span><br><span class="line">    let red = CGFloat(drand48())</span><br><span class="line">    let green = CGFloat(drand48())</span><br><span class="line">    let blue = CGFloat(drand48())</span><br><span class="line">    context?.setFillColor(red: red, green: green, blue: blue, alpha: 1.0)</span><br><span class="line">    context?.fill(rect)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下是上述代码的作用:</p>
<ul>
<li><code>layerClass</code>被重写了，所以这视图的图层是被作为<code>CATiledLayer</code>类实例创建的。</li>
<li><code>rand48()</code>方法会在<code>draw(_:)</code>中创建出多个随机颜色。接着缩放layer(本例中是<code>CATiledLayer</code>)的内容到屏幕的缩放大小和小块内容(tile)尺寸。</li>
<li>重写<code>draw(_:)</code>方法来创建多个带随机颜色的小块内容图层(tiled layers)填充视图。</li>
</ul>
<p>最终，上述代码绘制出6*6格带有随机色的正方形小块内容(tiled)，类似如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATiledLayer-250x250.png" alt="CATiledLayer"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/MTQQ-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/MTQQ-介绍/" itemprop="url">MTQQ 介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T14:51:14+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文出处:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
<p>本文只为自己快速查看资料，原文出处如上。</p>
</blockquote>
<h2 id="2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet"><a href="#2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet" class="headerlink" title="2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet"></a>2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet</h2><h5 id="MQTT控制报文的结构"><a href="#MQTT控制报文的结构" class="headerlink" title="MQTT控制报文的结构"></a>MQTT控制报文的结构</h5><table>
<thead>
<tr>
<th>Fixed header</th>
<th>固定报头，所有控制报文都包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable header</td>
<td>可变报头，部分控制报文包含</td>
</tr>
<tr>
<td>Payload</td>
<td>有效载荷，部分控制报文包含</td>
</tr>
</tbody>
</table>
<h2 id="2-2-固定报头-Fixed-header"><a href="#2-2-固定报头-Fixed-header" class="headerlink" title="2.2 固定报头 Fixed header"></a>2.2 固定报头 Fixed header</h2><h5 id="固定报头的格式"><a href="#固定报头的格式" class="headerlink" title="固定报头的格式"></a>固定报头的格式</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT控制报文的类型</center></td><br>        <td colspan="4"><center>用于指定控制报文类型的标志位</center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type"><a href="#2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type" class="headerlink" title="2.2.1 MQTT控制报文的类型 MQTT Control Packet type"></a>2.2.1 MQTT控制报文的类型 MQTT Control Packet type</h3><h5 id="控制报文的类型"><a href="#控制报文的类型" class="headerlink" title="控制报文的类型"></a>控制报文的类型</h5><table>
<thead>
<tr>
<th><strong>名字</strong></th>
<th><strong>值</strong></th>
<th><strong>报文流动方向</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>0</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
<tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端请求连接服务端</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>服务端到客户端</td>
<td style="text-align:left">连接报文确认</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布消息</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 1消息发布收到确认</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布收到（保证交付第一步）</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布释放（保证交付第二步）</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 2消息发布完成（保证交互第三步）</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端订阅请求</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>服务端到客户端</td>
<td style="text-align:left">订阅请求报文确认</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端取消订阅请求</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>服务端到客户端</td>
<td style="text-align:left">取消订阅报文确认</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>客户端到服务端</td>
<td style="text-align:left">心跳请求</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>服务端到客户端</td>
<td style="text-align:left">心跳响应</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端断开连接</td>
</tr>
<tr>
<td>Reserved</td>
<td>15</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-标志-Flags"><a href="#2-2-2-标志-Flags" class="headerlink" title="2.2.2 标志 Flags"></a>2.2.2 标志 Flags</h3><h5 id="标志位-Flag-Bits"><a href="#标志位-Flag-Bits" class="headerlink" title="标志位 Flag Bits"></a>标志位 Flag Bits</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>固定报头标志</strong></th>
<th><strong>Bit 3</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>Bit 0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>CONNACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>Used in MQTT 3.1.1</td>
<td>DUP1</td>
<td>QoS2</td>
<td>QoS2</td>
<td>RETAIN3</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREC</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREL</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>SUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li>DUP1 =控制报文的重复分发标志</li>
<li>QoS2 = PUBLISH报文的服务质量等级</li>
<li>RETAIN3 = PUBLISH报文的保留标志</li>
</ul>
<h3 id="2-2-3-剩余长度-Remaining-Length"><a href="#2-2-3-剩余长度-Remaining-Length" class="headerlink" title="2.2.3 剩余长度 Remaining Length"></a>2.2.3 剩余长度 Remaining Length</h3><p>剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
<p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个<em>延续位（continuation bit）</em>。剩余长度字段最大4个字节。</p>
<blockquote>
<p>  <strong>非规范评注</strong></p>
<p>例如，十进制数64会被编码为一个字节，数值是64，十六进制表示为0x40,。十进制数字321(=65+2*128)被编码为两个字节，最低有效位在前。第一个字节是 65+128=193。注意最高位为1表示后面至少还有一个字节。第二个字节是2。</p>
<p><strong>非规范评注</strong></p>
<p>这允许应用发送最大256MB(268,435,455)大小的控制报文。这个数值在报文中的表示是：0xFF,0xFF,0xFF,0x7F。</p>
<p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.4_Size" target="_blank" rel="noopener">表格 2.4剩余长度字段的大小</a>展示了剩余长度字段所表示的值随字节增长。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 最大四个字节，所以理论上最大控制报文大小是2^(4*8) = 4.294967e+9 bits，并且剩余长度字段最大四个字节，若是数据到达四个字节，则低字节的最高位则应该为0,此时表示无更多字节，所以实际上是(2^(4*8) /</span> <span class="number">2</span> = <span class="number">256</span> MB)。</span><br></pre></td></tr></table></figure>
<h5 id="表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field"><a href="#表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field" class="headerlink" title="表格 2.4剩余长度字段的大小 Size of Remaining Length field"></a>表格 2.4剩余长度字段的大小 Size of Remaining Length field</h5><table>
<thead>
<tr>
<th><strong>字节数</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0 (0x00)</td>
<td>127 (0x7F)</td>
</tr>
<tr>
<td>2</td>
<td>128 (0x80, 0x01)</td>
<td>16 383 (0xFF, 0x7F)</td>
</tr>
<tr>
<td>3</td>
<td>16 384 (0x80, 0x80, 0x01)</td>
<td>2 097 151 (0xFF, 0xFF, 0x7F)</td>
</tr>
<tr>
<td>4</td>
<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>
<td>268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td>
</tr>
</tbody>
</table>
<p>分别表示（每个字节的低7位用于编码数据，最高位是标志位）：</p>
<ul>
<li>1个字节时，从0(0x00)到127(0x7f)</li>
<li>2个字节时，从128(0x80,0x01)到16383(0Xff,0x7f)</li>
<li>3个字节时，从16384(0x80,0x80,0x01)到2097151(0xFF,0xFF,0x7F)</li>
<li>4个字节时，从2097152(0x80,0x80,0x80,0x01)到268435455(0xFF,0xFF,0xFF,0x7F)</li>
</ul>
<h2 id="2-3-可变报头-Variable-header"><a href="#2-3-可变报头-Variable-header" class="headerlink" title="2.3 可变报头 Variable header"></a>2.3 可变报头 Variable header</h2><h5 id="图例-2-3-报文标识符字节-Packet-Identifier-bytes"><a href="#图例-2-3-报文标识符字节-Packet-Identifier-bytes" class="headerlink" title="图例 2.3 -报文标识符字节 Packet Identifier bytes"></a>图例 2.3 -报文标识符字节 Packet Identifier bytes</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>报文标识符 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>报文标识符 LSB</td>
</tr>
</tbody>
</table>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。</p>
<p>SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文<strong>必须</strong>包含一个非零的16位报文标识符（Packet Identifier）[MQTT-2.3.1-1]。客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符 [MQTT-2.3.1-2]。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它<strong>必须</strong>使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT-2.3.1-3]。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端 [MQTT-2.3.1-4]。</p>
<p>QoS等于0的PUBLISH报文<strong>不能</strong>包含报文标识符 [MQTT-2.3.1-5]。</p>
<p>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT-2.3.1-6]。类似地，SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT-2.3.1-7]。</p>
<h5 id="表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier"><a href="#表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier" class="headerlink" title="表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier"></a>表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>报文标识符字段</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>不需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>需要（如果QoS &gt; 0）</td>
</tr>
<tr>
<td>PUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<p>客户端和服务端彼此独立地分配报文标识符。因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端发送标识符为0x1234的PUBLISH报文，它有可能会在收到那个报文的PUBACK之前，先收到服务端发送的另一个不同的但是报文标识符也为0x1234的PUBLISH报文。</p>
<table>
<thead>
<tr>
<th>Client</th>
<th>Server</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUBLISH</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBLISH</td>
<td>Packet Identifier=0x1234</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBACK</td>
<td>Packet Identifier=0x1234</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="2-4-有效载荷-Payload"><a href="#2-4-有效载荷-Payload" class="headerlink" title="2.4 有效载荷 Payload"></a>2.4 有效载荷 Payload</h2><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷，这将在第三章论述。对于<strong>PUBLISH来说有效载荷就是应用消息</strong>。</p>
<h5 id="表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload"><a href="#表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload" class="headerlink" title="表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload"></a>表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>有效载荷</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>可选</td>
</tr>
<tr>
<td>PUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>不需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<h2 id="3-1-CONNECT-–-连接服务端"><a href="#3-1-CONNECT-–-连接服务端" class="headerlink" title="3.1 CONNECT – 连接服务端"></a>3.1 CONNECT – 连接服务端</h2><p>客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1]。</p>
<p>在一个网络连接上，客户端只能发送一次CONNECT报文。服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接 [MQTT-3.1.0-2]。有关错误处理的信息请查看4.8节。</p>
<p><strong>有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will主题，Will消息，用户名和密码</strong>。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。</p>
<h3 id="3-1-1-固定报头-Fixed-header"><a href="#3-1-1-固定报头-Fixed-header" class="headerlink" title="3.1.1 固定报头 Fixed header"></a>3.1.1 固定报头 Fixed header</h3><h5 id="图例-3-1-–CONNECT报文的固定报头"><a href="#图例-3-1-–CONNECT报文的固定报头" class="headerlink" title="图例 3.1 –CONNECT报文的固定报头"></a>图例 3.1 –CONNECT报文的固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="剩余长度字段"><a href="#剩余长度字段" class="headerlink" title="剩余长度字段"></a><strong>剩余长度字段</strong></h3><p>剩余长度等于<strong>可变报头的长度（10字节</strong>）加上有效载荷的长度。编码方式见 2.2.3节的说明。</p>
<h3 id="3-1-2-可变报头-Variable-header"><a href="#3-1-2-可变报头-Variable-header" class="headerlink" title="3.1.2 可变报头 Variable header"></a>3.1.2 可变报头 Variable header</h3><p>CONNECT报文的可变报头按下列次序包含四个字段：<strong>协议名（Protocol Name），协议级别（Protocol Level），连接标志（Connect Flags）和保持连接（Keep Alive）</strong>。</p>
<h4 id="协议名-Protocol-Name"><a href="#协议名-Protocol-Name" class="headerlink" title="协议名 Protocol Name"></a>协议名 Protocol Name</h4><h5 id="图例-3-2-协议名字节构成"><a href="#图例-3-2-协议名字节构成" class="headerlink" title="图例 3.2 -协议名字节构成"></a>图例 3.2 -协议名字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>长度 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>长度 LSB (4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘M’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘Q’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 6</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>协议名是表示协议名 <em>MQTT</em> 的UTF-8编码的字符串。MQTT规范的后续版本不会改变这个字符串的偏移和长度。</p>
<h4 id="协议级别-Protocol-Level"><a href="#协议级别-Protocol-Level" class="headerlink" title="协议级别 Protocol Level"></a>协议级别 Protocol Level</h4><h5 id="图例-3-3-Protocol-Level-byte协议级别字节构成"><a href="#图例-3-3-Protocol-Level-byte协议级别字节构成" class="headerlink" title="图例 3.3 - Protocol Level byte协议级别字节构成"></a>图例 3.3 - Protocol Level byte协议级别字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议级别</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 7</td>
<td>Level(4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="连接标志-Connect-Flags"><a href="#连接标志-Connect-Flags" class="headerlink" title="连接标志 Connect Flags"></a>连接标志 Connect Flags</h4><p>连接标志字节包含一些用于指定MQTT连接行为的参数。它还指出有效载荷中的字段是否存在。</p>
<h5 id="图例-3-4-连接标志位"><a href="#图例-3-4-连接标志位" class="headerlink" title="图例 3.4 -连接标志位"></a>图例 3.4 -连接标志位</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0304.png" alt="figure-3.4"></p>
<p>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接 [MQTT-3.1.2-3]。</p>
<h4 id="清理会话-Clean-Session"><a href="#清理会话-Clean-Session" class="headerlink" title="清理会话 Clean Session"></a>清理会话 Clean Session</h4><p><strong>位置：</strong>连接标志字节的第1位</p>
<p>这个二进制位指定了会话状态的处理方式。</p>
<p>客户端和服务端可以保存会话状态，以支持跨网络连接的可靠消息传输。这个标志位用于控制会话状态的生存时间。</p>
<p>如果清理会话（CleanSession）标志被设置为0，服务端<strong>必须</strong>基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端<strong>必须</strong>创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端<strong>必须</strong>保存会话信息 [MQTT-3.1.2-4]。当清理会话标志为0的会话连接断开之后，服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.1.2-5]。服务端也<strong>可以</strong>保存满足相同条件的QoS 0级别的消息。</p>
<p>如果清理会话（CleanSession）标志被设置为1，客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用 [MQTT-3.1.2-6]。</p>
<p>客户端的会话状态包括：</p>
<ul>
<li>已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息</li>
<li>已从服务端接收，但是还没有完成确认的QoS 2级别的消息。</li>
</ul>
<p>服务端的会话状态包括：</p>
<ul>
<li>会话是否存在，即使会话状态的其它部分都是空。</li>
<li>客户端的订阅信息。</li>
<li>已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。</li>
<li>即将传输给客户端的QoS 1和QoS 2级别的消息。</li>
<li>已从客户端接收，但是还没有完成确认的QoS 2级别的消息。</li>
<li>可选，准备发送给客户端的QoS 0级别的消息。</li>
</ul>
<p>保留消息不是服务端会话状态的一部分，会话终止时<strong>不能</strong>删除保留消息 [MQTT-3.1.2.7]。</p>
<p>有关状态存储的限制和细节见第 4.1节。</p>
<p>当清理会话标志被设置为1时，客户端和服务端的状态删除不需要是原子操作。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>为了确保在发生故障时状态的一致性，客户端应该使用会话状态标志1重复请求连接，直到连接成功。</p>
<p><strong>非规范评注</strong></p>
<p>一般来说，客户端连接时总是将清理会话标志设置为0或1，并且不交替使用两种值。这个选择取决于具体的应用。清理会话标志设置为1的客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS 1或 QoS 2级别，同时将清理会话标志设置为0。</p>
<p><strong>非规范评注</strong></p>
<p>清理会话标志0的客户端连接时，它请求服务端在连接断开后保留它的MQTT会话状态。如果打算在之后的某个时间点重连到这个服务端，客户端连接应该只使用清理会话标志0。当客户端决定之后不再使用这个会话时，应该将清理会话标志设置为1最后再连接一次，然后断开连接。</p>
</blockquote>
<h4 id="遗嘱标志-Will-Flag"><a href="#遗嘱标志-Will-Flag" class="headerlink" title="遗嘱标志 Will Flag"></a>遗嘱标志 Will Flag</h4><p><strong>位置：</strong>连接标志的第2位。</p>
<p>遗嘱标志（Will Flag）被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端<strong>必须</strong>发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 [MQTT-3.1.2-8] 。</p>
<p>遗嘱消息发布的条件，包括但不限于：</p>
<ul>
<li>服务端检测到了一个I/O错误或者网络故障。</li>
<li>客户端在保持连接（Keep Alive）的时间内未能通讯。</li>
<li>客户端没有先发送DISCONNECT报文直接关闭了网络连接。</li>
<li>由于协议错误服务端关闭了网络连接。</li>
</ul>
<p>如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-9]。</p>
<p>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文，遗嘱消息就<strong>必须</strong>从存储的会话状态中移除 [MQTT-3.1.2-10]。</p>
<p>如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0，并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-11]。</p>
<p>如果遗嘱标志被设置为0，网络连接断开时，<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.2-12]。</p>
<p>服务端应该迅速发布遗嘱消息。在关机或故障的情况下，服务端可以推迟遗嘱消息的发布直到之后的重启。如果发生了这种情况，在服务器故障和遗嘱消息被发布之间可能会有一个延迟。</p>
<h4 id="遗嘱QoS-Will-QoS"><a href="#遗嘱QoS-Will-QoS" class="headerlink" title="遗嘱QoS Will QoS"></a>遗嘱QoS Will QoS</h4><p><strong>位置：</strong>连接标志的第4和第3位。</p>
<p>这两位用于指定发布遗嘱消息时使用的服务质量等级。</p>
<p>如果遗嘱标志被设置为0，遗嘱QoS也<strong>必须</strong>设置为0(0x00) [MQTT-3.1.2-13]。</p>
<p>如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值<strong>不能</strong>等于3 [MQTT-3.1.2-14]。</p>
<h4 id="遗嘱保留-Will-Retain"><a href="#遗嘱保留-Will-Retain" class="headerlink" title="遗嘱保留 Will Retain"></a>遗嘱保留 Will Retain</h4><p><strong>位置：</strong>连接标志的第5位。</p>
<p>如果遗嘱消息被发布时需要保留，需要指定这一位的值。</p>
<p>如果遗嘱标志被设置为0，遗嘱保留（Will Retain）标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-15]。</p>
<p>如果遗嘱标志被设置为1：</p>
<ul>
<li>如果遗嘱保留被设置为0，服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布 [MQTT-3.1.2-16]。</li>
<li>如果遗嘱保留被设置为1，服务端<strong>必须</strong>将遗嘱消息当作保留消息发布 [MQTT-3.1.2-17]。</li>
</ul>
<h4 id="用户名标志-User-Name-Flag"><a href="#用户名标志-User-Name-Flag" class="headerlink" title="用户名标志 User Name Flag"></a>用户名标志 User Name Flag</h4><p><strong>位置：</strong>连接标志的第7位。</p>
<p>如果用户名（User Name）标志被设置为0，有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-18]。</p>
<p>如果用户名（User Name）标志被设置为1，有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-19]。</p>
<h4 id="密码标志-Password-Flag"><a href="#密码标志-Password-Flag" class="headerlink" title="密码标志 Password Flag"></a>密码标志 Password Flag</h4><p><strong>位置：</strong>连接标志的第6位。</p>
<p>如果密码（Password）标志被设置为0，有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-20]。</p>
<p>如果密码（Password）标志被设置为1，有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-21]。</p>
<p>如果用户名标志被设置为0，密码标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-22]。</p>
<h4 id="保持连接-Keep-Alive"><a href="#保持连接-Keep-Alive" class="headerlink" title="保持连接 Keep Alive"></a>保持连接 Keep Alive</h4><h5 id="图例-3-5保持连接字节"><a href="#图例-3-5保持连接字节" class="headerlink" title="图例 3.5保持连接字节"></a>图例 3.5保持连接字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 9</td>
<td>保持连接 Keep Alive MSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 10</td>
<td>保持连接 Keep Alive LSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端<strong>必须</strong>发送一个PINGREQ报文 [MQTT-3.1.2-23]。</p>
<p>不管保持连接的值是多少，客户端任何时候都可以发送PINGREQ报文，并且使用PINGRESP报文判断网络和服务端的活动状态。</p>
<p>如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它<strong>必须</strong>断开客户端的网络连接，认为网络连接已断开 [MQTT-3.1.2-24]。</p>
<p>客户端发送了PINGREQ报文之后，如果在合理的时间内仍没有收到PINGRESP报文，它<strong>应该</strong>关闭到服务端的网络连接。</p>
<p>保持连接的值为零表示关闭保持连接功能。这意味着，服务端不需要因为客户端不活跃而断开连接。注意：不管保持连接的值是多少，任何时候，只要服务端认为客户端是不活跃或无响应的，可以断开客户端的连接。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>保持连接的实际值是由应用指定的，一般是几分钟。允许的最大值是18小时12分15秒。</p>
</blockquote>
<h4 id="可变报头非规范示例"><a href="#可变报头非规范示例" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><h5 id="图例-3-6-可变报头非规范示例"><a href="#图例-3-6-可变报头非规范示例" class="headerlink" title="图例 3.6 -可变报头非规范示例"></a>图例 3.6 -可变报头非规范示例</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0306.png" alt="figure-3.6"></p>
<h3 id="3-1-3-有效载荷-Payload"><a href="#3-1-3-有效载荷-Payload" class="headerlink" title="3.1.3 有效载荷 Payload"></a>3.1.3 有效载荷 Payload</h3><p>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，<strong>必须</strong>按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 [MQTT-3.1.3-1]。</p>
<h4 id="客户端标识符-Client-Identifier"><a href="#客户端标识符-Client-Identifier" class="headerlink" title="客户端标识符 Client Identifier"></a>客户端标识符 Client Identifier</h4><p>服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 [MQTT-3.1.3-2]。</p>
<p>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段 [MQTT-3.1.3-3]。</p>
<p>客户端标识符<strong>必须</strong>是1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-4]。</p>
<p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字）[MQTT-3.1.3-5]。</p>
<p>服务端<strong>可以</strong>允许编码后超过23个字节的客户端标识符 (ClientId)。服务端<strong>可以</strong>允许包含不是上面列表字符的客户端标识符 (ClientId)。</p>
<p>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文 [MQTT-3.1.3-6]。</p>
<p>如果客户端提供了一个零字节的客户端标识符，它<strong>必须</strong>同时将清理会话标志设置为1 [MQTT-3.1.3-7]。</p>
<p>如果客户端提供的ClientId为零字节且清理会话标志为0，服务端<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-8]。</p>
<p>如果服务端拒绝了这个ClientId，它<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-9]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端实现可以提供一个方便的方法用于生成随机的ClientId。当清理会话标志被设置为0时应该主动放弃使用这种方法。</p>
</blockquote>
<h4 id="遗嘱主题-Will-Topic"><a href="#遗嘱主题-Will-Topic" class="headerlink" title="遗嘱主题 Will Topic"></a>遗嘱主题 Will Topic</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱主题（Will Topic）。遗嘱主题<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-10]。</p>
<h4 id="遗嘱消息-Will-Message"><a href="#遗嘱消息-Will-Message" class="headerlink" title="遗嘱消息 Will Message"></a>遗嘱消息 Will Message</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱消息。遗嘱消息定义了将被发布到遗嘱主题的应用消息，见3.1.2.5节的描述。这个字段由一个两字节的长度和遗嘱消息的有效载荷组成，表示为零字节或多个字节序列。长度给出了跟在后面的数据的字节数，不包含长度字段本身占用的两个字节。</p>
<p>遗嘱消息被发布到遗嘱主题时，它的有效载荷只包含这个字段的数据部分，不包含开头的两个长度字节。</p>
<h4 id="用户名-User-Name"><a href="#用户名-User-Name" class="headerlink" title="用户名 User Name"></a>用户名 User Name</h4><p>如果用户名（User Name）标志被设置为1，有效载荷的下一个字段就是它。用户名<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-11]。服务端可以将它用于身份验证和授权。</p>
<h4 id="密码-Password"><a href="#密码-Password" class="headerlink" title="密码 Password"></a>密码 Password</h4><p>如果密码（Password）标志被设置为1，有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段，长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节），后面跟着0到65535字节的二进制数据。</p>
<h5 id="图例-3-7-密码字节"><a href="#图例-3-7-密码字节" class="headerlink" title="图例 3.7 - 密码字节"></a>图例 3.7 - 密码字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>数据长度 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>数据长度 LSB</td>
</tr>
<tr>
<td>byte 3 ….</td>
<td>如果长度大于0，这里就是数据部分</td>
</tr>
</tbody>
</table>
<h3 id="3-1-4-响应-Response"><a href="#3-1-4-响应-Response" class="headerlink" title="3.1.4 响应 Response"></a>3.1.4 响应 Response</h3><p>注意：服务器可以在同一个TCP端口或其他网络端点上支持多种协议（包括本协议的早期版本）。如果服务器确定协议是MQTT 3.1.1，那么它按照下面的方法验证连接请求。</p>
<ol>
<li>网络连接建立后，如果服务端在合理的时间内没有收到CONNECT报文，服务端<strong>应该</strong>关闭这个连接。</li>
<li>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接 [MQTT-3.1.4-1]。</li>
<li>服务端<strong>可以</strong>检查CONNECT报文的内容是不是满足任何进一步的限制，<strong>可以</strong>执行身份验证和授权检查。如果任何一项检查没通过，按照3.2节的描述，它<strong>应该</strong>发送一个适当的、返回码非零的CONNACK响应，并且<strong>必须</strong>关闭这个网络连接。</li>
</ol>
<p>如果验证成功，服务端会执行下列步骤。</p>
<ol>
<li>如果ClientId表明客户端已经连接到这个服务端，那么服务端<strong>必须</strong>断开原有的客户端连接 [MQTT-3.1.4-2]。</li>
<li>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程 [MQTT-3.1.4-3]。</li>
<li>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT-3.1.4-4]。</li>
<li>开始消息分发和保持连接状态监视。</li>
</ol>
<p>允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文。如果服务端拒绝了CONNECT，它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据 [MQTT-3.1.4-5]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端通常会等待一个CONNACK报文。然而客户端有权在收到CONNACK之前发送控制报文，由于不需要维持连接状态，这可以简化客户端的实现。</p>
</blockquote>
<h2 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h2><p>服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK [MQTT-3.2.0-1]。</p>
<p>如果客户端在合理的时间内没有收到服务端的CONNACK报文，客户端<strong>应该</strong>关闭网络连接。<em>合理</em> 的时间取决于应用的类型和通信基础设施。</p>
<h3 id="3-2-1-固定报头"><a href="#3-2-1-固定报头" class="headerlink" title="3.2.1 固定报头"></a>3.2.1 固定报头</h3><p>固定报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_Figure_3.8_%E2%80%93" target="_blank" rel="noopener">图例 3.8 – CONNACK 报文固定报头</a> 的描述。</p>
<h5 id="图例-3-8-–-CONNACK-报文固定报头"><a href="#图例-3-8-–-CONNACK-报文固定报头" class="headerlink" title="图例 3.8 – CONNACK 报文固定报头"></a>图例 3.8 – CONNACK 报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<p><strong>剩余长度字段</strong>表示可变报头的长度。对于CONNACK报文这个值等于2。</p>
<h3 id="3-2-2-可变报头"><a href="#3-2-2-可变报头" class="headerlink" title="3.2.2 可变报头"></a>3.2.2 可变报头</h3><p>可变报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E5%9B%BE%E4%BE%8B_3.9_%E2%80%93CONNACK%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4" target="_blank" rel="noopener">图例 3.9 –CONNACK报文可变报头</a> 的描述。</p>
<h5 id="图例-3-9-–CONNACK报文可变报头"><a href="#图例-3-9-–CONNACK报文可变报头" class="headerlink" title="图例 3.9 –CONNACK报文可变报头"></a>图例 3.9 –CONNACK报文可变报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>连接确认标志</center></td><br>        <td colspan="7"><center>Reserved 保留位</center></td><br>        <td colspan="1"><center>SP1</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>     <tr><br>        <td colspan="9"><center>连接返回码</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br></table>

<h4 id="连接确认标志-Connect-Acknowledge-Flags"><a href="#连接确认标志-Connect-Acknowledge-Flags" class="headerlink" title="连接确认标志 Connect Acknowledge Flags"></a>连接确认标志 Connect Acknowledge Flags</h4><p>第1个字节是 <em>连接确认标志</em>，位7-1是保留位且<strong>必须</strong>设置为0。 第0 (SP)位 是当前会话（Session Present）标志。</p>
<h4 id="当前会话-Session-Present"><a href="#当前会话-Session-Present" class="headerlink" title="当前会话 Session Present"></a>当前会话 Session Present</h4><p><strong>位置：</strong>连接确认标志的第0位。</p>
<p>如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还<strong>必须</strong>将CONNACK报文中的当前会话设置（Session Present）标志为0 [MQTT-3.2.2-1]。</p>
<p>如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1 [MQTT-3.2.2-2]。如果服务端没有已保存的会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0 [MQTT-3.2.2-3]。</p>
<p>当前会话标志使服务端和客户端在是否有已存储的会话状态上保持一致。</p>
<p>一旦完成了会话的初始化设置，已经保存会话状态的客户端将期望服务端维持它存储的会话状态。如果客户端从服务端收到的当前的值与预期的不同，客户端可以选择继续这个会话或者断开连接。客户端可以丢弃客户端和服务端之间的会话状态，方法是，断开连接，将清理会话标志设置为1，再次连接，然后再次断开连接。</p>
<p>如果服务端发送了一个包含非零返回码的CONNACK报文，它<strong>必须</strong>将当前会话标志设置为0 [MQTT-3.2.2-4]。</p>
<h4 id="连接返回码-Connect-Return-code"><a href="#连接返回码-Connect-Return-code" class="headerlink" title="连接返回码 Connect Return code"></a>连接返回码 Connect Return code</h4><p><strong>位置：</strong>可变报头的第2个字节。</p>
<p>连接返回码字段使用一个字节的无符号值，在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E8%A1%A8%E6%A0%BC_3.1_%E2%80%93%E8%BF%9E%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%A0%81%E7%9A%84%E5%80%BC" target="_blank" rel="noopener">表格 3.1 –连接返回码的值</a> 中列出。如果服务端收到一个合法的CONNECT报文，但出于某些原因无法处理它，服务端应该尝试发送一个包含非零返回码（表格中的某一个）的CONNACK报文。如果服务端发送了一个包含非零返回码的CONNACK报文，那么它<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-5].。</p>
<h5 id="表格-3-1-–连接返回码的值"><a href="#表格-3-1-–连接返回码的值" class="headerlink" title="表格 3.1 –连接返回码的值"></a>表格 3.1 –连接返回码的值</h5><table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>返回码响应</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x00连接已接受</td>
<td>连接已被服务端接受</td>
</tr>
<tr>
<td>1</td>
<td>0x01连接已拒绝，不支持的协议版本</td>
<td>服务端不支持客户端请求的MQTT协议级别</td>
</tr>
<tr>
<td>2</td>
<td>0x02连接已拒绝，不合格的客户端标识符</td>
<td>客户端标识符是正确的UTF-8编码，但服务端不允许使用</td>
</tr>
<tr>
<td>3</td>
<td>0x03连接已拒绝，服务端不可用</td>
<td>网络连接已建立，但MQTT服务不可用</td>
</tr>
<tr>
<td>4</td>
<td>0x04连接已拒绝，无效的用户名或密码</td>
<td>用户名或密码的数据格式无效</td>
</tr>
<tr>
<td>5</td>
<td>0x05连接已拒绝，未授权</td>
<td>客户端未被授权连接到此服务器</td>
</tr>
<tr>
<td>6-255</td>
<td></td>
<td>保留</td>
</tr>
</tbody>
</table>
<p>如果认为上表中的所有连接返回码都不太合适，那么服务端<strong>必须</strong>关闭网络连接，不需要发送CONNACK报文 [MQTT-3.2.2-6]。</p>
<h3 id="3-2-3-有效载荷"><a href="#3-2-3-有效载荷" class="headerlink" title="3.2.3 有效载荷"></a>3.2.3 有效载荷</h3><p>CONNACK报文没有有效载荷。</p>
<h2 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h2><p>PUBLISH控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。</p>
<h3 id="3-3-1-固定报头"><a href="#3-3-1-固定报头" class="headerlink" title="3.3.1 固定报头"></a>3.3.1 固定报头</h3><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E5%9B%BE%E4%BE%8B_3.10_%E2%80%93" target="_blank" rel="noopener">图例 3.10 – PUBLISH报文固定报头</a>描述了固定报头的格式</p>
<h5 id="图例-3-10-–-PUBLISH报文固定报头"><a href="#图例-3-10-–-PUBLISH报文固定报头" class="headerlink" title="图例 3.10 – PUBLISH报文固定报头"></a>图例 3.10 – PUBLISH报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>    <tr><br>        <td><center><strong>byte 1</strong></center></td><br>        <td colspan="4"><center>MQTT控制报文类型 (3)</center></td><br>        <td><center><strong>DUP</strong></center></td><br>        <td><center><strong>QoS-H</strong></center></td><br>        <td><center><strong>QoS-</strong></center></td><br>        <td><center><strong>RETAIN</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h4 id="重发标志-DUP"><a href="#重发标志-DUP" class="headerlink" title="重发标志 DUP"></a>重发标志 DUP</h4><p><strong>位置：</strong>第1个字节，第3位</p>
<p>如果DUP标志被设置为0，表示这是客户端或服务端第一次请求发送这个PUBLISH报文。如果DUP标志被设置为1，表示这可能是一个早前报文请求的重发。</p>
<p>客户端或服务端请求重发一个PUBLISH报文时，<strong>必须</strong>将DUP标志设置为1 [MQTT-3.3.1.-1].。对于QoS 0的消息，DUP标志<strong>必须</strong>设置为0 [MQTT-3.3.1-2]。</p>
<p>服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值<strong>必须</strong>单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定 [MQTT-3.3.1-3]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>接收者收到一个DUP标志为1的控制报文时，不能假设它看到了一个这个报文之前的一个副本。</p>
<p><strong>非规范评注</strong></p>
<p>需要特别指出的是，DUP标志关注的是控制报文本身，与它包含的应用消息无关。当使用QoS 1时，客户端可能会收到一个DUP标志为0的PUBLISH报文，这个报文包含一个它之前收到过的应用消息的副本，但是用的是不同的报文标识符。 2.3.1节提供了有关报文标识符的更多信息。</p>
</blockquote>
<h4 id="服务质量等级-QoS"><a href="#服务质量等级-QoS" class="headerlink" title="服务质量等级 QoS"></a>服务质量等级 QoS</h4><p><strong>位置：</strong>第1个字节，第2-1位。</p>
<p>这个字段表示应用消息分发的服务质量等级保证。服务质量等级在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.2_-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">表格 3.2 -服务质量定义</a> 中列出。</p>
<h5 id="表格-3-2-服务质量定义"><a href="#表格-3-2-服务质量定义" class="headerlink" title="表格 3.2 -服务质量定义"></a>表格 3.2 -服务质量定义</h5><table>
<thead>
<tr>
<th><strong>QoS值</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>最多分发一次</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>至少分发一次</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>只分发一次</td>
</tr>
<tr>
<td>-</td>
<td>1</td>
<td>1</td>
<td>保留位</td>
</tr>
</tbody>
</table>
<p>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它<strong>必须</strong>关闭网络连接 [MQTT-3.3.1-4]。</p>
<h4 id="保留标志-RETAIN"><a href="#保留标志-RETAIN" class="headerlink" title="保留标志 RETAIN"></a>保留标志 RETAIN</h4><p><strong>位置：</strong>第1个字节，第0位。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它<strong>必须</strong>被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它<strong>必须</strong>丢弃之前为那个主题保留的任何消息。它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 [MQTT-3.3.1-7]。有关存储状态的更多信息见 4.1节。</p>
<p>服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它<strong>必须</strong>将报文的保留标志设为1 [MQTT-3.3.1-8]。当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端<strong>必须</strong>将保留标志设为0，不管它收到的这个消息中保留标志的值是多少 [MQTT-3.3.1-9]。</p>
<p>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT-3.3.1-10]。<em>当作正常</em> 意思是现存的客户端收到的消息中保留标志未被设置。服务端<strong>不能</strong>存储零字节的保留消息 [MQTT-3.3.1-11]。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息 [MQTT-3.3.1-12]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>对于发布者不定期发送状态消息这个场景，保留消息很有用。新的订阅者将会收到最近的状态。</p>
</blockquote>
<p><strong>剩余长度字段</strong></p>
<p>等于可变报头的长度加上有效载荷的长度。</p>
<h3 id="3-3-2-可变报头"><a href="#3-3-2-可变报头" class="headerlink" title="3.3.2 可变报头"></a>3.3.2 可变报头</h3><p>可变报头按顺序包含主题名和报文标识符。</p>
<h4 id="主题名-Topic-Name"><a href="#主题名-Topic-Name" class="headerlink" title="主题名 Topic Name"></a>主题名 Topic Name</h4><p>主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。</p>
<p>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段。它<strong>必须</strong>是 1.5.3节定义的UTF-8编码的字符串 [MQTT-3.3.2-1]。</p>
<p>PUBLISH报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2]。</p>
<p>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器（根据 4.7节定义的匹配过程）[MQTT-3.3.2-3]。</p>
<h4 id="报文标识符-Packet-Identifier"><a href="#报文标识符-Packet-Identifier" class="headerlink" title="报文标识符 Packet Identifier"></a>报文标识符 Packet Identifier</h4><p>只有当QoS等级是1或2时，报文标识符（Packet Identifier）字段才能出现在PUBLISH报文中。2.3.1节提供了有关报文标识符的更多信息。</p>
<h4 id="可变报头非规范示例-1"><a href="#可变报头非规范示例-1" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_Figure_3.11_-" target="_blank" rel="noopener">图例 3.11 – PUBLISH报文可变报头非规范示例</a> 举例说明了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.3_-" target="_blank" rel="noopener">表格 3.3 - PUBLISH报文非规范示例</a> 中简要描述的PUBLISH报文的可变报头。</p>
<h5 id="表格-3-3-PUBLISH报文非规范示例"><a href="#表格-3-3-PUBLISH报文非规范示例" class="headerlink" title="表格 3.3 - PUBLISH报文非规范示例"></a>表格 3.3 - PUBLISH报文非规范示例</h5><table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>主题名</td>
<td>a/b</td>
</tr>
<tr>
<td>报文标识符</td>
<td>10</td>
</tr>
</tbody>
</table>
<h5 id="图例-3-11-–-PUBLISH报文可变报头非规范示例"><a href="#图例-3-11-–-PUBLISH报文可变报头非规范示例" class="headerlink" title="图例 3.11 – PUBLISH报文可变报头非规范示例"></a>图例 3.11 – PUBLISH报文可变报头非规范示例</h5><table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Topic Name 主题名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>Length MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>Length LSB (3)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘a’ (0x61)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘/’ (0x2F)</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘b’ (0x62)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>报文标识符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 6</td>
<td>报文标识符 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 7</td>
<td>报文标识符 LSB (10)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>示例中的主题名为 “a/b”，长度等于3，报文标识符为 “10”</p>
<h3 id="3-3-3-有效载荷"><a href="#3-3-3-有效载荷" class="headerlink" title="3.3.3 有效载荷"></a>3.3.3 有效载荷</h3><p>有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的。</p>
<h3 id="3-3-4-响应"><a href="#3-3-4-响应" class="headerlink" title="3.3.4 响应"></a>3.3.4 响应</h3><p>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应，见下面表格的描述 [MQTT-3.3.4-1]。</p>
<h5 id="表格-3-4-–-PUBLISH报文的预期响应"><a href="#表格-3-4-–-PUBLISH报文的预期响应" class="headerlink" title="表格 3.4 – PUBLISH报文的预期响应"></a>表格 3.4 – PUBLISH报文的预期响应</h5><table>
<thead>
<tr>
<th><strong>服务质量等级</strong></th>
<th><strong>预期响应</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QoS 0</td>
<td>无响应</td>
</tr>
<tr>
<td>QoS 1</td>
<td>PUBACK报文</td>
</tr>
<tr>
<td>QoS 2</td>
<td>PUBREC报文</td>
</tr>
</tbody>
</table>
<h3 id="3-3-5-动作-Actions"><a href="#3-3-5-动作-Actions" class="headerlink" title="3.3.5 动作 Actions"></a>3.3.5 动作 Actions</h3><p>客户端使用PUBLISH报文发送应用消息给服务端，目的是分发到其它订阅匹配的客户端。</p>
<p>服务端使用PUBLISH报文发送应用消息给每一个订阅匹配的客户端。</p>
<p>客户端使用带通配符的主题过滤器请求订阅时，客户端的订阅可能会重复，因此发布的消息可能会匹配多个过滤器。对于这种情况，服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端 [MQTT-3.3.5-1]。服务端之后可以按照订阅的QoS等级，分发消息的副本给每一个匹配的订阅者。</p>
<p>收到一个PUBLISH报文时，接收者的动作取决于4.3节描述的QoS等级。</p>
<p>如果服务端实现不授权某个客户端发布PUBLISH报文，它没有办法通知那个客户端。它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认，或者关闭网络连接 [MQTT-3.3.5-2]。</p>
<blockquote>
<p>MQTT 原文文献:<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p>
<p>MQTT 中文版:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/UIView和-CALayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/UIView和-CALayer/" itemprop="url">UIView和 CALayer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T11:21:19+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>作为普通开发者而言，写 UI 和控件时，我们并不经常直接接触到<code>CALayer</code>，但是<code>CALayer</code>却是写页面最常用的类之一(每个 UIView 至少有一个 CALayer)。但是什么是 CALayer 呢？</p>
<blockquote>
<p>参考资料：</p>
<p>CALayer Tutorial for iOS: Getting Started：<a href="https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started" target="_blank" rel="noopener">https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Objective-C-代码转换为-C-代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Wong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John 的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Objective-C-代码转换为-C-代码/" itemprop="url"> Objective-C 代码转换为 C++代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T11:22:30+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在研究 iOS 系统方法实现的时候，由于有时苹果未将改方法的实现开源，所以此时我们就需要将指定你文件转换为C++文件，这样就可以看到部分底层实现。</p>
<p>当你在谷歌搜索如何创建C++文件文件的时候，你得到的答案可能是这样:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>这样</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc AppDelegate.m -o AppDelegate.cpp</span><br></pre></td></tr></table></figure>
<p>或者是这样</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk ViewController.m</span><br></pre></td></tr></table></figure>
<p>这时候你可能欣喜，竟然有那么多种方案可以实现，但是在键入这些代码之后你可能会发现令你更加欣(fa)喜(kuang)的一面,这结果可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error1.png" alt="UIKit/UIKit.h not found"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error2.png" alt="not support weak references"></p>
<p>或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error3.png" alt="assigning retained object to weak variable"></p>
<p>这时候你看到那么多友善(mmp)的提示你的心情可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile1.jpg" alt="faker smile one"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile2.jpg" alt="faker smile two"></p>
<p>亦或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile3.jpg" alt="faker smile three"></p>
<p>如果你真的遇到这些问题，请冷静一下，我们先来解决这个技术难题</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/dontDoThis1.jpg" alt="大哥别这样"></p>
<p>首先我们分析一下第一个命令产生的问题—— <code>fatal error: &#39;UIKit/UIKit.h&#39; file not found</code></p>
<p>这个问题产生的原因是因为 clang 将.m文件转换为 C++文件的时候，clang 找不到这个头文件，这时候我们只需要指定一下其平台即可 </p>
<ul>
<li>指定真机 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<ul>
<li>指定模拟器 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>但是指定真机之后还可能会产生问题，例如代码中有 weak，这时候 clang 转换又双叒叕不通过了，这时只需要支持 ARC 指定运行时版本即可 </p>
<ul>
<li>支持 ARC 指定运行时版本，例如在-rewrite-objc 后面添加如下代码 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时候两个最常见的问题已经解决了，接下来解决第三个问题。 </p>
<p>第三个问题困扰了我好久，最后发现只要不直接使用 alloc init 或者 new 之类的初始化方法给被 weak 修饰的指针赋值即可。 </p>
<ul>
<li>最终命令 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<p>创建 C++文件总流程: </p>
<ol>
<li>打开终端，使用命令先进入指定路径(需要转换文件所在的路径) </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ChromeBook:</span>oc中的 weak sq$ cd /Users/sq/Desktop/Project/OCTest/oc中的\ weak/oc中的\ weak</span><br></pre></td></tr></table></figure>
<ol>
<li>输入上述最终命令，将最终命令中的Appdelegate.m改为你的目标文件 </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料： </p>
<p>OC代码转C++代码的生成:<a href="https://www.jianshu.com/p/3a896cba744a" target="_blank" rel="noopener">https://www.jianshu.com/p/3a896cba744a</a> </p>
<p>Objective-C编译成C++代码报错:<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">https://www.jianshu.com/p/43a09727eb2c</a> </p>
<p>使用clang将OC代码转为C++（亲测有效）:<a href="https://blog.csdn.net/qq_34003239/article/details/84230019" target="_blank" rel="noopener">https://blog.csdn.net/qq_34003239/article/details/84230019</a> </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Wong</p>
              <p class="site-description motion-element" itemprop="description">别在机会来临之时却无法握住。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Wong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
