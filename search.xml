<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LLDB动态调试</title>
    <url>/2021/12/02/LLDB%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>资料：</p>
<ol>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42" target="_blank" rel="noopener">LLDB 调试指南</a></li>
<li><a href="https://lldb.llvm.org/" target="_blank" rel="noopener">LLDB 文档</a></li>
</ol>
</blockquote>
<p>Xcode编译器和调试器的演变过程：</p>
<ul>
<li>编译器：GCC-&gt;LLVM</li>
<li>调试器：GDB-&gt;LLDB</li>
</ul>
<p><a href="https://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a> 和 <a href="https://iphonedev.wiki/index.php/debugserver" target="_blank" rel="noopener">debugserver</a></p>
<p>LLDB 是 Xcode 自带的调试器，是 <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a> 的调试器组件。它可以在本地调试 Mac 应用程序，也可以远程调试 iPhone 应用程序。debugserver是一个控制台应用程序，当第一次使用 Xcode 调试iPhone/iPad 设备时，会被安装到设备中，目录：<code>/Developer/usr/bin</code>。但是，默认情况下，由于权限不足， debugserver 只能调试通过 Xcode 安装的应用。</p>
<a id="more"></a>
<h2 id="远程调试指定-App"><a href="#远程调试指定-App" class="headerlink" title="远程调试指定 App"></a>远程调试指定 App</h2><h3 id="给-debugserver-添加权限"><a href="#给-debugserver-添加权限" class="headerlink" title="给 debugserver 添加权限"></a>给 debugserver 添加权限</h3><ol>
<li><p>由于<code>/Developer/usr/bin</code>下 debugserver 无法进行权限签名，所以使用mac 中的debugserver进行签名，从地址<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/12.0/DeveloperDiskImage.dmg/usr/bin</code>拷贝到桌面。然后一次执行如下命令，对 debugserver 进行签名：</p>
<ul>
<li><p>导出原权限文件：<code>ldid -e debugserver &gt; debuger.entitlements</code>。</p>
</li>
<li><p>打开导出的 <code>debuger.entitlements</code> 文件并添加如下两个键：<code>get-task-allow</code>和<code>task_for_pid_allow</code>，将其值均设为 true。</p>
</li>
<li><p>用已经添加完成权限的<code>debuger.entitlements</code>文件签名<code>debugserver</code>(任选其一)：</p>
<ul>
<li><code>codesign -s - --entitlements debuger.entitlements -f debugserver</code></li>
<li><code>ldid -Sdebuger.entitlements debugserver</code></li>
</ul>
</li>
</ul>
</li>
<li><p>将已经赋予权限的 debugserver 拷贝到手机的<code>/usr/bin</code>目录下</p>
</li>
<li><p>赋予 debugserver 执行权限(在 iPhone 上执行命令)：<code>chmod /usr/bin/debugserver</code></p>
</li>
</ol>
<h3 id="启动-debugserver"><a href="#启动-debugserver" class="headerlink" title="启动 debugserver"></a>启动 debugserver</h3><p>在 iPhone 终端中输入如下命令启动进程并附加到指定程序：</p>
<p>命令：<code>debugserver 127.0.0.1:指定端口 -a 指定程序</code></p>
<p>例如：<code>debugserver 127.0.0.1:11100 -a Snapchat</code></p>
<p>此时 debugserver 服务会在 iPhone 的11100端口开启这个服务，并附加到 Snapchat 上。</p>
<h3 id="lldb-连接-debugserver"><a href="#lldb-连接-debugserver" class="headerlink" title="lldb 连接 debugserver"></a>lldb 连接 debugserver</h3><p>在 mac 的终端里输入<code>lldb</code>，随后在 <code>lldb</code> 中输入如下命令来与 iPhone 设备上的 debugserver 进行通信：</p>
<p>命令：<code>process connect connect://iPhone设备IP:端口号</code></p>
<p>例如：<code>process connect connect://localhost:11100</code>。</p>
<p>自此已完成 lldb 与 debugserver 连接。</p>
<p>ps.如果在 lldb 连接 debugserver 时出现<code>debugserver rejecting incoming connection</code>问题，可以尝试在启动 debugserver 时使用此命令<code>debugserver *:11100 -a Snapchat</code>。</p>
<h2 id="LLDB-调试命令"><a href="#LLDB-调试命令" class="headerlink" title="LLDB 调试命令"></a>LLDB 调试命令</h2><blockquote>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42" target="_blank" rel="noopener">LLDB 调试指南</a></p>
</blockquote>
<p>命令格式：<code>&lt;command&gt; [&lt;subcommand&gt;...] [--&lt;option&gt; [&lt;option-value&gt;]]... [argument]...</code>。</p>
<p>注意事项：由于lldb 命令解释器对命令名称进行最短的唯一字符串匹配，因此以下两个命令将执行相同的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint set -n &quot;-[SKTGraphicView alignLeftEdges:]&quot;</span><br><span class="line">(lldb) br s -n &quot;-[SKTGraphicView alignLeftEdges:]&quot;</span><br></pre></td></tr></table></figure>
<p>常用命令：</p>
<ul>
<li><code>breakpoint &lt;subcommand&gt; [&lt;command-options&gt;]</code>：显示命令的子命令帮助,例如<code>help breakpoint、help breakpoint set</code>。</li>
<li><code>breakpoint</code>命令：<ul>
<li>格式：<code>return [-x] -- [&lt;expr&gt;]</code>或<code>return [&lt;expr&gt;]</code>。</li>
<li>功能：对断点进行操作。</li>
<li>例子：<code>breakpoint set -n test</code>，通过方法名对方法添加断点。</li>
<li>子命令：<ul>
<li><code>name</code>:对断点名字进行操作。</li>
<li><code>list</code>：以可配置的详细程度列出部分或全部断点。</li>
<li><code>delete [&lt;breakpt-id | breakpt-id-list&gt;]</code> ：删除指定的断点。 如果没有指定断点，则全部删除。</li>
<li><code>disable [&lt;breakpt-id | breakpt-id-list&gt;]</code>：禁用指定的断点而不删除它们。 如果没有指定，则禁用所有断点。</li>
<li><code>enable [&lt;breakpt-id | breakpt-id-list&gt;]</code>：启用指定的禁用断点。如果没有指定断点，则启用所有的断点。</li>
<li><code>set</code>：在可执行文件中设置一个或一组断点。<ul>
<li>命令选项：<ul>
<li><code>-n &lt;function-name&gt;</code>：通过方法名对方法添加断点，一个断点可以对应多个方法名，例如：<code>breakpoint set -n testA</code>。</li>
<li><code>-n &lt;classname function-name&gt;</code>：对指定类的方法添加断点，例如：<code>breakpoint set -n &quot;-[ViewController testA]&quot;</code>;</li>
<li><code>-r &lt;regular-expression&gt;</code>：通过正则表达式查找方法，并对结果方法设置断点。</li>
<li><code>-s &lt;shlib-name&gt;</code>：指定动态库里的方法设置断点，例如：<code>breakpoint set -s libdyld.dylib -r load</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>command &lt;sub-command&gt; [&lt;sub-command-options&gt;] &lt;breakpoint-id&gt;</code>：用于添加、删除和列出在断点时执行的LLDB命令。<ul>
<li>子命令：<ul>
<li><code>add &lt;breakpoint-id&gt;</code>：添加在断点触发时自动执行的指令，例如：<code>breakpoint command add 1</code>，在随后出现的&gt;内出入指令，并且以 DONE 结束指令。</li>
<li><code>list &lt;breakpoint-id&gt;</code>：查看在断点触发时执行的指令，例如：<code>breakpoint command list 1</code>。</li>
<li><code>delete &lt;breakpoint-id&gt;</code>：删除在断点触发时执行的指令，例如：<code>breakpoint command delete 1</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>watchpoint</code>命令：<ul>
<li>格式：<code>watchpoint &lt;subcommand&gt; [&lt;command-options&gt;]</code>。</li>
<li>功能：与<code>breakpoint</code>类似，<code>breakpoint</code>是为方法添加断点，而<code>watchpoint</code>则是为内存空间添加断点。</li>
<li>例子：<code>watchpoint set variable touches</code>，对储存变量 touches 的内存空间添加断点。</li>
<li>子命令：<ul>
<li><code>command/delete/disable/enable/list</code>：同<code>breakpoint</code>。</li>
<li><code>set &lt;subcommand&gt; [&lt;subcommand-options&gt;]</code>：。<ul>
<li>命令选项：<ul>
<li><code>expression</code>：直接观察某个内存地址，例如：<code>watchpoint set expression 0x00007fe0dbfd3433</code>。</li>
<li><code>variable</code>：观察存储变量的内存地址，例如：<code>watchpoint set variable touches</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>expression</code>命令:<ul>
<li>格式：<code>expression &lt;cmd-options&gt; -- &lt;expr&gt;</code>。</li>
<li>功能：执行表达式，其中<code>--</code>表示<code>&lt;cmd-options&gt;</code>截止。</li>
<li>例子：<code>expression self.view.alpha = 0.5、expr -f bin -- (index * 8) + 5</code>。</li>
<li>命令选项：<ul>
<li><code>-O</code>:打印 description 方法。</li>
</ul>
</li>
<li>简写命令：<ul>
<li><code>call</code>、<code>p</code>、<code>print</code>：调用函数，是<code>expression --</code>的缩写，例如：<code>call/print/p [self  view]</code>。</li>
<li><code>po</code>：是<code>expression -O  --</code>的缩写，打印 description 方法。</li>
</ul>
</li>
</ul>
</li>
<li><code>thread</code>命令<ul>
<li>格式：<code>thread &lt;subcommand&gt; [&lt;subcommand-options&gt;]</code>。</li>
<li>功能：打印方法调用栈。</li>
<li>命令选项：<ul>
<li><code>backtrace</code>：展示当前方法调用栈。<ul>
<li>简写：<code>bt</code>。</li>
</ul>
</li>
<li><code>return</code>：可以提早从栈帧(方法)中返回，可以在 <code>return</code> 之后添加函数返回值，例如在<code>-(int)number;</code>方法中的断点可以使用如下命令提早结束方法调用并返回指定值<code>thread return 33</code>。</li>
<li><code>continue</code>:继续执行当前目标进程。 可以指定一个或多个线程，默认情况下是所有线程继续执行。<ul>
<li>简写：<code>c、continue</code>。</li>
</ul>
</li>
<li><code>step-in</code>：源级单步，步入调用(进入子方法)。 除非指定，否则默认为当前线程。<ul>
<li>简写：<code>step、s</code>。</li>
</ul>
</li>
<li><code>step-inst</code>：指令级单步，步入调用。 除非指定，否则默认为当前线程。<ul>
<li>简写：<code>si</code>。</li>
</ul>
</li>
<li><code>step-out</code>：完成对当前堆栈帧的执行，返回后停止。 除非指定，否则默认为当前线程。<ul>
<li>简写：<code>finish</code>。</li>
</ul>
</li>
<li><code>step-inst-over</code>：指令级单步，跨步调用。 除非指定，否则默认为当前线程。<ul>
<li>简写：<code>ni</code>。</li>
</ul>
</li>
<li><code>step-over</code>：源码级单步，跨步调用。 除非指定，否则默认为当前线程。<ul>
<li>简写：<code>next、n</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>frame</code>命令：<ul>
<li>格式：<code>frame &lt;subcommand&gt; [&lt;subcommand-options&gt;]</code>。</li>
<li>功能：用于选择和检查当前线程的栈帧。</li>
<li>命令选项：<ul>
<li><code>info</code>：列出当前线程中关于当前堆栈框架的信息。</li>
<li><code>variable</code>：显示当前堆栈帧的变量。默认为范围内的所有参数和局部变量。可以指定参数、局部、文件静态和文件全局变量的名称。例如：<code>frame variable -O a</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>target modules</code>命令：<ul>
<li>格式：<code>target modules &lt;sub-command&gt;</code>。</li>
<li>简写：<code>image &lt;sub-command&gt;</code>。</li>
<li>功能：用于访问一个或多个目标模块信息的命令。。</li>
<li>子命令：<ul>
<li><code>list -o -f</code>：列出当前可执行的和依赖的共享库的偏移及其路径。</li>
<li><code>modules &lt;sub-command&gt;</code>：在可执行文件和依赖库中查找信息。<ul>
<li>子选项：<ul>
<li><code>-F &lt;function-name&gt;</code>:查找方法名，例如：<code>image lookup -F viewDidLoad</code>。</li>
<li><code>-n &lt;function-or-symbol&gt;</code>：使用名称查找方法或者符号，例如：<code>image lookup -n maxShowTimes</code>。</li>
<li><code>-t &lt;name&gt;</code>：按名称查找一个类型，例如：<code>image lookup -t SignalView</code>。</li>
<li><code>-a &lt;address-expression&gt;</code>：查找符号地址所对应的信息，例如<code>image lookup -v -a 0x10433d3f0</code>。</li>
<li><code>-v</code>：打印粗略信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>register</code>：命令：<ul>
<li>格式：<code>register [read|write]</code>。</li>
<li>功能：访问当前栈帧和线程的寄存器。</li>
<li>子命令：<ul>
<li><code>read</code>：读取寄存器内容，例如：<code>register read x0</code>。</li>
<li><code>write</code>：设置寄存器内容。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>x</code>：命令；</p>
<ul>
<li>功能：从当前进程的内存中读取数据，是命令<code>memory read</code>的简写。</li>
<li>格式：<code>x/[数量][进制格式][字节数] 内存地址</code></li>
<li><p>参数格式：</p>
<ul>
<li>进制格式：x(十六进制)、f(浮点数)、d(十进制)。</li>
<li>字节数：b(byte 1字节)、h(half word 2 字节)、w(word 4字节)、g(giant word 8 字节)。    </li>
</ul>
</li>
<li><p>例子：<code>x/3xg $x0</code>，x0中保存一个地址，以十六进制查看在这个地址开始的三组，每组长度为 8 字节的数据。</p>
</li>
</ul>
</li>
</ul>
<p>小技巧：</p>
<ul>
<li><p>在 LLDB 中对着空行敲回车键，会自动执行上一条命令。</p>
</li>
<li><p>由于在 arm 汇编中 Objective-C 的方法总是会转换为<code>objc_msgSend(class,className,params...)</code>，所以在 Objective-C 方法的汇编中，有如下指令打印调用者、方法名和参数：</p>
<ul>
<li>打印调用者：<code>po $x0</code></li>
<li>打印方法名：<code>x/s $x1</code></li>
<li>打印参数：<code>po $x2....</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
        <tag>iOS逆向</tag>
      </tags>
  </entry>
  <entry>
    <title> Objective-C 代码转换为 C++代码</title>
    <url>/2018/12/05/Objective-C-%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA-C-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在研究 iOS 系统方法实现的时候，由于有时苹果未将改方法的实现开源，所以此时我们就需要将指定你文件转换为C++文件，这样就可以看到部分底层实现。</p>
<p>当你在谷歌搜索如何创建C++文件文件的时候，你得到的答案可能是这样:</p>
<a id="more"></a>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>这样</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc AppDelegate.m -o AppDelegate.cpp</span><br></pre></td></tr></table></figure>
<p>或者是这样</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk ViewController.m</span><br></pre></td></tr></table></figure>
<p>这时候你可能欣喜，竟然有那么多种方案可以实现，但是在键入这些代码之后你可能会发现令你更加欣(fa)喜(kuang)的一面,这结果可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error1.png" alt="UIKit/UIKit.h not found"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error2.png" alt="not support weak references"></p>
<p>或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/occonvert2C++Error3.png" alt="assigning retained object to weak variable"></p>
<p>这时候你看到那么多友善(mmp)的提示你的心情可能是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile1.jpg" alt="faker smile one"></p>
<p>这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile2.jpg" alt="faker smile two"></p>
<p>亦或者是这样</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/fakerSmile3.jpg" alt="faker smile three"></p>
<p>如果你真的遇到这些问题，请冷静一下，我们先来解决这个技术难题</p>
<p><img src="/2018/12/05/Objective-C-代码转换为-C-代码/dontDoThis1.jpg" alt="大哥别这样"></p>
<p>首先我们分析一下第一个命令产生的问题—— <code>fatal error: &#39;UIKit/UIKit.h&#39; file not found</code></p>
<p>这个问题产生的原因是因为 clang 将.m文件转换为 C++文件的时候，clang 找不到这个头文件，这时候我们只需要指定一下其平台即可 </p>
<ul>
<li>指定真机 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<ul>
<li>指定模拟器 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc ViewController.m</span><br></pre></td></tr></table></figure>
<p>但是指定真机之后还可能会产生问题，例如代码中有 weak，这时候 clang 转换又双叒叕不通过了，这时只需要支持 ARC 指定运行时版本即可 </p>
<ul>
<li>支持 ARC 指定运行时版本，例如在-rewrite-objc 后面添加如下代码 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">-fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时候两个最常见的问题已经解决了，接下来解决第三个问题。 </p>
<p>第三个问题困扰了我好久，最后发现只要不直接使用 alloc init 或者 new 之类的初始化方法给被 weak 修饰的指针赋值即可。 </p>
<ul>
<li>最终命令 </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<p>创建 C++文件总流程: </p>
<ol>
<li>打开终端，使用命令先进入指定路径(需要转换文件所在的路径) </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ChromeBook:</span>oc中的 weak sq$ cd /Users/sq/Desktop/Project/OCTest/oc中的\ weak/oc中的\ weak</span><br></pre></td></tr></table></figure>
<ol>
<li>输入上述最终命令，将最终命令中的Appdelegate.m改为你的目标文件 </li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator12.<span class="number">1</span> clang -rewrite-objc -fobjc-arc -stdlib=libc++ -fobjc-arc -fobjc-runtime=ios-<span class="number">8.0</span>.<span class="number">0</span> -Wno-deprecated-declarations Appdelegate.m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料： </p>
<p>OC代码转C++代码的生成:<a href="https://www.jianshu.com/p/3a896cba744a" target="_blank" rel="noopener">https://www.jianshu.com/p/3a896cba744a</a> </p>
<p>Objective-C编译成C++代码报错:<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">https://www.jianshu.com/p/43a09727eb2c</a> </p>
<p>使用clang将OC代码转为C++（亲测有效）:<a href="https://blog.csdn.net/qq_34003239/article/details/84230019" target="_blank" rel="noopener">https://blog.csdn.net/qq_34003239/article/details/84230019</a> </p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O文件结构初探索</title>
    <url>/2021/12/02/Mach-O%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%9D%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="什么是-Mach-O-文件"><a href="#什么是-Mach-O-文件" class="headerlink" title="什么是 Mach-O 文件"></a>什么是 Mach-O 文件</h2><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）以及 Windows 上的 PE。</p>
<h2 id="Mach-O-构成"><a href="#Mach-O-构成" class="headerlink" title="Mach-O 构成"></a>Mach-O 构成</h2><p>Mach-O文件分成四部分：</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/Mach-O 结构.png" alt="image-20211115214823308" style="zoom:67%;"></p>
<ul>
<li>header：包含文件的目标架构，CPU类型，以及其他标志和信息以便读取文件的其他部分。</li>
<li>Load Command：Load Command跟在 header 之后，指定了文件在加载时将如何在虚拟内存中布局和文件连接特性，还包括符号表（用于动态链接）位置，以及任何要加载的共享库的名字。</li>
<li>segment 和 section：跟在 load command 之后，load command 中的具体描述保存在这部分。</li>
<li>link edit segment：最后一部分是链接编辑段，该段包含链接编辑信息表，如符号表、字符串表等，由动态加载器用于链接可执行文件或Mach-O捆绑包到其依赖库。</li>
</ul>
<a id="more"></a>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView 查看 Mach-O.png" alt="image-20211129234917525" style="zoom:75%;"></p>
<h2 id="一、header"><a href="#一、header" class="headerlink" title="一、header"></a>一、header</h2><h3 id="header-概述"><a href="#header-概述" class="headerlink" title="header 概述"></a>header 概述</h3><p>Mach-O 的第一部分 header 中包含的信息描述了Mach-O 结构的概况，包括：目标架构，CPU情况，文件类型，loadCommand 数量，loadCommand 所占用大小(字节为单位)等等。我们接下来从源码出发探寻 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h</a> (文件中分别定义了32 位架构和 64 位架构的头结构，下文我们以 64 位为例)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* 魔数标记 */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* CPU 标记 */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* CPU确切型号 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* 文件类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* load command 数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* load commands 大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 额外标记 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* 保留 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>变量说明：</p>
<ul>
<li><p>magic：本质上是一个 4 字节整型数据，用于标识是 32 位架构还是 64 位架构，并且还能标识Mach-O 文件的大小端序。</p>
<ul>
<li>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> / <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/fat.h" target="_blank" rel="noopener">fat.h</a>中定义。</li>
<li>64 位小端：<code>#define MH_MAGIC_64 0xfeedfacf</code>。</li>
<li>64 位大端：<code>#define MH_CIGAM_64 0xcffaedfe</code>。</li>
<li>32 位小端：<code>#define    MH_MAGIC    0xfeedface</code>。</li>
<li>32 位大端：<code>#define MH_CIGAM    0xcefaedfe</code>。</li>
<li>胖二进制小端：<code>#define FAT_MAGIC    0xcafebabe</code>。</li>
<li>胖二进制大端：<code>#define FAT_CIGAM    0xbebafeca</code>。</li>
</ul>
</li>
<li><p>cputype：本质上一个是4 字节整型数据，用于表示运行 Mach-O 文件平台 CPU 的架构。</p>
<ul>
<li>值在  <a href="https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/machine.h" target="_blank" rel="noopener">machine.h</a> 文件中定义。</li>
<li>早期 arm CPU：<code>#define CPU_TYPE_ARM            ((cpu_type_t) 12)</code>。</li>
<li>arm64 CPU：<code>#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</code>，值为 <code>0100000C</code> 。</li>
<li>64 位英特尔 CPU：<code>#define CPU_TYPE_X86_64         (CPU_TYPE_X86 | CPU_ARCH_ABI64)</code>，值为<code>01000007</code>。</li>
</ul>
</li>
<li><p>cpusubtype：本质上一个是4 字节整型数据，用于在 cputtype 确定的情况下内核运行的确切 CPU 型号。</p>
<ul>
<li>值在  <a href="https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/machine.h" target="_blank" rel="noopener">machine.h</a> 文件中定义。</li>
<li>ARM64平台下：<ul>
<li>ARM64所有型号：<code>#define CPU_SUBTYPE_ARM64_ALL           ((cpu_subtype_t) 0)</code>。</li>
<li>ARM64_v8：<code>#define CPU_SUBTYPE_ARM64_V8            ((cpu_subtype_t) 1)</code>。</li>
<li>ARM64e：<code>#define CPU_SUBTYPE_ARM64E              ((cpu_subtype_t) 2)</code>。</li>
</ul>
</li>
<li>X86平台下：<ul>
<li>X86 所有型号：<code>#define CPU_SUBTYPE_X86_ALL             ((cpu_subtype_t)3)</code>。</li>
<li>X86 下 64位所有：<code>#define CPU_SUBTYPE_X86_64_ALL          ((cpu_subtype_t)3)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>filetype：表示 Mach-O 文件的类型。</p>
<ul>
<li><p>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中定义。</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/header-filetype.png" alt="image-20211128013604436"></p>
</li>
<li><p>MH_OBJECT:目标文件——通过对源代码编译得到的(中间)结果。目标文件（.o）、静态库文件(.a），静态库其实就是N个.o合并在一起。</p>
</li>
<li><p>MH_EXECUTE：标准可执行文件。</p>
</li>
<li><p>MH_DYLIB：动态库文件，*.dylib，.framework/xx。</p>
</li>
<li><p>MH_DYLINKER：动态链接编辑器，/usr/lib/dyld。注意 dyld 负责加载 MH_EXECUTE、MH_DYLIB和部分MH_BUNDLE文件(<a href="https://github.com/opensource-apple/dyld/blob/master/src/dyld.cpp" target="_blank" rel="noopener">dyld 源码</a>)。</p>
</li>
<li><p>MH_BUNDLE：插件，非独立的二进制文件，要加载至其他二进制文件才能发挥作用。和 DYLIB类型文件的区别在于：这些二进制文件是可执行文件显示地加载的，通常是调用 NSBundle(Objective-C)或 CFBundle(C)。</p>
</li>
<li><p>MH_DSYM：存储着二进制文件符号信息的文件，*.dSYM/Contents/Resources/DWARF/xx（常用于分析APP的崩溃信息）。</p>
</li>
</ul>
</li>
<li><p>ncmds：load command 数量(number of load commands)。</p>
</li>
<li><p>sizeofcmds：load command所占用的内存大小(字节为单位)。</p>
</li>
<li><p>flags：额外标记，表示Mach-O文件格式的某些可选特性的状态。</p>
<ul>
<li>值在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中定义。</li>
<li>MH_NOUNDEFS：该对象文件不包含未定义的符号。</li>
<li>MH_INCRLINK：对象文件是针对基础文件的增量链接的输出，不能被再次链接。</li>
<li>MH_DYLDLINK：该文件是动态链接器的输入，不能再次静态链接。</li>
<li>MH_TWOLEVEL：该模块使用两级命名空间绑定。</li>
<li>MH_FORCE_FLAT：可执行程序强迫所有模块使用平面名称空间绑定。</li>
<li>MH_WEAK_DEFINES：最终的链接模块包含外部弱符号。</li>
<li>MH_PREBOUND：该文件有其动态未定义引用的预绑定。</li>
<li>MH_PIE：当这个位被设置时，操作系统将在一个随机地址加载主可执行文件(<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5" target="_blank" rel="noopener">ASLR 技术</a>)。 只在MH_EXECUTE文件类型中使用。</li>
<li>MH_HAS_TLV_DESCRIPTORS：包含一个类型为S_THREAD_LOCAL_VARIABLES的section。</li>
</ul>
</li>
<li><p>reserved：保留给未来用。</p>
</li>
</ul>
<p>接下来我们通过实例来查看header 的具体构成：</p>
<h3 id="header-查看"><a href="#header-查看" class="headerlink" title="header 查看"></a>header 查看</h3><ol>
<li><p>使用 GUI 工具 MachOView：</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView-header.png" alt="image-20211128185142510"></p>
<p>由图可知该 MachO 文件类型是 NH_EXECUTE ，有 66 个 load command 等一系列信息。</p>
</li>
<li><p>file 命令查看文件类型及架构：<code>file &lt;filepath&gt;</code>，例如：<code>file /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</p>
</li>
<li><p>通过 lipo 命令查看所支持的架构：</p>
<p>lipo命令路径：<code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</p>
<p>开源地址：<a href="https://opensource.apple.com/tarballs/cctools/" target="_blank" rel="noopener">cctools/misc/lipo.c</a>。</p>
<p>lipo命令格式：</p>
<ul>
<li><p>查看帮助：<code>man lipo</code>。</p>
</li>
<li><p>查看支持多少种 CPU架构：</p>
<ul>
<li>格式：<code>lipo -info 文件路径</code> 。</li>
<li>例子：<code>lipo -info /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo</code>。</li>
</ul>
</li>
<li>合并多个架构：<ul>
<li>格式：<code>lipo [-arch 指定架构] -create 文件1 文件2 -output 输出文件</code>。</li>
<li>-arch 指定架构参数可选，如果指定的话会将文件 1 文件 2 中的指定架构从输入文件中复制到输出文件。</li>
</ul>
</li>
<li>提取指定架构：<ul>
<li>格式：<code>lipo 文件路径 -thin 指定架构 -output 输出文件</code>。</li>
</ul>
</li>
<li>移除特定架构：<ul>
<li>格式：<code>lipo 文件路径 -remove 指定架构 -output 输出文件</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="二、Load-Command"><a href="#二、Load-Command" class="headerlink" title="二、Load Command"></a>二、Load Command</h2><h3 id="Load-Command概述"><a href="#Load-Command概述" class="headerlink" title="Load Command概述"></a>Load Command概述</h3><p>跟在 header 之后的就是 Load Command，Load Command负责描述指令在内存中的布局情况和文件连接特性，还包括符号表（用于动态链接）位置，以及任何要加载的共享库。</p>
<p><img src="/2021/12/02/Mach-O文件结构初探索/MachOView-load command-overview.png" alt="image-20211128221136653" style="zoom: 67%;"></p>
<p>LoadCommand 中的加载指令有很多种，<code>LC_SEGMENT_64</code>、<code>LC_DYLD_INFO_ONLY</code>、<code>LC_UUID</code>等等。接下来我们通过具体实例查看和分析 LoadCommand 实际组成。</p>
<h3 id="Load-Command-查看"><a href="#Load-Command-查看" class="headerlink" title="Load Command 查看"></a>Load Command 查看</h3><p>在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中声明了Load Command 指令的基础结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* load command类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* load command的字节长度 64位架构的值是 8 的倍数   32 位架构的值是 4 的倍数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cmd：指令类型。定义在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a> 中：</p>
<table>
<thead>
<tr>
<th>指令(定义在<a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>指令值(定义在<a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>指令对应的函数(定义在 <a href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/kern/mach_loader.c" target="_blank" rel="noopener">mach_loader.c</a> )</th>
<th>对应的数据结构(定义在 <a href="https://github.com/apple/darwin-xnu/blob/main/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noopener">loader.h</a>)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_SEGMENT_64</td>
<td>0x19</td>
<td>load_segment</td>
<td>segment_command_64</td>
<td>定义一个 64 位段，将其映射到加载该文件的进程的地址空间。它还包括该段所包含的所有部分。</td>
</tr>
<tr>
<td>LC_DYLD_INFO_ONLY</td>
<td>0x80000022</td>
<td>由 dyld 处理</td>
<td>dyld_info_command</td>
<td>告知 dyld 加载 image 所需的偏移信息(Dynamic Loader Info包含具体信息)。</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td>0x2</td>
<td>由 dyld 处理</td>
<td>symtab_command</td>
<td>为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义的和未定义的 external 符号被链接器所使用。</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td>0xb</td>
<td>由 dyld 处理</td>
<td>dysymtab_command</td>
<td>指定动态链接器使用的额外符号表信息。</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>0xe</td>
<td>load_dylinker</td>
<td>dylinker_command</td>
<td>指定内核在加载该文件所链接的动态共享库的路径。</td>
</tr>
<tr>
<td>LC_UUID</td>
<td>0x1b</td>
<td>load_uuid</td>
<td>uuid_command</td>
<td>产生一个唯一的 128 位随机数来标识当前可执行文件或其 dSYM 文件。</td>
</tr>
<tr>
<td>LC_VERSION_MIN_IPHONEOS</td>
<td>0x25</td>
<td>load_version</td>
<td>version_min_command</td>
<td>指定当前可执行文件最低可运行系统版本。</td>
</tr>
<tr>
<td>LC_SOURCE_VERSION</td>
<td>0x2A</td>
<td></td>
<td>source_version_command</td>
<td>用来构建二进制文件的源版本</td>
</tr>
<tr>
<td>LC_MAIN</td>
<td>0x80000028</td>
<td>load_main</td>
<td>entry_point_command</td>
<td>定义程序入口，设置程序主线程的入口点地址和栈大小。</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO_64</td>
<td>0x2C</td>
<td>由 dyld 处理</td>
<td>encryption_info_command_64</td>
<td>指示加壳时加密段偏移和大小。</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>0xc</td>
<td>由 dyld 处理</td>
<td>dylib_command</td>
<td>指示需要加载的额外的动态库的信息，包括：库版本、库路径等。可以使用命令”otool -L xxx”查看。</td>
</tr>
<tr>
<td>LC_LOAD_WEAK_DYLIB</td>
<td>0x80000018</td>
<td>由 dyld 处理</td>
<td>dylib_command</td>
<td>建立在LC_LOAD_DYLIB功能的基础上，如果未找到指定的库，就忽略这个库。</td>
</tr>
<tr>
<td>LC_RPATH</td>
<td>0x8000001C</td>
<td>由 dyld 处理</td>
<td>rpath_command</td>
<td>Runpath Search Paths，包含一个路径，在运行时应该被添加到当前的运行路径中，用于寻找@rpath前缀的dylibs。</td>
</tr>
<tr>
<td>LC_FUNCTION_STARTS</td>
<td>0x26</td>
<td>由 dyld 处理</td>
<td>linkedit_data_command</td>
<td>指示函数起始地址表。</td>
</tr>
<tr>
<td>LC_DATA_IN_CODE</td>
<td>0x29</td>
<td>由 dyld 处理</td>
<td>linkedit_data_command</td>
<td>指示定义在代码段内的非指令的表。</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td>0x1d</td>
<td>load_code_signature</td>
<td>linkedit_data_command</td>
<td>定义代码签名信息。</td>
</tr>
</tbody>
</table>
<p>接下来我们着重分析几个加载命令：</p>
<h4 id="1-LC-SEGMENT-64"><a href="#1-LC-SEGMENT-64" class="headerlink" title="1.LC_SEGMENT_64"></a>1.LC_SEGMENT_64</h4><p>LC_SEGMENT_64命令是最重要的加载命令之一。这条命令负责将 segment 映射到内存中。</p>
<p>segument 定义了Mach-O文件中的字节范围，以及这些字节在动态链接器加载应用程序时被映射到虚拟内存的地址和内存保护属性。</p>
<p>segument 提供的信息结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* 表示LC_SEGMENT_64 值为0x19 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* load command 所占用的字节大小 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment 名称 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* segment 映射到虚拟内存的偏移 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* segment 映射到虚拟内存的大小 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* segment 在当前架构文件中的偏移  */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* segment 在当前架构文件中所对应的文件的大小 */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* segment 的最高内存保护级别，用八进制表示(4=r，2=w，1=x) */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* segment 最初始的内存保护级别 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* segment 中 section 的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 标记位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LC_SEGMENT_64的执行逻辑：内核将从偏移量 fileoff 出的 filesize 字节加载到虚拟内存中，这块虚拟内存起始地址为 vmaddr 长度是 vmsize。并且每个 segment 的页面的权限都由 initprot 进行初始化。segment 权限可以改变，但是最高不能超过 maxprot 所规定的的权限级别。级别权限在 <a href="osfmk/mach/vm_prot.h">osfmk/mach/vm_prot.h</a> 中定义。</p>
<p>LC_SEGMENT_64能加载如下几个段：</p>
<ul>
<li><strong>PAGEZERO：静态链接器创建了 `</strong>PAGEZERO<code>段作为可执行文件的第一个段。这个段位于虚拟内存0 处，占据虚拟内存大小是64位架构下：0x100000000 。并且由于</code>__PAGEZERO`段中没有数据，所以它在文件中不占空间。</li>
<li>__TEXT：包含可执行代码和其他只读数据，并且静态链接器将该 segment 的虚拟内存权限设置为不可写入。</li>
<li>__DATA：包含可读写数据，静态链接器设置上个页面的虚拟内存权限为允许读和写。</li>
<li>__OBJC：包含Objective-C语言运行时支持库所使用的数据。</li>
<li>__IMPORT： 段包含了符号存根和指向未在可执行文件中定义的符号的非懒惰指针。这个段只为针对IA-32结构的可执行文件而产生。</li>
<li>__LINKEDIT：包含动态链接器使用的原始数据，如符号、字符串和重定位表项。</li>
</ul>
<p>对于一些 segment (<code>__TEXT</code>、<code>__OBJC</code>、<code>__DATA</code>)来说，有时候其中包含的信息也被分解成不同的 section。section 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment 名字 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* section 映射到虚拟内存的偏移 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	size;		<span class="comment">/* section 的字节数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* section 在当前架构文件中的偏移 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section 的字节对齐大小 n，计算结果为2的n次方 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* 重定位入口的个数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* section 的类型和属性*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* 保留位 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* 保留位 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* 保留位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>__TEXT的 section：</p>
<table>
<thead>
<tr>
<th>segment,section</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__TEXT,__text</code></td>
<td>程序可执行的代码</td>
</tr>
<tr>
<td><code>__TEXT,__stubs</code></td>
<td>用于动态链接的桩</td>
</tr>
<tr>
<td><code>__TEXT,__stubs</code></td>
<td>用于动态链接的桩</td>
</tr>
<tr>
<td><code>__TEXT,__const</code></td>
<td>const关键字修饰的常量</td>
</tr>
<tr>
<td><code>__TEXT,__objc_methname</code></td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td><code>__TEXT,__ustring</code></td>
<td>unicode字符串</td>
</tr>
<tr>
<td><code>__TEXT,__cstring</code></td>
<td>C 中的常量字符串</td>
</tr>
<tr>
<td><code>__TEXT,__objc_classname</code></td>
<td>Objective-C 类名</td>
</tr>
<tr>
<td><code>__TEXT,__objc_methtype</code></td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td><code>__TEXT,__gcc_except_tab</code></td>
<td>gcc异常表</td>
</tr>
<tr>
<td><code>__TEXT,__unwind_info</code></td>
<td>用于确定异常发生时栈所对应的信息</td>
</tr>
<tr>
<td><code>__TEXT,__eh_frame</code></td>
<td>调试符号信息</td>
</tr>
</tbody>
</table>
<p>__DATA 的 section：</p>
<table>
<thead>
<tr>
<th>segment,section</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__DATA,__const</code></td>
<td>初始化可重新定位的常量变量。</td>
</tr>
<tr>
<td><code>__DATA,__cfstring</code></td>
<td>程序中使用的 CoreFoundation 字符串(CFStringRefs)</td>
</tr>
<tr>
<td><code>__DATA,__classlist</code></td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td><code>__DATA,__nlcslist</code></td>
<td>保存了Objective-C 的categories的 +load函数列表。</td>
</tr>
<tr>
<td><code>__DATA,__catlist</code></td>
<td>Objective-C 分类信息</td>
</tr>
<tr>
<td><code>__DATA,__protolist</code></td>
<td>包含Objective-C所有协议列表</td>
</tr>
<tr>
<td><code>__DATA,__imageinfo</code></td>
<td>保存了Objective-C 镜像信息。</td>
</tr>
<tr>
<td><code>__DATA,__selrefs</code></td>
<td>保存了Objective-C 方法调用者的信息。</td>
</tr>
<tr>
<td><code>__DATA,__objc_classrefs</code></td>
<td>保存了 Objective-C 被使用的类的引用信息。</td>
</tr>
<tr>
<td><code>__DATA,__objc_superrefs</code></td>
<td>保存了 Objective-C 调用了 super 方法的类的引用。</td>
</tr>
<tr>
<td><code>__DATA,__objc_ivar</code></td>
<td>保存了 Objective-C 中的 ivar 指针。</td>
</tr>
<tr>
<td><code>__DATA,__objc_data</code></td>
<td>存储的就是<code>objc_class</code>的所有成员</td>
</tr>
<tr>
<td><code>__DATA,__data</code></td>
<td>储存可变变量。</td>
</tr>
</tbody>
</table>
<h4 id="2-LC-MAIN"><a href="#2-LC-MAIN" class="headerlink" title="2.LC_MAIN"></a>2.LC_MAIN</h4><p>这条命令的作用是设置程序主线程的入口点地址和栈大小。</p>
<h4 id="3-LC-CODE-SIGNATURE"><a href="#3-LC-CODE-SIGNATURE" class="headerlink" title="3.LC_CODE_SIGNATURE"></a>3.LC_CODE_SIGNATURE</h4><p>可执行文件进行签名之后会添加此条 load command。</p>
<h2 id="三、segment-和-section"><a href="#三、segment-和-section" class="headerlink" title="三、segment 和 section"></a>三、segment 和 section</h2><p>这部分所包含的信息是 load command 数据的具体描述。</p>
<h2 id="四、link-edit-segment"><a href="#四、link-edit-segment" class="headerlink" title="四、link edit segment"></a>四、link edit segment</h2><p>该段包含链接编辑信息表，如符号表、字符串表等，由动态加载器用于链接可执行文件或Mach-O捆绑包到其依赖库。</p>
<blockquote>
<p>资料：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001519" target="_blank" rel="noopener">Mach-O Programming Topics</a></p>
<p><a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener">osx-abi-macho-file-format-reference</a></p>
<p><a href="https://www.leewong.cn/2020/08/30/Mach-O/" target="_blank" rel="noopener">Mach-O 探究</a></p>
<p><a href="https://devyang.space/2020/01/10/%E4%BB%8Ellvm%E7%9C%8BmachO/" target="_blank" rel="noopener">从LLVM看MachO</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
        <tag>iOS逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Instrument文档翻译</title>
    <url>/2021/04/11/Instrument%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h2 id="关于Instrument"><a href="#关于Instrument" class="headerlink" title="关于Instrument"></a>关于Instrument</h2><h3 id="Instruments概述"><a href="#Instruments概述" class="headerlink" title="Instruments概述"></a>Instruments概述</h3><p>Instrument是 Xcode 工具集中的一个强大且灵活的性能分析和测试工具。它能够分析iOS，watchOS和 macOS的 app，以便您能够更好的理解和优化其行为并提高其性能。在您 app 开发的最初就将 Instrument 加入您的工作流当中能够在app 开发早期就帮助您发现问题以便减少后来的时间。</p>
<p>在Instrument中您使用的特殊工具被称作instruments，他们能够跟踪您app进程和硬件设备等不同方面。instruments将会手机数据以作分析，并将分析结果以图标的形式呈现出来。</p>
<p>Instruments与其他性能和调试工具不同的是，instruments允许你收集多种不同类型的数据并将其并排展示。这养能够轻易的分辨可能被遗漏的趋势。举个例子，由于多个开放的网络连接，您 app 出现巨大的内存增长时，通过同时使用Allocations和Connections这俩instruments工具，你能够识别出因未关闭而导致内存暴增的连接。</p>
<a id="more"></a>
<p>通过高效使用Instrument，你能够</p>
<ul>
<li>检查一个或多个 app 或进程</li>
<li>检查类似 WIFI和蓝牙这类设备特性</li>
<li>在模拟器或者真机上做性能分析</li>
<li>跟踪代码中出现的问题</li>
<li>对您的 app 进行性能分析</li>
<li>在您 app 中找到类似内存泄漏，弃用内存和僵尸对象</li>
<li>识别出使您 app 提高电源效率的方法</li>
<li>进行的常规系统级别的问题分析</li>
<li>将 Instrument 配置信息作为模板保存</li>
</ul>
<p>尽管他已嵌入并可以与Xcode 一同使用，Instruments还是一个独立的软件，这意味着在需要的时候Instruments可以独立使用。</p>
<p><a href="https://help.apple.com/instruments/developer/mac/current/" target="_blank" rel="noopener">Instruments开发帮助</a></p>
<h3 id="关于跟踪-trace-的文档"><a href="#关于跟踪-trace-的文档" class="headerlink" title="关于跟踪(trace)的文档"></a>关于跟踪(trace)的文档</h3><p>跟踪文档常被用来作为组织和配置用于分析的instruments，数据收集的发起，和查看分析结果。你可以通过启动Instruments之后选择分析模板或者直接从Xcode，Dock，命令行启动分析的方式来创建一个新的跟踪文档。您同样可以保存和重新打开您已经配置过的instruments并收集过数据的跟踪文档。一个跟踪文档可以通过多个窗格和区域的方式呈现出极其详尽的信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/51452EE2-B973-4C3C-A19F-A398AD0E5A59.png" alt="51452EE2-B973-4C3C-A19F-A398AD0E5A59"></p>
<p>跟踪文档包括如下多个主区域</p>
<ul>
<li>工具栏：允许但不限于您开始，暂停和结束数据分析，添加instruments，隐藏或者显示窗格。查看<a href="https://help.apple.com/instruments/mac/10.0/#/dev546b5b54" target="_blank" rel="noopener">关于跟踪文档工具栏</a></li>
<li>时间线窗格：以图形化模式展示指定跟踪(trace)所记录的数据的概要。查看<a href="https://help.apple.com/instruments/mac/10.0/#/devc12c5417" target="_blank" rel="noopener">关于跟踪文档时间线窗格</a></li>
<li>详情窗格：展示在您跟踪文档中使用instruments所收集的数据的详细信息。查看<a href="https://help.apple.com/instruments/mac/10.0/#/dev9b08bd72" target="_blank" rel="noopener">关于跟踪文档详情窗格</a></li>
<li>检查器窗格：包含关于当前数据记录的信息概要和instruments具体的扩展详情。查看<a href="https://help.apple.com/instruments/mac/10.0/#/devd72c957d" target="_blank" rel="noopener">关于跟踪文档检查器窗格</a></li>
</ul>
<h3 id="关于跟踪文档工具栏"><a href="#关于跟踪文档工具栏" class="headerlink" title="关于跟踪文档工具栏"></a>关于跟踪文档工具栏</h3><p>跟踪文档工具栏允许但不限于您开始，暂停和结束数据分析，添加instruments，隐藏或者显示窗格。</p>
<p>工具栏包含如下主要对象：</p>
<ul>
<li>分析控件：允许您记录，暂停和停止数据收集。</li>
<li>目标设备列表：允许您选择您希望分析的设备。</li>
<li>目标进程列表：允许您选择一个或多个进程用于分析。</li>
<li>活动查看器：展示跟踪文档的运行数量和当前跟踪(trace)的流逝时间。</li>
<li>添加Instrument按钮(+)：展示或隐藏包含所有可用instruments库模列表。在列表中你可以单独选择将它们添加到跟踪文档中。</li>
<li>查看按钮：显示或隐藏详情和检查器窗格。</li>
</ul>
<h3 id="关于跟踪文档时间线窗格"><a href="#关于跟踪文档时间线窗格" class="headerlink" title="关于跟踪文档时间线窗格"></a>关于跟踪文档时间线窗格</h3><p>时间线窗格以图形化模式展示指定跟踪(trace)所记录的数据的概要。在这个窗格中任意一个instrument，CPU核心或线程都有其各自跟踪(trace)，这个跟踪能够提供所收集到数据的图形化表格。</p>
<p>虽然这个窗格的信息是只读的，但是你能够通过滑动数据来选择需要仔细查看的指定区域，并插入标记以突显您感兴趣的点。你可以通过改变缩放级别，或者使用<a href="https://help.apple.com/instruments/mac/10.0/#/deva13e2923b" target="_blank" rel="noopener">显示配置弹出框</a>来改变一个独立instruments的显示配置来更改图形信息显示方式。instrument有一个可选择的过滤器栏来控制过滤数据的显示方式。例如，一个简单的instrument能够通过线程来过滤数据。</p>
<p>当你调查问题的时候可以通过将时间线固定到隔窗底部的方式来保持重要信息的显示。举个例子，你能够固定将Leaks instrument固定在窗格底部，接着通过滑动其他instruments来查找和发现可能发生内存泄漏的地方。被固定的instruments不会在多个运行之间保存。</p>
<p><img src="/2021/04/11/Instrument文档翻译/3EB44883-494C-4B0C-8C4C-06EFE03313A4.png" alt="3EB44883-494C-4B0C-8C4C-06EFE03313A4"></p>
<p>策略视图</p>
<p>点击筛选视图中的策略按钮在时间线中单独或同时显示instruments或CPU核心或线程数据。</p>
<p><img src="/2021/04/11/Instrument文档翻译/82A15CE7-10F3-4DDA-B79B-E5F9E8951416.png" alt="82A15CE7-10F3-4DDA-B79B-E5F9E8951416"></p>
<p>ALL：在时间线中展示instruments，线程和CPU核心数据。</p>
<p>CPUs：显示CPU核心列表，并在时间线窗格中单独展示随着时间改变它们的使用情况。只有当一个跟踪文档中包含记录了CPU数据的instruments时，才可用。</p>
<p><img src="/2021/04/11/Instrument文档翻译/64707226-3F58-4156-8C51-7C205735C864.png" alt="64707226-3F58-4156-8C51-7C205735C864"></p>
<p>Instruments：在时间线窗格中展示instruments列表和其数据。</p>
<p>当你在列表中选择了instrument，你可以在监控窗格中删除或者配置它。当你创建一个跟踪文档时instruments列表是默认可见的。</p>
<p><img src="/2021/04/11/Instrument文档翻译/4AFEA707-9FC7-45C4-9243-225D355F2E9F.png" alt="4AFEA707-9FC7-45C4-9243-225D355F2E9F"></p>
<p>Threads：在时间窗格中显示线程列表和其所使用的数据。只有在跟踪文档所包含的instruments记录了线程数据时才可见。</p>
<p><img src="/2021/04/11/Instrument文档翻译/74EABEE3-8F29-43D6-8D85-95E9CF8A382C.png" alt="74EABEE3-8F29-43D6-8D85-95E9CF8A382C"></p>
<h3 id="关于显示配置弹窗"><a href="#关于显示配置弹窗" class="headerlink" title="关于显示配置弹窗"></a>关于显示配置弹窗</h3><p>使用显示配置弹窗来配置在时间线中需要展示的数据和其展示格式。</p>
<p>在显示配置弹窗中可用的显示设置根据instrument而异。这些设置能帮助你：</p>
<ul>
<li>控制数据在时间线中的出现。例如：Activity instrument允许你切换总线程，虚拟机大小，和其他系统统计信息的显示。</li>
<li>调整被记录信息在时间线中的呈现方式。例如，instrument可能能让你在峰图和框图中切换。</li>
</ul>
<p>要打开显示配置窗口，请在跟踪文档的时间线窗格中点击instrument图标。当指针移到图标上方时，支持显示配置弹出框的instrument会显示一个指示器。</p>
<h3 id="关于跟踪文档详情窗格"><a href="#关于跟踪文档详情窗格" class="headerlink" title="关于跟踪文档详情窗格"></a>关于跟踪文档详情窗格</h3><p>详情窗格中展示在跟踪文档中使用instruments所收集到的数据的详情信息。正在分析时可以在时间线窗格中选择独立的instruments来查看所收集到的数据。</p>
<p>详情窗格由导航栏，数据收集区域和筛选配置栏三个区域构成。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane.png" alt="img"></p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>导航栏在详情窗格的顶部，它能够帮助你快速浏览收集到的数据。</p>
<p>你能够在导航栏中切换数据类型并查看不同的级别的数据。</p>
<ul>
<li>Instrument：当前时间线窗格中所选择的instrument的图标。点击它能够查看instrument的控制台。</li>
<li>Detail type list：能够在不同类型数据之间切换。对不同的Instrument其显示选项有差异。对于多数instruments，它们都包含了例如数据概要，调用树和控制台。</li>
<li>Detail tree：对您在详情窗格中数据查看时对其层级持续的跟踪。点击tree分支来选择与层级相符的数据。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_navigation_bar.png" alt="img"></p>
<h4 id="数据收集区"><a href="#数据收集区" class="headerlink" title="数据收集区"></a>数据收集区</h4><p>数据收集区展示所选instrument收集的所有数据，并通常以表格形式展现。不同instrument之间在这里展现的内容也会有显著不同。例如，Activity Monitor显示进程，CPU和线程，以及更多信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_collected_data_table.png" alt="img"></p>
<p>通常，在这个区域中的独立符号和数据点包含了导航按钮(<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACWElEQVRYw+2XZ4siQRCG9///EXNAVMQsooIJFQOCYkJBPyiiKMZanoZZ2r05xvO8deFWKJjQ9dYz1VXd7Zu8+Pf2A/DtAa7Xq2y3WxmPx9JqtaRcLksul5NsNiuZTEYZ1zzjHWMYiw++DwHgeLlcZL/fy3K5lOFwKJVKRVKplIRCIfH5fOLxeMTtdivjmme8Ywxj8cEXDbR+B2MKgMPhcJDFYiH1el2SyeRNYKfTaWo6CD74ooEWmncDQI1ju92WWCymhB0Oh9jt9ruMsfjgiwZaaN4FQKpIHfQI+P3+PwquQ+CLBlpomk3DLwCbzUbNHyk0vtxms5kGcblcEggElFELOig+RiaoCzQpTEuA0Wikqpl5tPpyAufzeSkUChIMBlUdfPbhHi0Kk+6wBKCNIKaYrNIciUSk0+lIr9dTENyTdjKjg6CFJtqWAMbXkzorgHg8LpPJRNbrtUynU2k2m2rqDAhjHFpolkolawAWFIhJpy7A1yGuW7ValdVqJefzWVX5fD6XRqOhFqdwOCxer/ejRdFE2xKAVc3odT3V3W5XBdCN4MfjUVW3AUG1DwYDKRaLEo1GPyDQRNsSAHoqWgdIJBIym83kdDrdGEH11jJAgGC+0+m0mg600ET7IQB6mTaiRXXb7XYq4FMBzKaAAqrVatLv92+MrJD2p06BWRFCDwSCulHVBHxqEf7LNkT7+y9ELJcsmy9bitkwjM3I2GD+djNC6+7NyNiOqfqXbMfPOpCQkYcOJM88kpHFh45kZodSWujLDqWfYVh2Oah82bH855/RfwXwDvGnbAtXk4lSAAAAAElFTkSuQmCC" alt="img">)，当你指向它的时候它才会出现。您可以点击按钮进入数据的更深层。当你点击进入时，在导航栏的详情树会随之更新并指向您所在的层级。</p>
<h4 id="筛选配置栏"><a href="#筛选配置栏" class="headerlink" title="筛选配置栏"></a>筛选配置栏</h4><p>在详情窗格底部的筛选配置栏能够帮你筛选所收集到的数据并配置数据显示的方式。</p>
<ul>
<li>Filter field：允许您以指定条件筛选所收集到的数据。点击筛选按钮区域会出现一些筛选选项。你同样可以通过在展示配置弹窗中调整显示设置的方式收集更多的数据。</li>
<li>Display configuration controls：通过筛选，排序和数据挖掘来优化显示结果。instrument之间的控制会有差异，包括不同的结果选择菜单和用于数据显示的弹窗。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_filter_config_bar.png" alt="A screenshot of the filter and display configuration bar showing the filter field on the left followed by a configuration drop-down, and buttons that show popovers with other display configuration options."></p>
<h3 id="关于跟踪文档的监视器窗格"><a href="#关于跟踪文档的监视器窗格" class="headerlink" title="关于跟踪文档的监视器窗格"></a>关于跟踪文档的监视器窗格</h3><p>监视器窗口包含在当前详情窗格当前运行的信息。这些信息包含当前记录的信息，并对于一些instruments还会包含当前所选数据的额外详情。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_navigation_bar.png" alt="img"></p>
<h4 id="运行信息区域"><a href="#运行信息区域" class="headerlink" title="运行信息区域"></a>运行信息区域</h4><p>运行区域展示详情窗格中当前的运行信息。包含目标，记录时间，记录所用到的设置。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_run_information.png" alt="A screenshot of the run information area of the detail pain inspector showing the recording information and recording settings for the current recording."></p>
<h4 id="额外详情区域"><a href="#额外详情区域" class="headerlink" title="额外详情区域"></a>额外详情区域</h4><p>额外详情区域常被用来展示特定instrument的关于在详情窗格中选中数据的额外信息，例如完整的栈跟踪。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_extended_detail.png" alt="img"></p>
<h3 id="关于库面板"><a href="#关于库面板" class="headerlink" title="关于库面板"></a>关于库面板</h3><p>库面板提供了可用instrument的完整列表，并能让你添加到跟踪文档中。在面板中你可以浏览instrument描述也可以筛选出指定的instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette.png" alt="img"></p>
<p>要显示库面板，请点击Window &gt; Library或按快捷键(Command-L)，还可以通过点击跟踪文档工具栏中Instrument的加号按钮(+)。</p>
<h3 id="关于标记面板"><a href="#关于标记面板" class="headerlink" title="关于标记面板"></a>关于标记面板</h3><p>标记面板中展示当前活动的跟踪文档中您需要在时间线窗格中添加的标记列表。</p>
<p>在标记文档中你可以通过选择标记来快速在时间线中导航到指定位置。你同样可以在一个较大的标记列表中筛选出指定标记，展示或隐藏标记和查看您标记的时间戳信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_flags_window.png" alt="img"></p>
<h3 id="关于分析模板"><a href="#关于分析模板" class="headerlink" title="关于分析模板"></a>关于分析模板</h3><p>在Instruments中你可以选择分析模板来分析您的app。分析模板是跟踪文档为了执行通用跟踪使用instruments已经预配置和设置过的。</p>
<p>在Instruments启动时或在Xcode中初始化一个跟踪或者创造新的跟踪文档的时候分析模板就已经可已使用。当您拥有更高级或者自定义的需求的时候也可以创造您自己的分析模板。</p>
<h3 id="关于分析模板选择框"><a href="#关于分析模板选择框" class="headerlink" title="关于分析模板选择框"></a><img src="/2021/04/11/Instrument文档翻译/instruments_profilingtemplateselection_dialog.png" alt="img">关于分析模板选择框</h3><p>在Instruments启动时你会看到一个模板列表，并可以从中选择，这列表是instruments预先设置好的集合。这个列表里包含标准的模板集合，同样也包含了你自定义的模板。</p>
<p>分析选择框由如下几个主要的要素组成：</p>
<ul>
<li>Target device list(目标设备列表)：点击这个可以选择您需要分析的载体设备。</li>
<li>Target process list(目标进程列表)：点击这个可以选择一个或者多个需要分析的进程。</li>
<li>Filter buttons(筛选按钮)：点击这些按钮在模板列表中筛选出标准模板，自定义模板和最近使用的模板。</li>
<li>Search field(搜索框)：通过输入文本来快速筛选出您需要的模板。它能够搜索模板的标题和描述。</li>
<li>Template list(模板列表)：可能被您输入的内容筛选过的模板列表。</li>
<li>Template description(模板描述)：当前所选中的模板的简短的描述，这段描述可能能够帮助您选择出符合您需求的模板。</li>
<li>Choose button(选择按钮)：点击它可以会基于你当前选择的来创建分析文档。 </li>
</ul>
<p>​       当你按住Option按键的时候它会变成分析(Profile)按钮。点击分析按钮会基于你当前选择的模板创建一个新的文档并直接开始分析。</p>
<ul>
<li>Open button(打开按钮)：点击它可以打开之前保存的分析文档，而不是以一个全新的模板开始。</li>
<li>Cancel button(取消按钮)：点击它关闭模板选择框。</li>
</ul>
<p>注意：你可以随时通过选择File &gt; New或者按下Command-N来呼出分析模板选择框。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profilingtemplate_dialog.png" alt="img"></p>
<h3 id="关于引用窗口"><a href="#关于引用窗口" class="headerlink" title="关于引用窗口"></a>关于引用窗口</h3><p>引用窗口被用来控制各种Instruments相关的行为设置。</p>
<p>在引用窗口中。你可以调整启动，保存和其他的相关设置。你同样可以调整记录设置，CPU设置和符号引用。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_general.png" alt="img"></p>
<h2 id="启动Instruments"><a href="#启动Instruments" class="headerlink" title="启动Instruments"></a>启动Instruments</h2><h3 id="从Xcode中启动Instruments"><a href="#从Xcode中启动Instruments" class="headerlink" title="从Xcode中启动Instruments"></a>从Xcode中启动Instruments</h3><p>在Xcode中启动Instruments最直接的方法。</p>
<ul>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu.png" alt="img"></p>
<h3 id="从Docker中启动Instruments"><a href="#从Docker中启动Instruments" class="headerlink" title="从Docker中启动Instruments"></a>从Docker中启动Instruments</h3><p>当Xcode运行的时候可以在Docker中的Xcode图标中启动Instruments。</p>
<ol>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/dock_xcode_contextualmenu_instruments.png" alt="img"></p>
<p>这样Instruments就启动了。</p>
<h3 id="将Instruments添加到Docker中"><a href="#将Instruments添加到Docker中" class="headerlink" title="将Instruments添加到Docker中"></a>将Instruments添加到Docker中</h3><p>你可以将Instruments添加到Docker中来随时快速访问。实现添加最简单的方法就是启动Instruments然后将其固定在Docker中。</p>
<ol>
<li>在Xcode中选择Xcode &gt; Open Developer Tool &gt; Instruments。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu2.png" alt="img">、Instruments启动并在Docker中出现了Instruments的图标。</p>
<ol>
<li>在Docker中右键点击Instruments图标，接着选择Options &gt; 在程序坞中保留。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_contextual_menu_options_keepindock.png" alt="img"></p>
<h3 id="添加Instruments到Launchpad"><a href="#添加Instruments到Launchpad" class="headerlink" title="添加Instruments到Launchpad"></a>添加Instruments到Launchpad</h3><p>Launchpad会自动显示您在应用程序文件夹内的 App。由于Instruments并不是应用程序文件夹内的程序(至少不是直属与应用程序文件夹内，它是在Xcode 中的，而 Xcode 直属与应用程序文件夹)，因此Instruments不会在Launchpad中出现。当然你可以通过对Instruments创建一个别名并将其放入Applications文件夹。</p>
<ol>
<li><p>在Xcode中，选择 Xcode > Open Developer Tool &gt; Instruments。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_instruments_menu.png" alt="img"></p>
<p>Instruments图标在您 Docker 中出现。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_app_icon_small.png" alt="img"></p>
</li>
<li><p>在 Docker 中右键点击Instruments图标，之后选择选项 -&gt; 在文件夹中显示。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_contextual_menu_options.png" alt="img"></p>
</li>
<li><p>按住 option 键并将Instruments图标拖动到您的应用程序文件夹目录中。一个Instruments的别名就已经创建成功并添加到您的应用程序文件夹中了。</p>
</li>
<li><p>删除Instruments别名文件名中的别名前缀。</p>
<p>Instruments现在将会出现在你的Launchpad中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/launchpad_instruments.png" alt="img"></p>
</li>
</ol>
<h3 id="从命令行中启动Instruments"><a href="#从命令行中启动Instruments" class="headerlink" title="从命令行中启动Instruments"></a>从命令行中启动Instruments</h3><p>你可以在OS X中通过终端使用开放命令打开包括Instruments在内的任意软件。</p>
<ol>
<li><p>打开终端(在/Applications/Utilities/)。</p>
</li>
<li><p>运行如下命令：</p>
<p>open /Applications/Xcode.app/Contents/Applications/Instruments.app</p>
</li>
</ol>
<p>Instruments被运行了。</p>
<p>注意：你可以使用两个命令行工具的任意一个来分析您的 app，而无需显示Instruments用户图形界面。</p>
<ul>
<li>instruments——此实用程序使用指定的模板对应用程序进行配置。可以将结果保存到文件中，然后在主要的仪器应用程序中手动打开以进行查看和分析。在<a href="https://help.apple.com/instruments/mac/current/#/devb14ffaa5" target="_blank" rel="noopener">使用instruments命令行工具分析</a>中查看更多。</li>
</ul>
<h2 id="创建，保存和打开跟踪文档"><a href="#创建，保存和打开跟踪文档" class="headerlink" title="创建，保存和打开跟踪文档"></a>创建，保存和打开跟踪文档</h2><h3 id="创建一个跟踪文档"><a href="#创建一个跟踪文档" class="headerlink" title="创建一个跟踪文档"></a>创建一个跟踪文档</h3><p>在使用Instruments开始分析之前，你需要创建跟踪文档。</p>
<ol>
<li>打开Instruments</li>
<li>当出现的分析模板选择框中选择目标设备和进程。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profiling_dialog_target.png" alt="img"></p>
<ol>
<li>选择期望的分析模板</li>
<li>点击Choose</li>
</ol>
<p>从您选择的模板中使用预配置好的instruments创建了一个新的跟踪文档。</p>
<p>提示：要在您创建跟踪文档之后立即自动开始分析，请在模板选择框中按住 option 键。当你如上述所述操作时，Choose按钮会变为Profile按钮。点击Profile按钮立即开始分析跟踪文档。</p>
<p>如果你找不到您所需要模板或者想从头开始创建自己的模板，在模板选择提示框中选择空白模板。</p>
<h3 id="保存一个跟踪文档"><a href="#保存一个跟踪文档" class="headerlink" title="保存一个跟踪文档"></a>保存一个跟踪文档</h3><p>当你创建了一个跟踪文档，你能够保存上次引用。Instruments将以 .trace 扩展名保存保存跟踪文档文件。</p>
<ol>
<li><p>创建一个跟踪文档。<a href="#创建一个跟踪文档">在创建跟踪文档中查看</a></p>
</li>
<li><p>选择 File &gt; Save. Or, choose File &gt; Save 当你希望将之前保存的跟踪文档保存成新的文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_menu.png" alt="img"></p>
</li>
<li><p>输入文件名</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_dialog.png" alt="img"></p>
</li>
<li><p>选择文件保存目录</p>
</li>
<li><p>点击保存</p>
</li>
</ol>
<h3 id="将跟踪文档保存为分析模板"><a href="#将跟踪文档保存为分析模板" class="headerlink" title="将跟踪文档保存为分析模板"></a>将跟踪文档保存为分析模板</h3><p>如果你创建了一个跟踪文档，并且可能会在之后分析其他app时用到这个模板，你可以将它保存为自定义模板以便你不用每次运行Instruments时都重新创建。</p>
<ol>
<li><p>创建或打开跟踪文档。</p>
</li>
<li><p>选择 File &gt; Save As Template。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_menu.png" alt="img"></p>
</li>
<li><p>输入模板名称。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_save_dialog.png" alt="img"></p>
</li>
<li><p>选择模板保存目录。</p>
<p>将您模板保存在/Users/<username>/Library/Application Support/Instruments/Templates目录下以保证它能够在Instruments模板窗口中的的自定义部分中可用。</username></p>
</li>
<li><p>为模板选择一个图标。</p>
</li>
<li><p>输入模板的描述。</p>
</li>
<li><p>点击保存。</p>
<p>当你保存了模板，这个模板会自动出现在模板选择框中的Custom模板组中出现。下次当你创建一个跟踪文档时，可以将其作为您分析的起点。</p>
</li>
</ol>
<h3 id="打开跟踪文档"><a href="#打开跟踪文档" class="headerlink" title="打开跟踪文档"></a>打开跟踪文档</h3><p>打开已保存的跟踪文档来查看之前运行的结果或者对其进行额外的分析。</p>
<p>按如下操作之一来打开跟踪文档：</p>
<ul>
<li><p>在文件夹中双击 .trace 文档文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/trace_document.png" alt="img"></p>
</li>
<li><p>将 .trace 文档文件拖入Instruments软件图标中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_drag_and_open_trace_doc.png" alt="img"></p>
</li>
<li><p>打开Instruments并按如下步骤来操作：</p>
<ol>
<li><p>选择 File &gt; Open (或按快捷键Command + O)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_file_open_menu.png" alt="img"></p>
</li>
<li><p>找到所保存的 .trance 文档文件。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_open_trace_doc_dialog.png" alt="img"></p>
</li>
<li><p>点击open。</p>
</li>
</ol>
</li>
</ul>
<p>这样跟踪文档就在Instruments中显示。</p>
<h3 id="关闭跟踪文档"><a href="#关闭跟踪文档" class="headerlink" title="关闭跟踪文档"></a>关闭跟踪文档</h3><p>当你使用跟踪文档完毕时，关闭它。</p>
<ol>
<li>选择 File &gt; Close(或按下Command + W)</li>
<li>当你的跟踪文档中包含尚未保存的数据，请选择是否保存更新文档。</li>
</ol>
<h2 id="目标设备和进程"><a href="#目标设备和进程" class="headerlink" title="目标设备和进程"></a>目标设备和进程</h2><h3 id="目标设备和进程-1"><a href="#目标设备和进程-1" class="headerlink" title="目标设备和进程"></a>目标设备和进程</h3><p>目标设备列表能在每个跟踪文档中的工具栏中看到，这个列表允许你跟踪文档运行中的任何时候更改指定设备和进程。</p>
<ul>
<li><p>点击目标设备列表或目标进程列表并选择指定目标和进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetspecificprocess_menuitem.png" alt="img"></p>
<p>部分instruments能以所有进程为目标。如果逆向选择全部进程，请在目标进程列表中选择全部进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetallprocesses_menuitem.png" alt="img"></p>
<p>如果目标进程并不在列表中，在目标进程列表中选择Choose Target。之后会显示一个弹窗，在这个弹窗内你可以浏览所有进程。你也可以在这个弹窗中为一个进程配置环境变量。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_choosetarget_menuitem.png" alt="img"></p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_choosetargetdialog.png" alt="img"></p>
</li>
</ul>
<p>提示：如果一个你已被设置为目标的app，但是并没有主动运行app，instruments会自动将其运行。</p>
<h3 id="以iOS设备作为目标"><a href="#以iOS设备作为目标" class="headerlink" title="以iOS设备作为目标"></a>以iOS设备作为目标</h3><p>为了将iOS设备作为目标，请把设备连接到开发Mac上。一旦连接，设备会出现在设备列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetiosdevice.png" alt="img"></p>
<p>注意：在你能使用Instruments分析iOS设备之前，你的设备必须已经拥有了能够搜集数据的开发环境。关于提供开发环境，请在<a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/index.html" target="_blank" rel="noopener">App分发指南上</a>查看<a href="https://developer.apple.com/library/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingProfiles/MaintainingProfiles.html#//apple_ref/doc/uid/TP40012582-CH30-SW61" target="_blank" rel="noopener">创建Provision 开发文件</a>。</p>
<h3 id="启动iOS设备无线分析"><a href="#启动iOS设备无线分析" class="headerlink" title="启动iOS设备无线分析"></a>启动iOS设备无线分析</h3><p>Instruments能够使用无线的方式来从iOS设备上收集数据。</p>
<ol>
<li><p>请确保您iOS设备已经连接到开发Mac上。</p>
<p><img src="/2021/04/11/Instrument文档翻译/graphic_computerconnectedtodevice.png" alt="img"></p>
</li>
<li><p>按住Option按键，并点击目标设备列表。</p>
</li>
<li><p>选择您需要开启无线分析的移动设备。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targets_enablewireless.png" alt="img"></p>
</li>
<li><p>再次点击设备目标列表并打开它，为您设备选择无线版本并选择进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targtetlist_selectwirelessprocess.png" alt="img"></p>
</li>
</ol>
<p>现在您应该可以在您设备商以无线的形式分析进程。</p>
<p>无线调试模式费事如下情况十分有用：</p>
<ul>
<li>Accelerometers(加速度计)：在所有方向是移动设备，而非只在一条线上。</li>
<li>Accessories(配件)：将您的USB配件插入插槽并进行测试。</li>
</ul>
<p>当你在设备上使用无线分析时，对设备关机会导致停止收集数据。你必须重新将设备连接到电脑上才能继续数据收集。</p>
<p><strong>重点：</strong>在Instruments收集数据之前，您的设备必须要有开发环境。并且您必须在无线网络访问端口上启用Bonjour和multicast。请在<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Discovering,Browsing,AndAdvertisingNetworkServices/Discovering,Browsing,AndAdvertisingNetworkServices.html#//apple_ref/doc/uid/TP40010220-CH9-SW7" target="_blank" rel="noopener">Bonjour服务预览</a>中查看。且记录数据所用 Mac 和设备必须都处于同一个子网中。</p>
<h3 id="准备Apple-Watch分析"><a href="#准备Apple-Watch分析" class="headerlink" title="准备Apple Watch分析"></a>准备Apple Watch分析</h3><p>在你使用instruments以Apple Watch作为目标之前，必须先对其进行分析。</p>
<ol>
<li><p>确保Apple Watch已与开发iPhone配对过。</p>
</li>
<li><p>退出Instruments。</p>
</li>
<li><p>打开Xcode。</p>
</li>
<li><p>将已于Apple Watch配对的iPhone连接到开发Mac上。</p>
<p><img src="/2021/04/11/Instrument文档翻译/graphic_computerconnectedtodevice.png" alt="img"></p>
</li>
<li><p>选择Window &gt; Devices(或按下Shift+Command+2)打开Xcode中设备窗口。</p>
</li>
<li><p>等待设备出现在列表窗口中。</p>
</li>
<li><p>等待Apple Watch作为iPhone配对设备出现。</p>
</li>
<li><p>等待Xcode将Apple Watch标记为准备完成。这个过程可能会花费好几分钟。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_devices_pairedwatch.png" alt="img"></p>
</li>
<li><p>断开iPhone连接。</p>
</li>
<li><p>再次连接iPhone。</p>
</li>
</ol>
<p>当你的Apple Watch完成分析准备，重启Instruments，然后Apple Watch会出现在目的设备列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_targetwatch.png" alt="img"></p>
<p>注意：在您分析Apple Watch的时候，你的开发iPhone充当代理，在Instruments和Apple Watch之间传递信息。</p>
<h2 id="访问和使用Instruments"><a href="#访问和使用Instruments" class="headerlink" title="访问和使用Instruments"></a>访问和使用Instruments</h2><h3 id="显示模板库"><a href="#显示模板库" class="headerlink" title="显示模板库"></a>显示模板库</h3><p>库模板中显示所有你能够添加到跟踪文档上的instruments。库中包含所有内置和您可能自定义好instruments。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette.png" alt="img"></p>
<ul>
<li><p>请按如下操作之一：</p>
<ul>
<li><p>在跟踪文档中点击Instrument工具栏上的加号按钮(+)。</p>
</li>
<li><p>选择Window &gt; Library(或按下Command+L)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在模板库中筛选出指定instrument"><a href="#在模板库中筛选出指定instrument" class="headerlink" title="在模板库中筛选出指定instrument"></a>在模板库中筛选出指定instrument</h3><p>模板库列表十分的长，尤其是当您添加过您自己的自定义模板时。请使用位于模板库列表底部的筛选输入框内容来根据名字，描述或者关键字快速查找指定instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_library_palette_filterterm.png" alt="img"></p>
<h3 id="将一个instrument添加到跟踪文档"><a href="#将一个instrument添加到跟踪文档" class="headerlink" title="将一个instrument添加到跟踪文档"></a>将一个instrument添加到跟踪文档</h3><p>无论你创建的跟踪文档是根据模板创建的还是空白的，都能够通过添加新的instruments来扩展其功能。</p>
<ol>
<li><p>打开目标跟踪文档。</p>
</li>
<li><p>显示模板库。</p>
</li>
<li><p>找到所需要的instruments。</p>
</li>
<li><p>将instruments从模板库中拖拽出来添加到跟踪文档中策略窗格里的instrument列表中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_addinstrument.png" alt="img"></p>
</li>
</ol>
<h3 id="在跟踪文档中移除一个instrument"><a href="#在跟踪文档中移除一个instrument" class="headerlink" title="在跟踪文档中移除一个instrument"></a>在跟踪文档中移除一个instrument</h3><p>在您不再需要instruments的时候，你可以轻易的将其从跟踪文档中移除。</p>
<ol>
<li><p>打开您需要的跟踪文档。</p>
</li>
<li><p>在策略窗格的instruments列表中选中您需要删除的instrument。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_selectedinstrument.png" alt="img"></p>
</li>
<li><p>按下delete(删除)键或者选择 Instrument &gt; Delete [Instrument名] Instrument</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_deleteinstrument_menu.png" alt="img"></p>
</li>
<li><p>当出现提示时，点击 ok 确认您真要将instrument移除。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_deleteinstrumentconfirmation_dialog.png" alt="img"></p>
</li>
</ol>
<h3 id="配置instrument的显示设置"><a href="#配置instrument的显示设置" class="headerlink" title="配置instrument的显示设置"></a>配置instrument的显示设置</h3><p>在录制跟踪(trace)时，Instruments会在时间线窗格中展示选中instrument结果的概览并在详情窗格中显示结果详情。这些结果会在不同的instrument之间有所差异。它们可能会包含像概览，调用树和样本列表。通常这里会展示很多的数据，导航会非常耗时。为了帮助您能够快速获取正确的信息，Instruments通常同样的，这也根据Instrument类型不同而有差距)能够让你对其调整，并在时间线窗格和详情窗格中过滤出信息。</p>
<ul>
<li>在时间线中配置显示设置</li>
</ul>
<ol>
<li><p>将鼠标移动到时间线中instrument图标上。如果该仪器支持不同的显示配置，则图标旁边会出现一个指示器</p>
</li>
<li><p>点击图标弹出<a href="https://help.apple.com/instruments/mac/current/#/deva13e2923b" target="_blank" rel="noopener">显示设置框</a>。</p>
</li>
<li><p>选择所需显示配置。时间线会在选择之后更新。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_config_popover.png" alt="A screenshot showing a trace document with the display configuration popover for the activity monitor instrument."></p>
</li>
<li><p>点击弹窗之外的区域来关闭它。</p>
</li>
</ol>
<h3 id="配置详情显示设置"><a href="#配置详情显示设置" class="headerlink" title="配置详情显示设置"></a>配置详情显示设置</h3><ul>
<li><p>使用在详情窗格底部的控件<a href="https://help.apple.com/instruments/mac/current/#/devadf729aef" target="_blank" rel="noopener">筛选和配置栏</a>来配置显示设置。不同instrument之间控件和配置选项会有所差异。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_filter_config_bar.png" alt="A screenshot of the filter and display configuration bar showing the filter field on the left followed by a configuration drop-down, and buttons that show popovers with other display configuration options."></p>
</li>
</ul>
<h2 id="记录，暂停和开始跟踪"><a href="#记录，暂停和开始跟踪" class="headerlink" title="记录，暂停和开始跟踪"></a>记录，暂停和开始跟踪</h2><h3 id="记录跟踪"><a href="#记录跟踪" class="headerlink" title="记录跟踪"></a>记录跟踪</h3><p>当你准备好分析您的 App 时，请开始收集。在收集期间，在跟踪文档中的instruments会根据其配置来监听您的App。当开始收集时，时间线窗格和详情窗格将会更新用以提供展示所捕获的实时数据的视图。</p>
<p>请按如下操作之一进行操作：</p>
<ul>
<li><p>点击在跟踪文档工具栏的收集按钮(<img src="/2021/04/11/Instrument文档翻译/inline_record_button.png" alt="img" style="zoom:50%;">)。</p>
<ul>
<li><p>选择 File &gt; Record Trace(或者按下 Command+R )。</p>
</li>
<li><p>再次按下 Command+R 将会停止收集。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_recordtrace_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="配置收集选项"><a href="#配置收集选项" class="headerlink" title="配置收集选项"></a>配置收集选项</h3><p>在收集选项弹窗选择全局收集选项，例如，将推迟结果处理推迟到开始收集之后和自定义instrument选项，来改善数据收集。</p>
<p>举个例子，你可能会希望调整Time Profiler instrument的样本速率或者使用Allocations instrument分析时放弃事件以释放内存。想如上所述的自定义选项会根据instrument的不同而有差异。很多instruments能控制其本身所生成信息的信息类型。</p>
<ul>
<li><p>配置全局收集选项</p>
<ol>
<li><p>选择 File &gt; Recording Options 来打开录制选项弹窗。</p>
<p><img src="/2021/04/11/Instrument文档翻译/FAB7CADB-6C17-439F-8811-CF7511D35243.png" alt="FAB7CADB-6C17-439F-8811-CF7511D35243"></p>
</li>
<li><p>点击 Global options 。</p>
</li>
<li><p>自定义所需选项。</p>
<p>选项包括：</p>
<p>Time limit:instruments收集数据的时间数值的最大值，以秒为单位。</p>
<p>Window limit:保存数据的最长时间，以秒为单位。如果录制超过了你作为window limit定义的时间(举个例子，长于四秒)，只有所用时长的最后四秒的数据才会被保存。</p>
<p>Deferred mode:选择以在数据收集完毕之后延迟数据分析。它能带来更快更精准的数据集合，因为更多系统资源被直接记录的过程。在数据收集期间在时间线和详情窗格不会有数据显示。</p>
</li>
<li><p>点击关闭或者录制按钮来保存选项。</p>
<p>点击录制按钮来使用新的选项开始跟踪。</p>
</li>
</ol>
</li>
</ul>
<h3 id="暂停跟踪"><a href="#暂停跟踪" class="headerlink" title="暂停跟踪"></a>暂停跟踪</h3><p>如果需要的话你可以暂停跟踪，并在之后继续。</p>
<p>注意:当收集暂停时，被暂停的App不会响应输入。</p>
<ul>
<li><p>按如下之一进行操作：</p>
<ul>
<li>在跟踪文档的工具栏按下暂停按钮(<img src="/2021/04/11/Instrument文档翻译/pause.png" alt="img" style="zoom:60%;">)。</li>
<li>选择 File &gt; Pause Trace(或按下Shift+Command+R))。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/11ACD438-6F73-4A25-A067-0E5099AB9423.png" alt="11ACD438-6F73-4A25-A067-0E5099AB9423"></p>
</li>
</ul>
<h3 id="停止跟踪"><a href="#停止跟踪" class="headerlink" title="停止跟踪"></a>停止跟踪</h3><p>在你已经搜集到了你想要的数据之后，停止收集来让你能够开始对所收集的数据进行分析。</p>
<ul>
<li><p>按如下之一操作进行:    </p>
<ul>
<li><p>在跟踪文档的工具栏上按下停止按钮<img src="/2021/04/11/Instrument文档翻译/inline_stop_button.png" alt="img" style="zoom:67%;">。</p>
</li>
<li><p>选择 File &gt; Stop Trace (或者按下Command-R)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_stoptrace_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在-Xcode-构建和产品菜单中分析您的-App"><a href="#在-Xcode-构建和产品菜单中分析您的-App" class="headerlink" title="在 Xcode 构建和产品菜单中分析您的 App"></a>在 Xcode 构建和产品菜单中分析您的 App</h3><p>Xcode 构建菜单允许您对您的 app 进行运行、测试和分析等操作。它同样也可以使用instruments分析您的 App。</p>
<ol>
<li><p>在 Xcode 中打开项目。</p>
</li>
<li><p>进行如下之一操作：</p>
<ul>
<li><p>在Xcode 主页面中点击并长按构建按钮，并在出现的菜单中选择Profile。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_toolbar_build_menu_profile_option.png" alt="img"></p>
</li>
<li><p>选择 Product &gt; Profile (或按下Command-I)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_product_menu_profile_menu.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
<p>Instruments启动并出现模板选择提示框。注意此时您的 app 会在自动在设备和进程列表中被选中。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_profiling_template_window_initiatedbyxcode.png" alt="img"></p>
<h3 id="在-Xcode-构建和产品菜单中启动分析时使用默认模板"><a href="#在-Xcode-构建和产品菜单中启动分析时使用默认模板" class="headerlink" title="在 Xcode 构建和产品菜单中启动分析时使用默认模板"></a>在 Xcode 构建和产品菜单中启动分析时使用默认模板</h3><p>如果你经常需要使用同一个模板来分析您的 App，你可以对 Xcode 项目进行设置，并让其在启动分析时使用指定模板。</p>
<ol>
<li>启动 Xcode 并开启您的项目。</li>
<li>进行如下操作之一来打开计划编辑弹窗：</li>
</ol>
<ul>
<li><p>选中在 Xcode 主页面工具栏设备目标列表中的Edit Scheme。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_targetdevice_list_editscheme_option.png" alt="img"></p>
</li>
<li><p>选择 Product &gt; Scheme &gt; Edit Scheme 或按下 Command + (小于号)&lt;。</p>
</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_product_menu_editscheme_menu.png" alt="img"></p>
<ol>
<li>在编辑弹窗的侧边栏中选择 profile。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_scheme_editor_dialog_sidebar_profile_option.png" alt="img"></p>
<ol>
<li>在Instrument下出现的菜单中选择你需要的模板。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_scheme_editor_dialog_profile_option_instrument_popup.png" alt="img"></p>
<ol>
<li><p>点击 close。</p>
</li>
<li><p>启动分析。请查看 在<a href="https://help.apple.com/instruments/mac/current/#/dev54a36a4b" target="_blank" rel="noopener">Xcode 构建和产品菜单中分析您的 App</a>。</p>
<p>Xcode 构建您的项目，Instruments启动并以scheme editor中配置过的模板开始分析您的App。</p>
</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_activitymonitorprofilingfromxcode.png" alt="img"></p>
<h3 id="debug时从-Xcode-仪器中分析"><a href="#debug时从-Xcode-仪器中分析" class="headerlink" title="debug时从 Xcode 仪器中分析"></a>debug时从 Xcode 仪器中分析</h3><p>当您测试和 debug App 的时候，Xcode debug 导航区中包含了一些列仪表来监视您的 App。这些仪表监视多种元素，包括 CPU 使用量，内存和电量消耗，这些能够提示你影响性能，能量消耗等潜在问题。如果您在测试应用时发现希望进一步调查的趋势，则可以将监控转换为仪器以进行更详细的分析。</p>
<ol>
<li><p>打开一个 App 项目并运行。</p>
</li>
<li><p>当你App 已经运行，使用如下操作之一来显示debug 导航区：</p>
<ul>
<li><p>在导航栏的选择栏中选择 Debug 导航按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_navigatorselector_bar_debugnaviagator_button.png" alt="img"></p>
</li>
<li><p>选择View &gt; Navigators &gt; Show Debug Navigator (或按下 Command + 6)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_view_menu_debugnavigator_menu.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>在 debug 导航区中点击需要的仪器。</p>
</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_debug_navigator_selectedgauge.png" alt="img"></p>
<ol>
<li><p>在主编辑区中点击仪器的 Profile in Instruments 按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_gauge_profileininstruments_button.png" alt="img"></p>
<p>注意：并不是每个仪器都拥有 Profile in Instruments 按钮。举个例子，Energy Impact 仪器拥有一系列按钮来初始化不同的 Instruments 。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_timeprofiler_gauge_profileininstruments_button.png" alt="img"></p>
</li>
<li><p>当如下提示出现，选择是将应用当前运行的实例转移到仪器上，还是停止应用，然后用仪器启动新的实例。</p>
<p><img src="/2021/04/11/Instrument文档翻译/xcode_profileininstrruments_alert.png" alt="img"></p>
<p>在这两种情况下，请注意 Xcode 停止分析您的应用、启动文书并启动分析。如果您选择transfer，仪器将以当前状态开始分析应用。</p>
</li>
</ol>
<h3 id="在-Dock-中启动分析"><a href="#在-Dock-中启动分析" class="headerlink" title="在 Dock 中启动分析"></a>在 Dock 中启动分析</h3><p>你能够通过触发在Dock上的Instruments App 图标中的Time Profiler来后台自动录制确切的事件。</p>
<p>在 Dock 收集 Time Profiler 数据。</p>
<ol>
<li><p>Instruments打开后，右键 Dock 上的Instruments图标。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_app_icon_small.png" alt="img"></p>
</li>
<li><p>在出现的菜单中选择您需要开始分析的进程。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_dock_menu.png" alt="img"></p>
<p>选项包括：</p>
<ul>
<li><em>System Time Profile</em>：开始分析所有系统进程。</li>
<li><em>Time Profile Specific Process</em>：在子菜单中选择指定的进程开始Time Profiler instrument。</li>
<li><em>Automatically Time Profile Spinning Applications</em>：自动分析在未来被阻隔的App。</li>
<li><em>Allow Tracing of Any Process (10 hours)</em>：在接下来的十小时内跟踪任意进程，在此十小时内需要绕过密码进入。</li>
</ul>
</li>
</ol>
<p>注意：以这种方式记录的数据以 .dtps 格式保存到  ~/Library/Application Support/Instruments/Unimported/.。</p>
<h3 id="使用instruments命令行工具启动分析"><a href="#使用instruments命令行工具启动分析" class="headerlink" title="使用instruments命令行工具启动分析"></a>使用instruments命令行工具启动分析</h3><p>使用仪器命令行工具使用指定的模板来描述应用，而无需启动仪器。在分析过程中收集的数据保存在 .trace 文件中到指定目录中。分析完成后，您可以使用仪器打开记录的数据文件，查看数据的可视化表示。</p>
<ol>
<li><p>打开在 /Applications/Utilities. 中的终端。</p>
</li>
<li><p>输入一个 instruments 命令来收集数据。</p>
<p>举个例子，以下命令配置了带有分配模板的应用，并将结果保存到.trace文件中的桌面。</p>
<p><code>instruments -t &quot;Allocations&quot; -D ~/Desktop/*YourTraceFileName*.trace *PathToYourApp*</code></p>
</li>
<li><p>打开 Instruments ，并选择File &gt; Open。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_fileopen_menu.png" alt="img"></p>
</li>
<li><p>找到你保存的 .trace 文件，并打开。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_opentracefile_dialog.png" alt="img"></p>
</li>
</ol>
<p>打开保存的文件后，仪器会自动将相关文书添加到跟踪文档中，并将它们填充到收集的数据中。您可以查看和分析数据，以便查找应用的任何问题。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_loadedtrace_file.png" alt="img"></p>
<p><strong>instruments</strong>选项</p>
<p>instruments提供了以下一组配置选项，用于定义要收集的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Configuration option</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-t template</code></td>
<td style="text-align:left">分析 App 时，所要用到的模板名字或者是模板路径。</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code></td>
<td style="text-align:left">返回所有已安装的模板的列表。</td>
</tr>
<tr>
<td style="text-align:left"><code>-D document</code></td>
<td style="text-align:left">.trace 文档的保存路径。如果路径已存在，则新数据会覆盖旧数据。</td>
</tr>
<tr>
<td style="text-align:left"><code>-l #</code></td>
<td style="text-align:left">指定收集的时间，以毫秒为单位。如果不提供则会无限录制下去，知道 App 被手动终止。</td>
</tr>
<tr>
<td style="text-align:left"><code>-i #</code></td>
<td style="text-align:left">被用于录制的 instrument 的索引。</td>
</tr>
<tr>
<td style="text-align:left"><code>-p pid</code></td>
<td style="text-align:left">需要被收集的 App 的进程 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>application</code></td>
<td style="text-align:left">需要被收集的 App 的路径。</td>
</tr>
<tr>
<td style="text-align:left"><code>-w hardware device</code></td>
<td style="text-align:left">需要被设为目标的设备的 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>-e variable value</code></td>
<td style="text-align:left">在分析时需要被应用的一个环境变量。</td>
</tr>
<tr>
<td style="text-align:left"><code>argument</code></td>
<td style="text-align:left">要传递到正在配置的应用程序的命令行参数。如果需要，可以指定多个参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>-v</code></td>
<td style="text-align:left">在分析时启用详细的日志记录。</td>
</tr>
</tbody>
</table>
<h3 id="延时启动分析"><a href="#延时启动分析" class="headerlink" title="延时启动分析"></a>延时启动分析</h3><p>对于特长的跟踪，延迟模式造成的延迟可能非常显著。仅为需要极其精确的数据收集的痕迹设置延期模式，从而避免此延迟。</p>
<ol>
<li><p>选择 File &gt; Recording Options。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_recordoptions_menu.png" alt="img"></p>
</li>
<li><p>在出现的弹窗中选择Deferred Mode 复选框接着按下 OK。</p>
<p>如果在Instruments设置中中启用”始终使用递延模式”，则此选项将禁用。</p>
</li>
</ol>
<p>通过将数据分析推迟到退出正在测试的应用之前，提高性能相关数据的准确性。通常，仪器会在应用运行时分析和显示数据，从而允许您在收集数据时查看数据。通过占用 CPU 时间和内存进行实时分析会减慢目标过程，从而获得可能无法反映该过程通常表现的测量结果。在延期模式下运行文书会延迟数据分析，直到数据收集完成，无论是在应用完成运行后还是在单击”停止”之后。在延期模式下，您被阻止与正在收集数据的仪器交互。</p>
<p>在延期模式下，仪器完成数据收集后，仪器处理数据并将其显示在屏幕上。延迟数据分析为数据收集过程的后期阶段增加了时间，但它有助于确保与性能相关的数据准确无误。</p>
<h3 id="在延迟模式下启动Instruments"><a href="#在延迟模式下启动Instruments" class="headerlink" title="在延迟模式下启动Instruments"></a>在延迟模式下启动Instruments</h3><p>通过将数据分析推迟到退出正在测试的应用之前，提高性能相关数据的准确性。通常，仪器会在应用运行时分析和显示数据，从而允许您在收集数据时查看数据。通过占用 CPU 时间和内存进行实时分析会减慢目标过程，从而获得可能无法反映该过程通常表现的测量结果。在延期模式下运行文书会延迟数据分析，直到数据收集完成，无论是在应用完成运行后还是在单击”停止”之后。在延期模式下，您被阻止与正在收集数据的仪器交互。</p>
<ol>
<li><p>选择Instruments &gt; Preferences。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_preferences_menu.png" alt="img"></p>
</li>
<li><p>在录制窗格中，选择 Always use deferred mode 复选框。</p>
<p><img src="https://help.apple.com/instruments/mac/current/en.lproj/Art/instruments_prefs_recording_deferred_option.png" alt="img"></p>
</li>
</ol>
<p>在延期模式下，仪器完成数据收集后，仪器处理数据并将其显示在屏幕上。延迟数据分析为数据收集过程的后期阶段增加了时间，但它有助于确保与性能相关的数据准确无误。</p>
<h2 id="导航所收集的数据"><a href="#导航所收集的数据" class="headerlink" title="导航所收集的数据"></a>导航所收集的数据</h2><h3 id="在时间线窗格中放大或者缩小"><a href="#在时间线窗格中放大或者缩小" class="headerlink" title="在时间线窗格中放大或者缩小"></a>在时间线窗格中放大或者缩小</h3><p>如果你使用跟踪文档收集了很多的数据，你可以对在详情窗格中的详情数据的显示区域进行扩大或者缩小，这样你能够专注于指定数据的子集。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_zooming.png" alt="img"></p>
<h4 id="扩大或者缩小您的数据"><a href="#扩大或者缩小您的数据" class="headerlink" title="扩大或者缩小您的数据"></a>扩大或者缩小您的数据</h4><ul>
<li>进行如下之一的操作<ul>
<li>捏住触控板选择放大或者缩小。</li>
<li>滑动鼠标滚轮同时按下Option 按键并将鼠标指向跟踪视图上，来放大。</li>
<li>按下Option按键并拖动您希望分离出的数据，来放大。</li>
<li>按下Control按键并拖动数据来缩小。</li>
</ul>
</li>
</ul>
<h4 id="选中所有在时间线窗格中的数据"><a href="#选中所有在时间线窗格中的数据" class="headerlink" title="选中所有在时间线窗格中的数据"></a>选中所有在时间线窗格中的数据</h4><ul>
<li><p>选择 view > Snap Track To Fit (或者按下 Control-Command-Z)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_snaptracktofit_menuitem.png" alt="img">、</p>
</li>
</ul>
<h4 id="增加在时间线窗格中显示的数据"><a href="#增加在时间线窗格中显示的数据" class="headerlink" title="增加在时间线窗格中显示的数据"></a>增加在时间线窗格中显示的数据</h4><ul>
<li><p>选择 View &gt; Increase Deck Size (或者按下 Command+加号)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_increasedecksize_menuitem.png" alt="img"></p>
<p>instrument当前所选中的跟踪增加了高度，这能让你查看的更加详细。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_largertrack.png" alt="img"></p>
</li>
</ul>
<h4 id="减少在时间线窗格中显示的数据"><a href="#减少在时间线窗格中显示的数据" class="headerlink" title="减少在时间线窗格中显示的数据"></a>减少在时间线窗格中显示的数据</h4><ul>
<li>选择View &gt; Decrease Deck Size (或者按下 Command+减号)。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_view_menu_decreasedecksize_menuitem.png" alt="img"></p>
<p>instrument当前所选中的跟踪减少了高度。</p>
<h3 id="在详情窗格中筛选一段数据"><a href="#在详情窗格中筛选一段数据" class="headerlink" title="在详情窗格中筛选一段数据"></a>在详情窗格中筛选一段数据</h3><p>Instruments会收集大量数据用于分析。您可以通过设置详情窗格只显示指定时间段的事件来快速筛选数据。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_selectedrange.png" alt="img"></p>
<h4 id="选择时间区域用于查看"><a href="#选择时间区域用于查看" class="headerlink" title="选择时间区域用于查看"></a>选择时间区域用于查看</h4><ul>
<li>在不使用任何按键的情况下拖动部分数据。只有您拖动的数据才会显示。</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_selectingrange.png" alt="img"></p>
<p>在Instruments中时间线窗格高亮部分的内容，都是您指定的范围。</p>
<h4 id="清除所选区域"><a href="#清除所选区域" class="headerlink" title="清除所选区域"></a>清除所选区域</h4><ul>
<li>进行如下操作期中之一：<ul>
<li>点击时间线窗格中所选区域以外。</li>
<li>选择 View &gt; Clear Inspection Range 。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_clearinspectionrange_menu.png" alt="img"></p>
<h3 id="在时间线窗格中设置标记"><a href="#在时间线窗格中设置标记" class="headerlink" title="在时间线窗格中设置标记"></a>在时间线窗格中设置标记</h3><p>标记让你能够快速的在时间线窗格中访问点。你能够为每个标记都添加名字和描述。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_trace_document_timeline_pane_flags.png" alt="img"></p>
<ul>
<li><p>在时间线窗格中的当前位置设置一个标记</p>
<ul>
<li><p>选择 Edit &gt; Add Flag  (或者按下 Command + ↓)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_addflag_menu.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>在时间线标记中导航</p>
<ol>
<li><p>选择 Window &gt; Manage Flags (或按下 Shift-Command-T )来显示标记面板。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_manageflags_menu.png" alt="img"></p>
</li>
<li><p>点击标记面板中的一个标记来导航到时间线窗格。</p>
</li>
</ol>
</li>
<li><p>删除标记</p>
<ul>
<li>将标记点拖拽出时间线导航栏。</li>
</ul>
</li>
<li><p>隐藏标记点</p>
<ol>
<li><p>选择 Window &gt; Manage Flags (或按下 Shift-Command-T)来显示标记面板。</p>
</li>
<li><p>在标记面板中反选标记边上的复选框来隐藏时间线窗格中的标记点。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_flags_palette_disabledflag.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
<h3 id="固定和取消固定时间线"><a href="#固定和取消固定时间线" class="headerlink" title="固定和取消固定时间线"></a>固定和取消固定时间线</h3><ul>
<li><p>固定时间线</p>
<ol>
<li><p>如果目标时间线未选中，将鼠标移动到该时间线的左侧。</p>
</li>
<li><p>点击加号按钮 (<img src="/2021/04/11/Instrument文档翻译/pin_add_button.png" alt="img" style="zoom:67%;">)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/timeline_pin_add.png" alt="Screenshot showing the timeline pane with the mouse over the Frames Per Second instrument that shows the pin button."></p>
</li>
</ol>
</li>
<li><p>取消固定时间线</p>
<p><img src="/2021/04/11/Instrument文档翻译/timeline_pin_delete.png" alt="Screenshot showing the timeline pane with the mouse over the pinned Frames Per Second instrument that shows the unpin button"></p>
</li>
</ul>
<h3 id="在详情窗格中查看不同类型的数据"><a href="#在详情窗格中查看不同类型的数据" class="headerlink" title="在详情窗格中查看不同类型的数据"></a>在详情窗格中查看不同类型的数据</h3><p>在一些instruments中你可以在详情窗格中展示多种格式的数据。举个例子，在Activity Monitor中，你可以查看到数据概览，父子信息和一些样本的列表。</p>
<ul>
<li><p>对详情窗格中导航栏列表里的详情列表类型选择合适的模式。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_detailtypelist.png" alt="img"></p>
<p>instrument支持哪种数据要依赖于instrument所收集到的数据的类型。</p>
<p>对于一些详情类型，像 Allocations 称为 call tree 模式，你可以使用确切详情窗格中的下箭头来进一步深入到与其相对应的层级中。点击三角形会展开或者收起行信息。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_calltreeexpanded.png" alt="img"></p>
<p>提示：按住option并点击三角形来递归展开到当前行的子节点发生数据更改的位置。按住Shift-Option点击左键来展开当前行的所有字节点。</p>
<p>当查看调用树时(call tree)，多数instruments都包含 hide system calls 和 invert the call tree选项。这些选项在inspector窗格的显示设置中的调用树区域(call tree area)可以找到。Hiding system calls能够让你快速筛选出您 App 中的调用方法。Inverting the call tree 能够让你最先查看到最后的调用。</p>
</li>
</ul>
<h3 id="使用额外详情区域"><a href="#使用额外详情区域" class="headerlink" title="使用额外详情区域"></a>使用额外详情区域</h3><p>对于一些instruments，其检查区域中的额外详情区域能够展示在当前详情窗格中所选中条目的额外信息。这些额外的详情信息可以包括一些结果的描述或者是被记录的事件或调用跟踪和信息被记录的时间或者是其他信息。</p>
<ul>
<li><p>请按如下操作之一进行操作：</p>
<ul>
<li><p>选择 View &gt; Inspectors &gt; Show Extended Detail or Hide Extended Detail (或按下 Command - 1)。</p>
</li>
<li><p>点击指示器窗格顶部的额外详情按钮 (<img src="/2021/04/11/Instrument文档翻译/instruments_extendeddetail_button_inline.png" alt="img" style="zoom:67%;">)。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_inspector_pane_navigation_bar.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<p>你可以通过点击额外详情区域中栈跟踪区域顶部的折叠按钮<img src="/2021/04/11/Instrument文档翻译/inline_hidesystemcalls_button.png" alt="img" style="zoom:67%;"> 来隐藏系统调用方法。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_extendeddetail_pane_hiddensystemcalls.png" alt="Hiding system calls in the extended detail area of the inspector pane"></p>
<h3 id="访问多次运行的跟踪数据"><a href="#访问多次运行的跟踪数据" class="headerlink" title="访问多次运行的跟踪数据"></a>访问多次运行的跟踪数据</h3><p>一个跟踪文档能够为你的 app 收集多次运行的数据。这样做时，这并不会抛弃之前所收集的数据。在工具栏的活动区域(Activity area)展示出总共运行的次数，当前运行，和当前运行的时间。更改当前运行会为trace document中每一个instrument更新为当前运行的数据。数据只会在跟踪文档选中的运行期间的instruments展示。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_strategy_pane_multipleruns.png" alt="img"></p>
<ul>
<li>移动到下一次运行<ul>
<li>选择 Instrument &gt; Next Run ，点击在活动区域顶部工具栏中的 Previous Run 按钮或者按下 Command + {。</li>
</ul>
</li>
<li>移动到之前的运行<ul>
<li>选择 Instrument &gt; Previous Run ，点击在活动区域顶部工具栏中的 Next Run 按钮或者按下 Command + }。</li>
</ul>
</li>
</ul>
<h3 id="在Instruments中访问源代码"><a href="#在Instruments中访问源代码" class="headerlink" title="在Instruments中访问源代码"></a>在Instruments中访问源代码</h3><p>如果您拥有的 Xcode 项目源代码能够列出跟踪栈中的符号，Instruments能够打开 Xcode ，以便你能够对其进行任何所需的更改。</p>
<ol>
<li>在详情窗格中找到您代码的图标(<img src="/2021/04/11/Instrument文档翻译/inline_usercode_icon.png" alt="img" style="zoom:67%;">表示用户)。</li>
<li>右键条目，并在所出现的弹窗中选择 Reveal in Xcode 。</li>
</ol>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_detail_pane_usersourcecode_popover.png" alt="Screenshot showing the popover for opening the user symbol in Xcode"></p>
<p>为了更轻松地查找代码符号，您可以通过展示窗口底部的<a href="https://help.apple.com/instruments/mac/current/#/devadf729aef" target="_blank" rel="noopener">筛选和配置栏</a>中 instrument 的显示设置来从系统库中筛选出符号。</p>
<h2 id="配置instruments"><a href="#配置instruments" class="headerlink" title="配置instruments"></a>配置instruments</h2><h3 id="将数据映射到源码中"><a href="#将数据映射到源码中" class="headerlink" title="将数据映射到源码中"></a>将数据映射到源码中</h3><p>Instruments需要关于您项目的精确信息以提供最棒的结果。如果系统能够查看所有与您项目相关的符号你可以获取最完整的数据。在跟踪文档通过Instruments分析工具所产生而显示的是地址而非符号时，你可以手动提供缺失信息。地址所对应的符号被包含在dSYM文件中。通常Instruments会通过你在Instruments偏好设置中指定的路径索引来自动寻找dSYM文件。然而，您可以在Instruments无法自动找到 dSYM时指定其正确的路径。一旦您这样做了，Instruments能将地址映射到其相关联的符号和行信息。</p>
<h4 id="为跟踪文档查找dSYM路径"><a href="#为跟踪文档查找dSYM路径" class="headerlink" title="为跟踪文档查找dSYM路径"></a>为跟踪文档查找dSYM路径</h4><ol>
<li><p>选择 File &gt; Symbols 。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_file_menu_symbols_menuitem.png" alt="img"></p>
<p>这个选项只有在运行了一个跟踪或者载入之前运行的跟踪结果时才会出现。</p>
</li>
<li><p>选择缺失符号的可执行的库或者框架。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_symbols_dialog_binaries.png" alt="img"></p>
</li>
<li><p>点击查找按钮。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_symbols_dialog_locatedysmpath_button.png" alt="img"></p>
</li>
<li><p>在出现的弹窗中选择您的符号或者包含它的文件夹。</p>
</li>
<li><p>点击 open。</p>
</li>
</ol>
<p>为了在跟踪文档中正确显示符号，Instruments需要访问指定符号文件，这个符号文件是在您测试的可执行文件构建之后生成的。因此当您在一台电脑上构建并在另一台电脑上测试性能时，您可能需要手动查找dSYM文件。</p>
<p>在符号弹窗中的筛选栏能让你通过可执行文件、不完整的二进制文件和框架中筛选。同样您也能够通过在搜索框中输入文本来搜索特定的二进制或框架。</p>
<p>注意：默认情况下，Xcode会在构建路径中将symbols保存为dSYM文件。Xcode 通过将扩展添加到可执行名称创建默认的 dSYM 捆绑路径。为了在 Xcode 中创建dSYM文件，进入您项目中的Build Settings(构建设置)，然后选中在Build Options栏中的 Debug Information Format &gt; Dwarf with dSYM File 。</p>
<p>注意：通常，当显示的不是符号而是地址而，地址以黑色显示在左边，在细节窗格中以灰色显示库。您可以通过定位适当的 dSYM 文件来识别这些地址。</p>
<p>如果地址为灰色且未列出拥有库，则无法显示符号名称。没有库名称的灰色地址意味着在记录跟踪时，您无权查看有关该过程的信息。这通常发生在构建设置中的代码签名标识设置为发布生成的发布/分发标识时。您的发布生成应使用与调试生成相同的设置（通常为”iOS 开发人员”）。</p>
<h3 id="设置通用选项"><a href="#设置通用选项" class="headerlink" title="设置通用选项"></a>设置通用选项</h3><p>使用在选项窗口中的通用窗格来配置Instruments的类似启动选项，键盘快捷键和警告选项等基础行为。</p>
<p>选择 Instruments &gt; Preferences 并点击 General。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_general.png" alt="img"></p>
<p>你能够设置如下选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Compress run data</td>
<td style="text-align:left">将每次运行都以 zip 格式保存</td>
</tr>
<tr>
<td style="text-align:left">Enforce initial deck height</td>
<td style="text-align:left">当instrument文档被重新加载并使用模板默认高度时可以防止回复自定义高度。取消选择时，保存并回复当前高度。</td>
</tr>
<tr>
<td style="text-align:left">Sort process lists by identifier</td>
<td style="text-align:left">对所有Instruments App 列表内容以进程 ID 排序。当未选中时，默认以字母排列。</td>
</tr>
<tr>
<td style="text-align:left">Always snap track to fit at end of run</td>
<td style="text-align:left">在运行结束时自动将跟踪缩放到跟踪文档中，以适应窗口中的所有数据。</td>
</tr>
<tr>
<td style="text-align:left">Reset “Don’t Ask Me” Warnings</td>
<td style="text-align:left">重新发布对话警告您以前选择不显示。文书有几个警告对话框，您可以通过在对话框中选择”不要再次显示此消息”复选框来禁用这些对话框。要重新发布所有这些警告对话，请单击重置”不要问我”警告按钮。</td>
</tr>
</tbody>
</table>
<h3 id="设置收集选项"><a href="#设置收集选项" class="headerlink" title="设置收集选项"></a>设置收集选项</h3><p>使用在选项窗口中的 Recording 窗格来配置跟踪在跟踪文档中显示的样式。</p>
<ul>
<li><p>选择 Instruments &gt; Preferences 并点击 Recording。</p>
<p><img src="/2021/04/11/Instrument文档翻译/instruments_prefs_recording.png" alt="img"></p>
</li>
</ul>
<p>你能够配置如下选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Recording location</td>
<td style="text-align:left">为新创建的Instruments 文档指定一个位置。默认是一个临时的路径。在这个弹出菜单中自定义一个不同的路径。</td>
</tr>
<tr>
<td style="text-align:left">Background sampling duration</td>
<td style="text-align:left">Sets the length of a sample trace operating in the background. Type a numeric value in the field. Defaults to 5 seconds.</td>
</tr>
<tr>
<td style="text-align:left">Global keyboard shortcuts</td>
<td style="text-align:left">Opens the Keyboard &gt; Shortcuts &gt; Services pane in the System Preferences app, as shown in the Keyboard &gt; Shortcuts &gt; Services pane in System Preferences. From here, you can assign keyboard shortcuts to development services, such as a service that automatically opens an Xcode project in Instruments and profiles it with the System Trace profiling template.</td>
</tr>
<tr>
<td style="text-align:left">Always use deferred mode</td>
<td style="text-align:left">Performs data analysis for all traces after data collection is complete.</td>
</tr>
<tr>
<td style="text-align:left">Automatically time profile spinning applications</td>
<td style="text-align:left">Automatically monitors for a spinning process while a trace is recorded. This can be a process other than the one being recorded. If detected, Instruments starts the Time Profiler instrument on the spinning process.</td>
</tr>
<tr>
<td style="text-align:left">DTrace max buffer size</td>
<td style="text-align:left">Sets the size of the DTrace kernel buffer (in megabytes). The default is 25 MB.</td>
</tr>
<tr>
<td style="text-align:left">DTrace max backtrace depth</td>
<td style="text-align:left">Sets the maximum stack depth that is captured when using a DTrace instrument. The default is 128 frames.</td>
</tr>
<tr>
<td style="text-align:left">Permit zero match probes</td>
<td style="text-align:left">Prevents an error when a specified DTrace probe is not found.</td>
</tr>
<tr>
<td style="text-align:left">Preserve intermediate files</td>
<td style="text-align:left">Prevents Instruments from removing intermediate DTrace data output files from the disk.</td>
</tr>
<tr>
<td style="text-align:left">Flag runtime messages</td>
<td style="text-align:left">Adds flags to the timeline for DTrace runtime status and error messages encountered during a recording.</td>
</tr>
</tbody>
</table>
<p>参考资料</p>
<blockquote>
<p>Instruments Help:<a href="https://help.apple.com/instruments/mac/current/#/dev7b09c84f5" target="_blank" rel="noopener">https://help.apple.com/instruments/mac/current/#/dev7b09c84f5</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>MTQQ 介绍</title>
    <url>/2018/12/16/MTQQ-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>原文出处:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
<p>本文只为自己快速查看资料，原文出处如上。</p>
</blockquote>
<h2 id="2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet"><a href="#2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet" class="headerlink" title="2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet"></a>2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet</h2><h5 id="MQTT控制报文的结构"><a href="#MQTT控制报文的结构" class="headerlink" title="MQTT控制报文的结构"></a>MQTT控制报文的结构</h5><table>
<thead>
<tr>
<th>Fixed header</th>
<th>固定报头，所有控制报文都包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable header</td>
<td>可变报头，部分控制报文包含</td>
</tr>
<tr>
<td>Payload</td>
<td>有效载荷，部分控制报文包含</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="2-2-固定报头-Fixed-header"><a href="#2-2-固定报头-Fixed-header" class="headerlink" title="2.2 固定报头 Fixed header"></a>2.2 固定报头 Fixed header</h2><h5 id="固定报头的格式"><a href="#固定报头的格式" class="headerlink" title="固定报头的格式"></a>固定报头的格式</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT控制报文的类型</center></td><br>        <td colspan="4"><center>用于指定控制报文类型的标志位</center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type"><a href="#2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type" class="headerlink" title="2.2.1 MQTT控制报文的类型 MQTT Control Packet type"></a>2.2.1 MQTT控制报文的类型 MQTT Control Packet type</h3><h5 id="控制报文的类型"><a href="#控制报文的类型" class="headerlink" title="控制报文的类型"></a>控制报文的类型</h5><table>
<thead>
<tr>
<th><strong>名字</strong></th>
<th><strong>值</strong></th>
<th><strong>报文流动方向</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>0</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
<tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端请求连接服务端</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>服务端到客户端</td>
<td style="text-align:left">连接报文确认</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布消息</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 1消息发布收到确认</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布收到（保证交付第一步）</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>两个方向都允许</td>
<td style="text-align:left">发布释放（保证交付第二步）</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>两个方向都允许</td>
<td style="text-align:left">QoS 2消息发布完成（保证交互第三步）</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端订阅请求</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>服务端到客户端</td>
<td style="text-align:left">订阅请求报文确认</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端取消订阅请求</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>服务端到客户端</td>
<td style="text-align:left">取消订阅报文确认</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>客户端到服务端</td>
<td style="text-align:left">心跳请求</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>服务端到客户端</td>
<td style="text-align:left">心跳响应</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端到服务端</td>
<td style="text-align:left">客户端断开连接</td>
</tr>
<tr>
<td>Reserved</td>
<td>15</td>
<td>禁止</td>
<td style="text-align:left">保留</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-标志-Flags"><a href="#2-2-2-标志-Flags" class="headerlink" title="2.2.2 标志 Flags"></a>2.2.2 标志 Flags</h3><h5 id="标志位-Flag-Bits"><a href="#标志位-Flag-Bits" class="headerlink" title="标志位 Flag Bits"></a>标志位 Flag Bits</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>固定报头标志</strong></th>
<th><strong>Bit 3</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>Bit 0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>CONNACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>Used in MQTT 3.1.1</td>
<td>DUP1</td>
<td>QoS2</td>
<td>QoS2</td>
<td>RETAIN3</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREC</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PUBREL</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>SUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>Reserved</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li>DUP1 =控制报文的重复分发标志</li>
<li>QoS2 = PUBLISH报文的服务质量等级</li>
<li>RETAIN3 = PUBLISH报文的保留标志</li>
</ul>
<h3 id="2-2-3-剩余长度-Remaining-Length"><a href="#2-2-3-剩余长度-Remaining-Length" class="headerlink" title="2.2.3 剩余长度 Remaining Length"></a>2.2.3 剩余长度 Remaining Length</h3><p>剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
<p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个<em>延续位（continuation bit）</em>。剩余长度字段最大4个字节。</p>
<blockquote>
<p>  <strong>非规范评注</strong></p>
<p>例如，十进制数64会被编码为一个字节，数值是64，十六进制表示为0x40,。十进制数字321(=65+2*128)被编码为两个字节，最低有效位在前。第一个字节是 65+128=193。注意最高位为1表示后面至少还有一个字节。第二个字节是2。</p>
<p><strong>非规范评注</strong></p>
<p>这允许应用发送最大256MB(268,435,455)大小的控制报文。这个数值在报文中的表示是：0xFF,0xFF,0xFF,0x7F。</p>
<p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.4_Size" target="_blank" rel="noopener">表格 2.4剩余长度字段的大小</a>展示了剩余长度字段所表示的值随字节增长。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/<span class="regexp">/ 最大四个字节，所以理论上最大控制报文大小是2^(4*8) = 4.294967e+9 bits，并且剩余长度字段最大四个字节，若是数据到达四个字节，则低字节的最高位则应该为0,此时表示无更多字节，所以实际上是(2^(4*8) /</span> <span class="number">2</span> = <span class="number">256</span> MB)。</span><br></pre></td></tr></table></figure>
<h5 id="表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field"><a href="#表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field" class="headerlink" title="表格 2.4剩余长度字段的大小 Size of Remaining Length field"></a>表格 2.4剩余长度字段的大小 Size of Remaining Length field</h5><table>
<thead>
<tr>
<th><strong>字节数</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0 (0x00)</td>
<td>127 (0x7F)</td>
</tr>
<tr>
<td>2</td>
<td>128 (0x80, 0x01)</td>
<td>16 383 (0xFF, 0x7F)</td>
</tr>
<tr>
<td>3</td>
<td>16 384 (0x80, 0x80, 0x01)</td>
<td>2 097 151 (0xFF, 0xFF, 0x7F)</td>
</tr>
<tr>
<td>4</td>
<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>
<td>268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td>
</tr>
</tbody>
</table>
<p>分别表示（每个字节的低7位用于编码数据，最高位是标志位）：</p>
<ul>
<li>1个字节时，从0(0x00)到127(0x7f)</li>
<li>2个字节时，从128(0x80,0x01)到16383(0Xff,0x7f)</li>
<li>3个字节时，从16384(0x80,0x80,0x01)到2097151(0xFF,0xFF,0x7F)</li>
<li>4个字节时，从2097152(0x80,0x80,0x80,0x01)到268435455(0xFF,0xFF,0xFF,0x7F)</li>
</ul>
<h2 id="2-3-可变报头-Variable-header"><a href="#2-3-可变报头-Variable-header" class="headerlink" title="2.3 可变报头 Variable header"></a>2.3 可变报头 Variable header</h2><h5 id="图例-2-3-报文标识符字节-Packet-Identifier-bytes"><a href="#图例-2-3-报文标识符字节-Packet-Identifier-bytes" class="headerlink" title="图例 2.3 -报文标识符字节 Packet Identifier bytes"></a>图例 2.3 -报文标识符字节 Packet Identifier bytes</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>报文标识符 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>报文标识符 LSB</td>
</tr>
</tbody>
</table>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。</p>
<p>SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文<strong>必须</strong>包含一个非零的16位报文标识符（Packet Identifier）[MQTT-2.3.1-1]。客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符 [MQTT-2.3.1-2]。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它<strong>必须</strong>使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT-2.3.1-3]。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端 [MQTT-2.3.1-4]。</p>
<p>QoS等于0的PUBLISH报文<strong>不能</strong>包含报文标识符 [MQTT-2.3.1-5]。</p>
<p>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT-2.3.1-6]。类似地，SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT-2.3.1-7]。</p>
<h5 id="表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier"><a href="#表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier" class="headerlink" title="表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier"></a>表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>报文标识符字段</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>不需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>需要（如果QoS &gt; 0）</td>
</tr>
<tr>
<td>PUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<p>客户端和服务端彼此独立地分配报文标识符。因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端发送标识符为0x1234的PUBLISH报文，它有可能会在收到那个报文的PUBACK之前，先收到服务端发送的另一个不同的但是报文标识符也为0x1234的PUBLISH报文。</p>
<table>
<thead>
<tr>
<th>Client</th>
<th>Server</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUBLISH</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBLISH</td>
<td>Packet Identifier=0x1234</td>
</tr>
<tr>
<td>PUBACK</td>
<td>Packet Identifier=0x1234—</td>
</tr>
<tr>
<td>–PUBACK</td>
<td>Packet Identifier=0x1234</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="2-4-有效载荷-Payload"><a href="#2-4-有效载荷-Payload" class="headerlink" title="2.4 有效载荷 Payload"></a>2.4 有效载荷 Payload</h2><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷，这将在第三章论述。对于<strong>PUBLISH来说有效载荷就是应用消息</strong>。</p>
<h5 id="表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload"><a href="#表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload" class="headerlink" title="表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload"></a>表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload</h5><table>
<thead>
<tr>
<th><strong>控制报文</strong></th>
<th><strong>有效载荷</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td>需要</td>
</tr>
<tr>
<td>CONNACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>可选</td>
</tr>
<tr>
<td>PUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREC</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBREL</td>
<td>不需要</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>不需要</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>SUBACK</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>需要</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>不需要</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>不需要</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>不需要</td>
</tr>
</tbody>
</table>
<h2 id="3-1-CONNECT-–-连接服务端"><a href="#3-1-CONNECT-–-连接服务端" class="headerlink" title="3.1 CONNECT – 连接服务端"></a>3.1 CONNECT – 连接服务端</h2><p>客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1]。</p>
<p>在一个网络连接上，客户端只能发送一次CONNECT报文。服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接 [MQTT-3.1.0-2]。有关错误处理的信息请查看4.8节。</p>
<p><strong>有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will主题，Will消息，用户名和密码</strong>。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。</p>
<h3 id="3-1-1-固定报头-Fixed-header"><a href="#3-1-1-固定报头-Fixed-header" class="headerlink" title="3.1.1 固定报头 Fixed header"></a>3.1.1 固定报头 Fixed header</h3><h5 id="图例-3-1-–CONNECT报文的固定报头"><a href="#图例-3-1-–CONNECT报文的固定报头" class="headerlink" title="图例 3.1 –CONNECT报文的固定报头"></a>图例 3.1 –CONNECT报文的固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h3 id="剩余长度字段"><a href="#剩余长度字段" class="headerlink" title="剩余长度字段"></a><strong>剩余长度字段</strong></h3><p>剩余长度等于<strong>可变报头的长度（10字节</strong>）加上有效载荷的长度。编码方式见 2.2.3节的说明。</p>
<h3 id="3-1-2-可变报头-Variable-header"><a href="#3-1-2-可变报头-Variable-header" class="headerlink" title="3.1.2 可变报头 Variable header"></a>3.1.2 可变报头 Variable header</h3><p>CONNECT报文的可变报头按下列次序包含四个字段：<strong>协议名（Protocol Name），协议级别（Protocol Level），连接标志（Connect Flags）和保持连接（Keep Alive）</strong>。</p>
<h4 id="协议名-Protocol-Name"><a href="#协议名-Protocol-Name" class="headerlink" title="协议名 Protocol Name"></a>协议名 Protocol Name</h4><h5 id="图例-3-2-协议名字节构成"><a href="#图例-3-2-协议名字节构成" class="headerlink" title="图例 3.2 -协议名字节构成"></a>图例 3.2 -协议名字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>长度 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>长度 LSB (4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘M’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘Q’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 6</td>
<td>‘T’</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>协议名是表示协议名 <em>MQTT</em> 的UTF-8编码的字符串。MQTT规范的后续版本不会改变这个字符串的偏移和长度。</p>
<h4 id="协议级别-Protocol-Level"><a href="#协议级别-Protocol-Level" class="headerlink" title="协议级别 Protocol Level"></a>协议级别 Protocol Level</h4><h5 id="图例-3-3-Protocol-Level-byte协议级别字节构成"><a href="#图例-3-3-Protocol-Level-byte协议级别字节构成" class="headerlink" title="图例 3.3 - Protocol Level byte协议级别字节构成"></a>图例 3.3 - Protocol Level byte协议级别字节构成</h5><table>
<thead>
<tr>
<th></th>
<th><strong>说明</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>协议级别</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 7</td>
<td>Level(4)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="连接标志-Connect-Flags"><a href="#连接标志-Connect-Flags" class="headerlink" title="连接标志 Connect Flags"></a>连接标志 Connect Flags</h4><p>连接标志字节包含一些用于指定MQTT连接行为的参数。它还指出有效载荷中的字段是否存在。</p>
<h5 id="图例-3-4-连接标志位"><a href="#图例-3-4-连接标志位" class="headerlink" title="图例 3.4 -连接标志位"></a>图例 3.4 -连接标志位</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0304.png" alt="figure-3.4"></p>
<p>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接 [MQTT-3.1.2-3]。</p>
<h4 id="清理会话-Clean-Session"><a href="#清理会话-Clean-Session" class="headerlink" title="清理会话 Clean Session"></a>清理会话 Clean Session</h4><p><strong>位置：</strong>连接标志字节的第1位</p>
<p>这个二进制位指定了会话状态的处理方式。</p>
<p>客户端和服务端可以保存会话状态，以支持跨网络连接的可靠消息传输。这个标志位用于控制会话状态的生存时间。</p>
<p>如果清理会话（CleanSession）标志被设置为0，服务端<strong>必须</strong>基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端<strong>必须</strong>创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端<strong>必须</strong>保存会话信息 [MQTT-3.1.2-4]。当清理会话标志为0的会话连接断开之后，服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3" target="_blank" rel="noopener">MQTT-3</a>.1.2-5]。服务端也<strong>可以</strong>保存满足相同条件的QoS 0级别的消息。</p>
<p>如果清理会话（CleanSession）标志被设置为1，客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用 [MQTT-3.1.2-6]。</p>
<p>客户端的会话状态包括：</p>
<ul>
<li>已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息</li>
<li>已从服务端接收，但是还没有完成确认的QoS 2级别的消息。</li>
</ul>
<p>服务端的会话状态包括：</p>
<ul>
<li>会话是否存在，即使会话状态的其它部分都是空。</li>
<li>客户端的订阅信息。</li>
<li>已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。</li>
<li>即将传输给客户端的QoS 1和QoS 2级别的消息。</li>
<li>已从客户端接收，但是还没有完成确认的QoS 2级别的消息。</li>
<li>可选，准备发送给客户端的QoS 0级别的消息。</li>
</ul>
<p>保留消息不是服务端会话状态的一部分，会话终止时<strong>不能</strong>删除保留消息 [MQTT-3.1.2.7]。</p>
<p>有关状态存储的限制和细节见第 4.1节。</p>
<p>当清理会话标志被设置为1时，客户端和服务端的状态删除不需要是原子操作。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>为了确保在发生故障时状态的一致性，客户端应该使用会话状态标志1重复请求连接，直到连接成功。</p>
<p><strong>非规范评注</strong></p>
<p>一般来说，客户端连接时总是将清理会话标志设置为0或1，并且不交替使用两种值。这个选择取决于具体的应用。清理会话标志设置为1的客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS 1或 QoS 2级别，同时将清理会话标志设置为0。</p>
<p><strong>非规范评注</strong></p>
<p>清理会话标志0的客户端连接时，它请求服务端在连接断开后保留它的MQTT会话状态。如果打算在之后的某个时间点重连到这个服务端，客户端连接应该只使用清理会话标志0。当客户端决定之后不再使用这个会话时，应该将清理会话标志设置为1最后再连接一次，然后断开连接。</p>
</blockquote>
<h4 id="遗嘱标志-Will-Flag"><a href="#遗嘱标志-Will-Flag" class="headerlink" title="遗嘱标志 Will Flag"></a>遗嘱标志 Will Flag</h4><p><strong>位置：</strong>连接标志的第2位。</p>
<p>遗嘱标志（Will Flag）被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端<strong>必须</strong>发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 [MQTT-3.1.2-8] 。</p>
<p>遗嘱消息发布的条件，包括但不限于：</p>
<ul>
<li>服务端检测到了一个I/O错误或者网络故障。</li>
<li>客户端在保持连接（Keep Alive）的时间内未能通讯。</li>
<li>客户端没有先发送DISCONNECT报文直接关闭了网络连接。</li>
<li>由于协议错误服务端关闭了网络连接。</li>
</ul>
<p>如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-9]。</p>
<p>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文，遗嘱消息就<strong>必须</strong>从存储的会话状态中移除 [MQTT-3.1.2-10]。</p>
<p>如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0，并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-11]。</p>
<p>如果遗嘱标志被设置为0，网络连接断开时，<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.2-12]。</p>
<p>服务端应该迅速发布遗嘱消息。在关机或故障的情况下，服务端可以推迟遗嘱消息的发布直到之后的重启。如果发生了这种情况，在服务器故障和遗嘱消息被发布之间可能会有一个延迟。</p>
<h4 id="遗嘱QoS-Will-QoS"><a href="#遗嘱QoS-Will-QoS" class="headerlink" title="遗嘱QoS Will QoS"></a>遗嘱QoS Will QoS</h4><p><strong>位置：</strong>连接标志的第4和第3位。</p>
<p>这两位用于指定发布遗嘱消息时使用的服务质量等级。</p>
<p>如果遗嘱标志被设置为0，遗嘱QoS也<strong>必须</strong>设置为0(0x00) [MQTT-3.1.2-13]。</p>
<p>如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值<strong>不能</strong>等于3 [MQTT-3.1.2-14]。</p>
<h4 id="遗嘱保留-Will-Retain"><a href="#遗嘱保留-Will-Retain" class="headerlink" title="遗嘱保留 Will Retain"></a>遗嘱保留 Will Retain</h4><p><strong>位置：</strong>连接标志的第5位。</p>
<p>如果遗嘱消息被发布时需要保留，需要指定这一位的值。</p>
<p>如果遗嘱标志被设置为0，遗嘱保留（Will Retain）标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-15]。</p>
<p>如果遗嘱标志被设置为1：</p>
<ul>
<li>如果遗嘱保留被设置为0，服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布 [MQTT-3.1.2-16]。</li>
<li>如果遗嘱保留被设置为1，服务端<strong>必须</strong>将遗嘱消息当作保留消息发布 [MQTT-3.1.2-17]。</li>
</ul>
<h4 id="用户名标志-User-Name-Flag"><a href="#用户名标志-User-Name-Flag" class="headerlink" title="用户名标志 User Name Flag"></a>用户名标志 User Name Flag</h4><p><strong>位置：</strong>连接标志的第7位。</p>
<p>如果用户名（User Name）标志被设置为0，有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-18]。</p>
<p>如果用户名（User Name）标志被设置为1，有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-19]。</p>
<h4 id="密码标志-Password-Flag"><a href="#密码标志-Password-Flag" class="headerlink" title="密码标志 Password Flag"></a>密码标志 Password Flag</h4><p><strong>位置：</strong>连接标志的第6位。</p>
<p>如果密码（Password）标志被设置为0，有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-20]。</p>
<p>如果密码（Password）标志被设置为1，有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-21]。</p>
<p>如果用户名标志被设置为0，密码标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-22]。</p>
<h4 id="保持连接-Keep-Alive"><a href="#保持连接-Keep-Alive" class="headerlink" title="保持连接 Keep Alive"></a>保持连接 Keep Alive</h4><h5 id="图例-3-5保持连接字节"><a href="#图例-3-5保持连接字节" class="headerlink" title="图例 3.5保持连接字节"></a>图例 3.5保持连接字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 9</td>
<td>保持连接 Keep Alive MSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 10</td>
<td>保持连接 Keep Alive LSB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端<strong>必须</strong>发送一个PINGREQ报文 [MQTT-3.1.2-23]。</p>
<p>不管保持连接的值是多少，客户端任何时候都可以发送PINGREQ报文，并且使用PINGRESP报文判断网络和服务端的活动状态。</p>
<p>如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它<strong>必须</strong>断开客户端的网络连接，认为网络连接已断开 [MQTT-3.1.2-24]。</p>
<p>客户端发送了PINGREQ报文之后，如果在合理的时间内仍没有收到PINGRESP报文，它<strong>应该</strong>关闭到服务端的网络连接。</p>
<p>保持连接的值为零表示关闭保持连接功能。这意味着，服务端不需要因为客户端不活跃而断开连接。注意：不管保持连接的值是多少，任何时候，只要服务端认为客户端是不活跃或无响应的，可以断开客户端的连接。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>保持连接的实际值是由应用指定的，一般是几分钟。允许的最大值是18小时12分15秒。</p>
</blockquote>
<h4 id="可变报头非规范示例"><a href="#可变报头非规范示例" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><h5 id="图例-3-6-可变报头非规范示例"><a href="#图例-3-6-可变报头非规范示例" class="headerlink" title="图例 3.6 -可变报头非规范示例"></a>图例 3.6 -可变报头非规范示例</h5><p><img src="/2018/12/16/MTQQ-介绍/figure0306.png" alt="figure-3.6"></p>
<h3 id="3-1-3-有效载荷-Payload"><a href="#3-1-3-有效载荷-Payload" class="headerlink" title="3.1.3 有效载荷 Payload"></a>3.1.3 有效载荷 Payload</h3><p>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，<strong>必须</strong>按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 [MQTT-3.1.3-1]。</p>
<h4 id="客户端标识符-Client-Identifier"><a href="#客户端标识符-Client-Identifier" class="headerlink" title="客户端标识符 Client Identifier"></a>客户端标识符 Client Identifier</h4><p>服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 [MQTT-3.1.3-2]。</p>
<p>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段 [MQTT-3.1.3-3]。</p>
<p>客户端标识符<strong>必须</strong>是1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-4]。</p>
<p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字）[MQTT-3.1.3-5]。</p>
<p>服务端<strong>可以</strong>允许编码后超过23个字节的客户端标识符 (ClientId)。服务端<strong>可以</strong>允许包含不是上面列表字符的客户端标识符 (ClientId)。</p>
<p>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文 [MQTT-3.1.3-6]。</p>
<p>如果客户端提供了一个零字节的客户端标识符，它<strong>必须</strong>同时将清理会话标志设置为1 [MQTT-3.1.3-7]。</p>
<p>如果客户端提供的ClientId为零字节且清理会话标志为0，服务端<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-8]。</p>
<p>如果服务端拒绝了这个ClientId，它<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-9]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端实现可以提供一个方便的方法用于生成随机的ClientId。当清理会话标志被设置为0时应该主动放弃使用这种方法。</p>
</blockquote>
<h4 id="遗嘱主题-Will-Topic"><a href="#遗嘱主题-Will-Topic" class="headerlink" title="遗嘱主题 Will Topic"></a>遗嘱主题 Will Topic</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱主题（Will Topic）。遗嘱主题<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-10]。</p>
<h4 id="遗嘱消息-Will-Message"><a href="#遗嘱消息-Will-Message" class="headerlink" title="遗嘱消息 Will Message"></a>遗嘱消息 Will Message</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱消息。遗嘱消息定义了将被发布到遗嘱主题的应用消息，见3.1.2.5节的描述。这个字段由一个两字节的长度和遗嘱消息的有效载荷组成，表示为零字节或多个字节序列。长度给出了跟在后面的数据的字节数，不包含长度字段本身占用的两个字节。</p>
<p>遗嘱消息被发布到遗嘱主题时，它的有效载荷只包含这个字段的数据部分，不包含开头的两个长度字节。</p>
<h4 id="用户名-User-Name"><a href="#用户名-User-Name" class="headerlink" title="用户名 User Name"></a>用户名 User Name</h4><p>如果用户名（User Name）标志被设置为1，有效载荷的下一个字段就是它。用户名<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-11]。服务端可以将它用于身份验证和授权。</p>
<h4 id="密码-Password"><a href="#密码-Password" class="headerlink" title="密码 Password"></a>密码 Password</h4><p>如果密码（Password）标志被设置为1，有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段，长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节），后面跟着0到65535字节的二进制数据。</p>
<h5 id="图例-3-7-密码字节"><a href="#图例-3-7-密码字节" class="headerlink" title="图例 3.7 - 密码字节"></a>图例 3.7 - 密码字节</h5><table>
<thead>
<tr>
<th><strong>Bit</strong></th>
<th><strong>7</strong> - <strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte 1</td>
<td>数据长度 MSB</td>
</tr>
<tr>
<td>byte 2</td>
<td>数据长度 LSB</td>
</tr>
<tr>
<td>byte 3 ….</td>
<td>如果长度大于0，这里就是数据部分</td>
</tr>
</tbody>
</table>
<h3 id="3-1-4-响应-Response"><a href="#3-1-4-响应-Response" class="headerlink" title="3.1.4 响应 Response"></a>3.1.4 响应 Response</h3><p>注意：服务器可以在同一个TCP端口或其他网络端点上支持多种协议（包括本协议的早期版本）。如果服务器确定协议是MQTT 3.1.1，那么它按照下面的方法验证连接请求。</p>
<ol>
<li>网络连接建立后，如果服务端在合理的时间内没有收到CONNECT报文，服务端<strong>应该</strong>关闭这个连接。</li>
<li>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接 [MQTT-3.1.4-1]。</li>
<li>服务端<strong>可以</strong>检查CONNECT报文的内容是不是满足任何进一步的限制，<strong>可以</strong>执行身份验证和授权检查。如果任何一项检查没通过，按照3.2节的描述，它<strong>应该</strong>发送一个适当的、返回码非零的CONNACK响应，并且<strong>必须</strong>关闭这个网络连接。</li>
</ol>
<p>如果验证成功，服务端会执行下列步骤。</p>
<ol>
<li>如果ClientId表明客户端已经连接到这个服务端，那么服务端<strong>必须</strong>断开原有的客户端连接 [MQTT-3.1.4-2]。</li>
<li>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程 [MQTT-3.1.4-3]。</li>
<li>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT-3.1.4-4]。</li>
<li>开始消息分发和保持连接状态监视。</li>
</ol>
<p>允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文。如果服务端拒绝了CONNECT，它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据 [MQTT-3.1.4-5]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>客户端通常会等待一个CONNACK报文。然而客户端有权在收到CONNACK之前发送控制报文，由于不需要维持连接状态，这可以简化客户端的实现。</p>
</blockquote>
<h2 id="3-2-CONNACK-–-确认连接请求"><a href="#3-2-CONNACK-–-确认连接请求" class="headerlink" title="3.2 CONNACK – 确认连接请求"></a>3.2 CONNACK – 确认连接请求</h2><p>服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK [MQTT-3.2.0-1]。</p>
<p>如果客户端在合理的时间内没有收到服务端的CONNACK报文，客户端<strong>应该</strong>关闭网络连接。<em>合理</em> 的时间取决于应用的类型和通信基础设施。</p>
<h3 id="3-2-1-固定报头"><a href="#3-2-1-固定报头" class="headerlink" title="3.2.1 固定报头"></a>3.2.1 固定报头</h3><p>固定报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_Figure_3.8_%E2%80%93" target="_blank" rel="noopener">图例 3.8 – CONNACK 报文固定报头</a> 的描述。</p>
<h5 id="图例-3-8-–-CONNACK-报文固定报头"><a href="#图例-3-8-–-CONNACK-报文固定报头" class="headerlink" title="图例 3.8 – CONNACK 报文固定报头"></a>图例 3.8 – CONNACK 报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>Bit</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>byte 1</center></td><br>        <td colspan="4"><center>MQTT报文类型 (2)</center></td><br>        <td colspan="4"><center>Reserved 保留位</center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>     <tr><br>           <td colspan="1"><center>byte 2…</center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<p><strong>剩余长度字段</strong>表示可变报头的长度。对于CONNACK报文这个值等于2。</p>
<h3 id="3-2-2-可变报头"><a href="#3-2-2-可变报头" class="headerlink" title="3.2.2 可变报头"></a>3.2.2 可变报头</h3><p>可变报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E5%9B%BE%E4%BE%8B_3.9_%E2%80%93CONNACK%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4" target="_blank" rel="noopener">图例 3.9 –CONNACK报文可变报头</a> 的描述。</p>
<h5 id="图例-3-9-–CONNACK报文可变报头"><a href="#图例-3-9-–CONNACK报文可变报头" class="headerlink" title="图例 3.9 –CONNACK报文可变报头"></a>图例 3.9 –CONNACK报文可变报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>   <tr><br>           <td colspan="1"><center>连接确认标志</center></td><br>        <td colspan="7"><center>Reserved 保留位</center></td><br>        <td colspan="1"><center>SP1</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>     <tr><br>        <td colspan="9"><center>连接返回码</center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br></table>

<h4 id="连接确认标志-Connect-Acknowledge-Flags"><a href="#连接确认标志-Connect-Acknowledge-Flags" class="headerlink" title="连接确认标志 Connect Acknowledge Flags"></a>连接确认标志 Connect Acknowledge Flags</h4><p>第1个字节是 <em>连接确认标志</em>，位7-1是保留位且<strong>必须</strong>设置为0。 第0 (SP)位 是当前会话（Session Present）标志。</p>
<h4 id="当前会话-Session-Present"><a href="#当前会话-Session-Present" class="headerlink" title="当前会话 Session Present"></a>当前会话 Session Present</h4><p><strong>位置：</strong>连接确认标志的第0位。</p>
<p>如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还<strong>必须</strong>将CONNACK报文中的当前会话设置（Session Present）标志为0 [MQTT-3.2.2-1]。</p>
<p>如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1 [MQTT-3.2.2-2]。如果服务端没有已保存的会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0 [MQTT-3.2.2-3]。</p>
<p>当前会话标志使服务端和客户端在是否有已存储的会话状态上保持一致。</p>
<p>一旦完成了会话的初始化设置，已经保存会话状态的客户端将期望服务端维持它存储的会话状态。如果客户端从服务端收到的当前的值与预期的不同，客户端可以选择继续这个会话或者断开连接。客户端可以丢弃客户端和服务端之间的会话状态，方法是，断开连接，将清理会话标志设置为1，再次连接，然后再次断开连接。</p>
<p>如果服务端发送了一个包含非零返回码的CONNACK报文，它<strong>必须</strong>将当前会话标志设置为0 [MQTT-3.2.2-4]。</p>
<h4 id="连接返回码-Connect-Return-code"><a href="#连接返回码-Connect-Return-code" class="headerlink" title="连接返回码 Connect Return code"></a>连接返回码 Connect Return code</h4><p><strong>位置：</strong>可变报头的第2个字节。</p>
<p>连接返回码字段使用一个字节的无符号值，在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E8%A1%A8%E6%A0%BC_3.1_%E2%80%93%E8%BF%9E%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%A0%81%E7%9A%84%E5%80%BC" target="_blank" rel="noopener">表格 3.1 –连接返回码的值</a> 中列出。如果服务端收到一个合法的CONNECT报文，但出于某些原因无法处理它，服务端应该尝试发送一个包含非零返回码（表格中的某一个）的CONNACK报文。如果服务端发送了一个包含非零返回码的CONNACK报文，那么它<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-5].。</p>
<h5 id="表格-3-1-–连接返回码的值"><a href="#表格-3-1-–连接返回码的值" class="headerlink" title="表格 3.1 –连接返回码的值"></a>表格 3.1 –连接返回码的值</h5><table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>返回码响应</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x00连接已接受</td>
<td>连接已被服务端接受</td>
</tr>
<tr>
<td>1</td>
<td>0x01连接已拒绝，不支持的协议版本</td>
<td>服务端不支持客户端请求的MQTT协议级别</td>
</tr>
<tr>
<td>2</td>
<td>0x02连接已拒绝，不合格的客户端标识符</td>
<td>客户端标识符是正确的UTF-8编码，但服务端不允许使用</td>
</tr>
<tr>
<td>3</td>
<td>0x03连接已拒绝，服务端不可用</td>
<td>网络连接已建立，但MQTT服务不可用</td>
</tr>
<tr>
<td>4</td>
<td>0x04连接已拒绝，无效的用户名或密码</td>
<td>用户名或密码的数据格式无效</td>
</tr>
<tr>
<td>5</td>
<td>0x05连接已拒绝，未授权</td>
<td>客户端未被授权连接到此服务器</td>
</tr>
<tr>
<td>6-255</td>
<td></td>
<td>保留</td>
</tr>
</tbody>
</table>
<p>如果认为上表中的所有连接返回码都不太合适，那么服务端<strong>必须</strong>关闭网络连接，不需要发送CONNACK报文 [MQTT-3.2.2-6]。</p>
<h3 id="3-2-3-有效载荷"><a href="#3-2-3-有效载荷" class="headerlink" title="3.2.3 有效载荷"></a>3.2.3 有效载荷</h3><p>CONNACK报文没有有效载荷。</p>
<h2 id="3-3-PUBLISH-–-发布消息"><a href="#3-3-PUBLISH-–-发布消息" class="headerlink" title="3.3 PUBLISH – 发布消息"></a>3.3 PUBLISH – 发布消息</h2><p>PUBLISH控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。</p>
<h3 id="3-3-1-固定报头"><a href="#3-3-1-固定报头" class="headerlink" title="3.3.1 固定报头"></a>3.3.1 固定报头</h3><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E5%9B%BE%E4%BE%8B_3.10_%E2%80%93" target="_blank" rel="noopener">图例 3.10 – PUBLISH报文固定报头</a>描述了固定报头的格式</p>
<h5 id="图例-3-10-–-PUBLISH报文固定报头"><a href="#图例-3-10-–-PUBLISH报文固定报头" class="headerlink" title="图例 3.10 – PUBLISH报文固定报头"></a>图例 3.10 – PUBLISH报文固定报头</h5><table><br>    <tr><br>        <td><center><strong>描述</strong></center></td><br>        <td><center><strong>7</strong></center></td><br>        <td><center><strong>6</strong></center></td><br>        <td><center><strong>5</strong></center></td><br>        <td><center><strong>4</strong></center></td><br>        <td><center><strong>3</strong></center></td><br>        <td><center><strong>2</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>   </tr><br>    <tr><br>        <td><center><strong>byte 1</strong></center></td><br>        <td colspan="4"><center>MQTT控制报文类型 (3)</center></td><br>        <td><center><strong>DUP</strong></center></td><br>        <td><center><strong>QoS-H</strong></center></td><br>        <td><center><strong>QoS-</strong></center></td><br>        <td><center><strong>RETAIN</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong> </strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>0</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>1</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>        <td><center><strong>X</strong></center></td><br>   </tr><br>    <tr><br>           <td><center><strong>byte 2</strong></center></td><br>        <td colspan="8"><center>剩余长度</center></td><br>   </tr><br></table>

<h4 id="重发标志-DUP"><a href="#重发标志-DUP" class="headerlink" title="重发标志 DUP"></a>重发标志 DUP</h4><p><strong>位置：</strong>第1个字节，第3位</p>
<p>如果DUP标志被设置为0，表示这是客户端或服务端第一次请求发送这个PUBLISH报文。如果DUP标志被设置为1，表示这可能是一个早前报文请求的重发。</p>
<p>客户端或服务端请求重发一个PUBLISH报文时，<strong>必须</strong>将DUP标志设置为1 [MQTT-3.3.1.-1].。对于QoS 0的消息，DUP标志<strong>必须</strong>设置为0 [MQTT-3.3.1-2]。</p>
<p>服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值<strong>必须</strong>单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定 [MQTT-3.3.1-3]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>接收者收到一个DUP标志为1的控制报文时，不能假设它看到了一个这个报文之前的一个副本。</p>
<p><strong>非规范评注</strong></p>
<p>需要特别指出的是，DUP标志关注的是控制报文本身，与它包含的应用消息无关。当使用QoS 1时，客户端可能会收到一个DUP标志为0的PUBLISH报文，这个报文包含一个它之前收到过的应用消息的副本，但是用的是不同的报文标识符。 2.3.1节提供了有关报文标识符的更多信息。</p>
</blockquote>
<h4 id="服务质量等级-QoS"><a href="#服务质量等级-QoS" class="headerlink" title="服务质量等级 QoS"></a>服务质量等级 QoS</h4><p><strong>位置：</strong>第1个字节，第2-1位。</p>
<p>这个字段表示应用消息分发的服务质量等级保证。服务质量等级在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.2_-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">表格 3.2 -服务质量定义</a> 中列出。</p>
<h5 id="表格-3-2-服务质量定义"><a href="#表格-3-2-服务质量定义" class="headerlink" title="表格 3.2 -服务质量定义"></a>表格 3.2 -服务质量定义</h5><table>
<thead>
<tr>
<th><strong>QoS值</strong></th>
<th><strong>Bit 2</strong></th>
<th><strong>Bit 1</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>最多分发一次</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>至少分发一次</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>只分发一次</td>
</tr>
<tr>
<td>-</td>
<td>1</td>
<td>1</td>
<td>保留位</td>
</tr>
</tbody>
</table>
<p>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它<strong>必须</strong>关闭网络连接 [MQTT-3.3.1-4]。</p>
<h4 id="保留标志-RETAIN"><a href="#保留标志-RETAIN" class="headerlink" title="保留标志 RETAIN"></a>保留标志 RETAIN</h4><p><strong>位置：</strong>第1个字节，第0位。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它<strong>必须</strong>被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它<strong>必须</strong>丢弃之前为那个主题保留的任何消息。它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 [MQTT-3.3.1-7]。有关存储状态的更多信息见 4.1节。</p>
<p>服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它<strong>必须</strong>将报文的保留标志设为1 [MQTT-3.3.1-8]。当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端<strong>必须</strong>将保留标志设为0，不管它收到的这个消息中保留标志的值是多少 [MQTT-3.3.1-9]。</p>
<p>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT-3.3.1-10]。<em>当作正常</em> 意思是现存的客户端收到的消息中保留标志未被设置。服务端<strong>不能</strong>存储零字节的保留消息 [MQTT-3.3.1-11]。</p>
<p>如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息 [MQTT-3.3.1-12]。</p>
<blockquote>
<p><strong>非规范评注</strong></p>
<p>对于发布者不定期发送状态消息这个场景，保留消息很有用。新的订阅者将会收到最近的状态。</p>
</blockquote>
<p><strong>剩余长度字段</strong></p>
<p>等于可变报头的长度加上有效载荷的长度。</p>
<h3 id="3-3-2-可变报头"><a href="#3-3-2-可变报头" class="headerlink" title="3.3.2 可变报头"></a>3.3.2 可变报头</h3><p>可变报头按顺序包含主题名和报文标识符。</p>
<h4 id="主题名-Topic-Name"><a href="#主题名-Topic-Name" class="headerlink" title="主题名 Topic Name"></a>主题名 Topic Name</h4><p>主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。</p>
<p>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段。它<strong>必须</strong>是 1.5.3节定义的UTF-8编码的字符串 [MQTT-3.3.2-1]。</p>
<p>PUBLISH报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2]。</p>
<p>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器（根据 4.7节定义的匹配过程）[MQTT-3.3.2-3]。</p>
<h4 id="报文标识符-Packet-Identifier"><a href="#报文标识符-Packet-Identifier" class="headerlink" title="报文标识符 Packet Identifier"></a>报文标识符 Packet Identifier</h4><p>只有当QoS等级是1或2时，报文标识符（Packet Identifier）字段才能出现在PUBLISH报文中。2.3.1节提供了有关报文标识符的更多信息。</p>
<h4 id="可变报头非规范示例-1"><a href="#可变报头非规范示例-1" class="headerlink" title="可变报头非规范示例"></a>可变报头非规范示例</h4><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_Figure_3.11_-" target="_blank" rel="noopener">图例 3.11 – PUBLISH报文可变报头非规范示例</a> 举例说明了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.3_-" target="_blank" rel="noopener">表格 3.3 - PUBLISH报文非规范示例</a> 中简要描述的PUBLISH报文的可变报头。</p>
<h5 id="表格-3-3-PUBLISH报文非规范示例"><a href="#表格-3-3-PUBLISH报文非规范示例" class="headerlink" title="表格 3.3 - PUBLISH报文非规范示例"></a>表格 3.3 - PUBLISH报文非规范示例</h5><table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>主题名</td>
<td>a/b</td>
</tr>
<tr>
<td>报文标识符</td>
<td>10</td>
</tr>
</tbody>
</table>
<h5 id="图例-3-11-–-PUBLISH报文可变报头非规范示例"><a href="#图例-3-11-–-PUBLISH报文可变报头非规范示例" class="headerlink" title="图例 3.11 – PUBLISH报文可变报头非规范示例"></a>图例 3.11 – PUBLISH报文可变报头非规范示例</h5><table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
<th><strong>7</strong></th>
<th><strong>6</strong></th>
<th><strong>5</strong></th>
<th><strong>4</strong></th>
<th><strong>3</strong></th>
<th><strong>2</strong></th>
<th><strong>1</strong></th>
<th><strong>0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Topic Name 主题名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 1</td>
<td>Length MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 2</td>
<td>Length LSB (3)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 3</td>
<td>‘a’ (0x61)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>byte 4</td>
<td>‘/’ (0x2F)</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>byte 5</td>
<td>‘b’ (0x62)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>报文标识符</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte 6</td>
<td>报文标识符 MSB (0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>byte 7</td>
<td>报文标识符 LSB (10)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>示例中的主题名为 “a/b”，长度等于3，报文标识符为 “10”</p>
<h3 id="3-3-3-有效载荷"><a href="#3-3-3-有效载荷" class="headerlink" title="3.3.3 有效载荷"></a>3.3.3 有效载荷</h3><p>有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的。</p>
<h3 id="3-3-4-响应"><a href="#3-3-4-响应" class="headerlink" title="3.3.4 响应"></a>3.3.4 响应</h3><p>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应，见下面表格的描述 [MQTT-3.3.4-1]。</p>
<h5 id="表格-3-4-–-PUBLISH报文的预期响应"><a href="#表格-3-4-–-PUBLISH报文的预期响应" class="headerlink" title="表格 3.4 – PUBLISH报文的预期响应"></a>表格 3.4 – PUBLISH报文的预期响应</h5><table>
<thead>
<tr>
<th><strong>服务质量等级</strong></th>
<th><strong>预期响应</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QoS 0</td>
<td>无响应</td>
</tr>
<tr>
<td>QoS 1</td>
<td>PUBACK报文</td>
</tr>
<tr>
<td>QoS 2</td>
<td>PUBREC报文</td>
</tr>
</tbody>
</table>
<h3 id="3-3-5-动作-Actions"><a href="#3-3-5-动作-Actions" class="headerlink" title="3.3.5 动作 Actions"></a>3.3.5 动作 Actions</h3><p>客户端使用PUBLISH报文发送应用消息给服务端，目的是分发到其它订阅匹配的客户端。</p>
<p>服务端使用PUBLISH报文发送应用消息给每一个订阅匹配的客户端。</p>
<p>客户端使用带通配符的主题过滤器请求订阅时，客户端的订阅可能会重复，因此发布的消息可能会匹配多个过滤器。对于这种情况，服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端 [MQTT-3.3.5-1]。服务端之后可以按照订阅的QoS等级，分发消息的副本给每一个匹配的订阅者。</p>
<p>收到一个PUBLISH报文时，接收者的动作取决于4.3节描述的QoS等级。</p>
<p>如果服务端实现不授权某个客户端发布PUBLISH报文，它没有办法通知那个客户端。它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认，或者关闭网络连接 [MQTT-3.3.5-2]。</p>
<blockquote>
<p>MQTT 原文文献:<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p>
<p>MQTT 中文版:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>随手记录</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa教程 - 权威介绍：第1/2部分</title>
    <url>/2018/06/04/ReactiveCocoa%E6%95%99%E7%A8%8B-%E6%9D%83%E5%A8%81%E4%BB%8B%E7%BB%8D%EF%BC%9A%E7%AC%AC1-2%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>五月初来到新公司之后，新公司开发使用的是 RAC+MVVM 的开发模式。以前就想学这样的响应式编程，现在正好趁着这个机会学习一下。就从翻译一篇好文章开始。</p>
<p>原文:<a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="noopener">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<p>作者:Colin Eberhardt</p>
</blockquote>
<p>作为一个 iOS 开发者，你写的每一行代码基本上都是对一个事件的响应。例如:一个按钮的点击、一个受到的网络消息、一个属性的变化(通过键值观察)或者是通过CoreLocation更改了用户位置，这些都是一些很好的例子。然而这些事件都以不同的方式编码。例如动作(actions)、代理(delegate)、键值观察(KVO)、回调(callbacks)和其他的一些事件。ReactiveCocoa为这些事件定义了一个标准的接口，所以他们能够更轻松的被链接，并使用一组基本工具进行过滤和组合。</p>
<p>听起来很困惑、很奇妙？感觉很兴奋？让我们继续看下去:]</p>
<a id="more"></a>
<p>ReactiveCocoa结合了几种编程风格：</p>
<ul>
<li>[函数式编程(Functional Programming)][<a href="http://en.wikipedia.org/wiki/Functional_programming]：通过高阶函数实现的范式，例如接收其他函数作为函数的参数。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Functional_programming]：通过高阶函数实现的范式，例如接收其他函数作为函数的参数。</a></li>
<li><a href="http://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程(Reactive Programming)</a>：只专注于数据流和数据变化传播的编程范式。</li>
</ul>
<p>介于此原因，你可能听说过ReactiveCocoa同样被描述为函数响应式编程(或FRP)框架。</p>
<p>但是你尽可放心，虽然编程范式的确是一个十分吸引人的课题，但是在 ReactiveCocoa 教程中，我们并不会去深入探讨，在我们的教程中更加注重的是其使用价值，我们会用实例去演示其价值。</p>
<h2 id="The-Reactive-Playground"><a href="#The-Reactive-Playground" class="headerlink" title="The Reactive Playground"></a>The Reactive Playground</h2><p>在此ReactiveCocoa教程中你将会在一个非常简单的应用程序——ReactivePlayground中去认识反应时编程。下载<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="noopener">此项目</a>编译并运行以确保项目能够正常的运行。</p>
<p>ReactivePlayground是一个非常简单的App，它只显示一个登录的界面。并当你输入了正确的用户名和密码之后，你会看到一只可爱的小猫咪。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/ReactivePlaygroundStarter.jpg" alt="ReactivePlaygroundStarter"></p>
<p>哇，多可爱的一只猫咪啊！</p>
<p>现在我们需要花一点时间去看这个演示项目的源代码，这并不会花费你很多时间，因为这个项目非常简单。</p>
<p>打开 <em>RWViewController.m</em> 文件并随便看看。你多快才能看出 <em>Sign In</em>按钮可用的条件？signInFailure label 的显示或者隐藏的条件是什么？在这个相对简单的示例中，这个问题可能会花费你一两分钟。对于更复杂的示例，你会发现这个简单的分析会花费你更长的时间。</p>
<p>使用ReactiveCocoa你会发现应用程序的深层意图会变得更加的明朗简单。所以是时候开始做了！</p>
<h2 id="添加ReactiveCocoa框架"><a href="#添加ReactiveCocoa框架" class="headerlink" title="添加ReactiveCocoa框架"></a>添加ReactiveCocoa框架</h2><p>将ReactiveCocoa框架添加到你的项目中的最简单的方法就是使用 <a href="http://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a>。如果你之前从来没有用过 <a href="http://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a>，你可以这篇<a href="https://www.raywenderlich.com/?p=12139" target="_blank" rel="noopener">Introduction To CocoaPods</a>也许会对你有帮助，或者至少运行这篇文章中初始化的步骤，以便你能安装必要的组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示:如果因为一些原因你无法去使用 CocoaPods 你也可以在 GitHub上的文档中查看手动导入ReactiveCocoa 的方法。</span><br></pre></td></tr></table></figure>
<p>如果<em>ReactivePlayground</em>还在你的 Xcode 中开着，那么现在请关闭它。CocoaPods将会创建一个代替原始工程文件的Xcode的工作区(workspace)。</p>
<p>打开终端(Terminal)，进入你工程所在的文件夹并输入如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">touch Podfile</span><br><span class="line">open -e Podfile</span><br></pre></td></tr></table></figure>
<p>这会为你创建一个名为Podfile的文件，然后用文本编辑器(TextEdit)打开它。在文本编辑器中拷贝并粘贴如下内容。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'ReactiveCocoa'</span>, <span class="string">'2.1.8'</span></span><br></pre></td></tr></table></figure>
<p>这是将 iOS 平台最低的 SDK 支持版本设置为7.0，并添加ReactiveCocoa框架设置为依赖项。</p>
<p>当你保存了这个文件之后，回到终端，并输入以下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>你会看见类似如下输出内容：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing ReactiveCocoa (<span class="number">2.1</span>.<span class="number">8</span>)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] From now on use <span class="string">`RWReactivePlayground.xcworkspace`</span>.</span><br></pre></td></tr></table></figure>
<p>这意味着 ReactiveCocoa 框架已经下载完毕，并且CocoaPods已经为你创建了一个工作区以便你在存在的应用程序中整合 ReactiveCocoa 框架。</p>
<p>打开刚创建的 <em>RWReactivePlayground.xcworkspace</em> 文件，并查看在项目导航区中创建的 CocoaPods 结构。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/AddedCocoaPods.png" alt="添加 CocoaPods"></p>
<p>你应该能看到CocoaPods 创建了一个新的工作区，添加了 <em>RWReactivePlayground</em> 原始项目，和包含ReactiveCocoa的Pod 项目。 CocoaPods 确实使得管理依赖变得轻而易举！</p>
<p>你会发现项目的名称为 <em>ReactivePlayground</em> ，这代表着我们将要正式开始了。</p>
<h2 id="游乐开始"><a href="#游乐开始" class="headerlink" title="游乐开始"></a>游乐开始</h2><p>如引言所述，ReactiveCocoa 为你的应用处理不同事件流提供了一个标准的接口。在 ReactiveCocoa 中的术语被称为 信号，它们是代表了 RACSignal 类。</p>
<p>为这个 App 的初始化视图控制器的<em>RWViewController.m</em> 的顶部添加如下代码以引入 ReactiveCocoa 头文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span><br></pre></td></tr></table></figure>
<p>你现在不用替换任何已有的代码，因为现在我们只是要游乐一下。在 <em>viewDidLoad</em> 结尾添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.usernameTextField.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>编译运行程序并且在 username text field 中随便输入几个数字。观察控制台输入的类似如下的代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.359</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] i</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.436</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.541</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is </span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.695</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is t</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.831</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is th</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.878</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is thi</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">50.901</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.009</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this </span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.142</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this m</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.236</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this ma</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.335</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this mag</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.439</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this magi</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.535</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this magic</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">14</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">51.774</span> RWReactivePlayground[<span class="number">9193</span><span class="symbol">:a0b</span>] is this magic?</span><br></pre></td></tr></table></figure>
<p>你会发现每次你在输入 textFIeld 信息都会执行代码块(block)。没有目标-动作对(target-action)、没有代理(delegate)，唯一存在的只是信号和代码块——这真令人兴奋！</p>
<p>ReactiveCocoa 信号(<em>RACSignal</em>的对象)会为他所有的订阅者发送事件流。这里三种需要知晓的事件类型——<em>next</em>, <em>error</em> 和 <em>completed</em>。一个信号可能会在其遇到error 事件被终止之前发送多个 next 事件。在本教程的第一部分中你会专注于 next 事件。当需要了解 error 和completed 事件时，请务必阅读第二部分。</p>
<p>ReactiveCocoa框架通过通过分类(categories)的方式为多个 UIKit Controls 控件添加了信号，因此你可以通过他们为这些控件的响应事件添加订阅者。在 textField 中信号的属性是 rac_textSignal。</p>
<p>理论到这里结束，接来下我们开始让 ReactiveCocoa 为你效命。</p>
<p>ReactiveCocoa 拥有海量的运算符用于操作事件流。举个例子，假设你唯一在意的是超过三个字符长度的用户名，你可以使用 <em>filter</em> 运算符来达到目的。更新你刚刚添加到在 viewDIdLoad 方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>如果你编译并运行，并输入一下内容，你会发现控制台只有在texfield 中内容长度超过三个字符的情况下才会输出内容。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.335</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is t</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.478</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is th</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.526</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is thi</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.548</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.676</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this </span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.798</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this m</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.926</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this ma</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">51.987</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this mag</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">52.141</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this magi</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">52.229</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this magic</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> 08<span class="symbol">:</span><span class="number">17</span><span class="symbol">:</span><span class="number">52.486</span> RWReactivePlayground[<span class="number">9654</span><span class="symbol">:a0b</span>] is this magic?</span><br></pre></td></tr></table></figure>
<p>你在这里创建的其实是一个非常简单的管道。你在数据流方面表达应用程序的功能，这是响应式编程(Reactive Programming)的本质。</p>
<p>下图或许可以帮助你理解数据流管道：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/FilterPipeline.png" alt="FilterPipeline"></p>
<p>在上图中你可以看到 <em>rac_textSignal</em> 是事件的初始源头。数据流经过一个filter ，这个 filter只允许内容包含长度三位或者三位以上的字符串的事件通过。在管道的最后一步<em>subscribeNext:</em> ， 输入值的操作在这个 block 中打印。</p>
<p>在这一步中值得注意的是，filter 操作符输出的内容也是一个<em>RACSignal</em>。你可以使用如下的代码分散管道的每一步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *usernameSourceSignal = </span><br><span class="line">    self.usernameTextField.rac_textSignal;</span><br><span class="line"></span><br><span class="line">RACSignal *filteredUsername = [usernameSourceSignal  </span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">[filteredUsername subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>因为对 <em>RACSignal</em> 操作的每一个操作符都会返回一个 <em>RACSignal</em>，这被称为<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">流式接口</a>。这个特性可以让你在引用管道每一步的时候都不用额外创建一个局部变量。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">注意：ReactiveCocoa中大量使用了 block，如果 block 对于你来说是一个新的事物，你可能会想看看苹果的[block编程注意事项](<span class="symbol">https:</span>/<span class="regexp">/developer.apple.com/library</span><span class="regexp">/ios/documentation</span><span class="regexp">/cocoa/</span>Conceptual/Blocks/Articles/<span class="number">00_</span>Introduction.html)。而如果像我一样对 block 熟悉，但是对这个复杂的难以记住的语法有点头疼，那么这篇标题很有趣的文章[fuckingblocksyntax](<span class="symbol">http:</span>/<span class="regexp">/fuckingblocksyntax.com/</span>)会很适合你。</span><br></pre></td></tr></table></figure>
<h2 id="一个简单的转换"><a href="#一个简单的转换" class="headerlink" title="一个简单的转换"></a>一个简单的转换</h2><p>如果你升级了你的代码并且将其分隔成了多个 <code>RACSignal</code> 组件，那么现在是时候将代码转换为流畅的语法了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value; // 隐式转换</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>在上文中标记的位置，将 <em>id</em> 类型隐式转换为<em>NSString</em>类型，但是这并不够优雅。幸运的是当 value 通过 block 传递值的时候这个值类型一直都会保持为 NSString 类型的，因此你可以改变参数本身的类型。可以将代码升级如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>接着就类似之前那样构建并运行项目，查看项目是否能正常工作。</p>
<h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><p>到目前为止，本教程已经描述了多个事件类型，但是还没有具体描述这些事件的结构。有趣的是，一个事件能包含任何东西。</p>
<p>为了说明这一点，你需要在管道中加入其他的操作。请在 <em>viewDidLoad</em> 中加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self.usernameTextField.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSNumber *length) &#123;</span><br><span class="line">    return [length integerValue] &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>编译并运行项目，你会发现在控制台中输出的内容被替换为了字符串的长度。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">54.566</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">4</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">54.725</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">5</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">54.853</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">6</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.061</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">7</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.197</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">8</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.300</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">9</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.462</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">10</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.558</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">11</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">12</span><span class="symbol">:</span><span class="number">06</span><span class="symbol">:</span><span class="number">55.646</span> RWReactivePlayground[<span class="number">10079</span><span class="symbol">:a0b</span>] <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>最新添加的 <em>map</em> 操作是通过提供的 block 来转换事件数据。并且对于它收到的任何的下一个事件，都会运行这个 block 并且将 block 返回的数据作为下一个事件数据传递发出。对于上面的代码，map 操作取传入的 NSString 的长度作为<em>NSNumber</em>的内容输出。</p>
<p>其原理的如下如所示:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/FilterAndMapPipeline.png" alt="FilterAndMapPipeline"></p>
<p>通过上图说明，你会发现在 map 操作符之后的所有操作现在都接收了 NSNumber 来代替 NSString作为接收内容。</p>
<blockquote>
<p>注意：在上述的示例程序中text.length属性返回一个基本类型NSUinteger 。为了让它能够成为事件的内容，必须将其装箱。幸运的是 <a href="https://www.mikeash.com/pyblog/friday-qa-2012-06-22-objective-c-literals.html" target="_blank" rel="noopener">Objective-C 字面语法</a>提供了一种非常简洁的语法来实现，那就是– @(text.length)。</p>
</blockquote>
<p>玩够了，现在是时候让我们结合目前所学的知识来升级 ReactivePlayground 这个 App 了。你可能需要删除你在本教程刚开始添加的所有代码。</p>
<h2 id="创建有效的状态信号"><a href="#创建有效的状态信号" class="headerlink" title="创建有效的状态信号"></a>创建有效的状态信号</h2><p>第一件事是要先创建出一对分别表示用户名和密码输入框有效的信号。将下列代码添加到<em>RWViewController.m</em>文件的 viewDidLoad 方法中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *validUsernameSignal =</span><br><span class="line">  [self.usernameTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidUsername:text]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *validPasswordSignal =</span><br><span class="line">  [self.passwordTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidPassword:text]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>你可以看到上述代码为每个 textfield 的rac_textSignal使用了 map 转换操作符。其输出是一个被装箱为 NSNumber 的 BOOL 值。</p>
<p>接下来一步是转化信号使得他们能够为 textField 提供一个好的背景颜色。基本上，你会使用这些信号和其结果以设置 textfield 的背景颜色。其中一个可行的方式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[validPasswordSignal</span><br><span class="line">  map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.passwordTextField.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>(请不要将上述代码添加到你的项目中，因为即将有更优雅的解决方式)</p>
<p>从概念上来讲，你将信号的输出分配给了textfield 的 backgroundColor 属性。然而上述代码并没有将其意思展现出出来，这是非常不好的。</p>
<p>幸运的是 ReactiveCocoa 提供了一个宏，这个宏允许你以非常简洁的方式来表达。</p>
<p>在之前添加在viewDidLoad 中的两个信号的下面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAC(self.passwordTextField, backgroundColor) =</span><br><span class="line">  [validPasswordSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">      return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.usernameTextField, backgroundColor) =</span><br><span class="line">  [validUsernameSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">     return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p><em>RAC</em>宏允许你将对象的属性设置为信号的输出。这个宏需要两个参数，第一个参数是一个对象找个对象包含了需要被设置的属性，第二个参数就是属性名。每次信号发出下一个事件(NextEvent)，被传递的值会被设置到给定的属性上。</p>
<p>这是一个非常优雅的解决方式，你认为呢？</p>
<p>在你构建并运行之前的最后一件事情是找到<em>updateUIState</em>方法并移除如下两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br></pre></td></tr></table></figure>
<p>这将会清除非响应式编程的代码。</p>
<p>构建并运行程序，你会发现当 textfield 无效时，会变为高亮状态，而有效的时候会清除高亮。</p>
<p>视觉效果相当的好，所以这个是一个可以可视化当前逻辑的方法。这样你可以看到两个带文本信号的简单管道，并将它们映射到指示是否有效的 BOOL 值上，接下来按照第二个映射到绑定 textfield背景颜色的 <em>UIColor</em> 。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/TextFieldValidPipeline.png" alt="TextFieldValidPipeline"></p>
<p>你是否正对为何要单独创建<em>validPasswordSignal</em>和<em>validUsernameSignal</em>信号分隔符，而不是为每个 textfield 创建流畅的管道而感到疑惑？请保持耐心，亲爱的读者，这疯狂方法的背后意图不久之后会变得清晰。</p>
<h2 id="组合信号"><a href="#组合信号" class="headerlink" title="组合信号"></a>组合信号</h2><p>在当前的 app 中，<em>signin</em>按钮只有在用户名和密码 textfield 同时具有有效输入的时候才能生效。是时候将其设置为响应式编程的风格了！</p>
<p>当前的代码中已经包含了发出一个boolean类型的值用于指示用户名和密码 textfield 是否有效的信号——<em>validUsernameSignal</em>和<em>validPasswordSignal</em>。你所需要做的就是将这两个信号结合用以决定何时能够将按钮启用。</p>
<p>在 viewDidLoad 方法中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal =</span><br><span class="line">  [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</span><br><span class="line">                    reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</span><br><span class="line">                      return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</span><br><span class="line">                    &#125;];</span><br></pre></td></tr></table></figure>
<p>上述代码使用了 <em>combineLatest:reduce:</em> 方法来结合 <em>validUsernameSignal</em> 和 <em>validUsernameSignal</em> 最后发送出来的值，并将其传入新的信号中。每次这两个源信号发送出新值的时候，reduce代码块都会被执行，并且代码块所返回的值会被结合信号发送给下一个事件。</p>
<blockquote>
<p>注意：RACSignal 的组合方法可以组合任意数量的信号，并且reduce代码块的参数会对应每个源信号。ReactiveCocoa有一个非常实用的工具类——RACBlockTrampoline，他会在内部响应reduce代码块的变量参数列表。事实上，在ReactiveCocoa的实现中隐藏了很多的小技巧，这些小技巧非常值得去研究。</p>
</blockquote>
<p>现在你有了适当的信号，在 viewDidLoad 方法的结尾添加如下代码。这将会连接到按钮的enable 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</span><br><span class="line">   self.signInButton.enabled = [signupActive boolValue];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>在运行代码之前，我们需要删除旧的的实现代码，在文件的顶部删除这两个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic) BOOL passwordIsValid;</span><br><span class="line">@property (nonatomic) BOOL usernameIsValid;</span><br></pre></td></tr></table></figure>
<p>在 viewDidLoad 方法附近删除如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// handle text changes for both text fields</span><br><span class="line">[self.usernameTextField addTarget:self</span><br><span class="line">                           action:@selector(usernameTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br><span class="line">[self.passwordTextField addTarget:self </span><br><span class="line">                           action:@selector(passwordTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br></pre></td></tr></table></figure>
<p>同样的也删除这几个方法updateUIState, usernameTextFieldChanged和passwordTextFieldChanged。</p>
<p>你刚删除的代码中有非常多的非响应式的代码。你将会感谢你刚所做的。</p>
<p>最终还要记得删除在 viewDidLoad 中对 updateUIState 方法的调用代码。</p>
<p>如果你构建并运行程序，检查一下登录按钮。就像之前一样，按钮应该是处于可用状态的，因为用户名和密码 textfield 目前都是有效的。</p>
<p>代码升级过后的应用程序逻辑图如下所示：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/CombinePipeline.png" alt="CombinePipeline"></p>
<p>上面说明了一些重要的概念，它们允许您使用ReactiveCocoa执行一些非常强大的任务:</p>
<ul>
<li>拆分：信号能够拥有多个订阅者，作为后续管道步骤的来源。在上图中boolean信号指示了用户名和密码的是否可用被拆分，并用于多个不同的目的。</li>
<li>组合：多个信号可以被合成为一个新的信号。在我们这个例子中，两个boolean信号被组合了。并且你能够组合多个信号，并使其传递出任何类型的值。</li>
</ul>
<p>这样做的结果是程序不在拥有指示两个 textfield 目前有效状态的的私有属性。这是你发现的在使用了响应式风格之后的关键改变，你不再需要使用实例变量去跟踪短暂的状态。</p>
<h2 id="响应式登录"><a href="#响应式登录" class="headerlink" title="响应式登录"></a>响应式登录</h2><p>应用程序现在使用了上面说明的响应式管道的方式来管理textfield 的状态和按钮。然而，按钮的点击事件仍然是使用的action 方式响应，所以接下来的工作就是将应用其余的逻辑改为使用响应式的方式实现。</p>
<p>在登录按钮上的<em>Touch Up Inside</em>是通过 storyboard 连线的方式连接RWViewController.m中的signInButtonTouched方法的。你将要使用响应式的方法代替它，所以你首先需要做的就是取消在 storyboard 中的方法连线。</p>
<p>打开<em>Main.storyboard</em>文件，找到登录按钮，ctrl+左键点击登录按钮调出outlet / action连线框，并点击 x 来移除这个方法。如果你感觉有点迷失，下图会帮助你找到删除方法的具体操作。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/DisconnectAction.jpg" alt="DisconnectAction"></p>
<p>现在你已经看到ReactiveCocoa框架如何为标准的 UIKit 框架控件添加属性和方法了。目前为止，你已经使用了rac_textSignal，它会在 textfield的文本改变的时候发送事件。为了响应按钮事件，你需要使用ReactiveCocoa 想 UIKit 框架中添加的其他方法——rac_signalForControlEvents。</p>
<p>回到<em>RWViewController.m</em>, 在viewDidLoad 方法的末尾添加如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;button clicked&quot;);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>上述代码从按钮的<em>UIControlEventTouchUpInside</em>事件之中创建了信号，并向其中添加了一个订阅者使得每次事件发生的时候都能够输出日志信息。</p>
<p>构建并运行程序，确保信息确实输出了。请记住按钮只有在用户名和密码有效的情况下才会被启用，所以确保你在点击按钮之前在两个 textfield 中均输入了正确的信息。</p>
<p>你应该会在Xcode 的控制台中输出如下信息:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">28</span> 08<span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">10.816</span> RWReactivePlayground[<span class="number">18203</span><span class="symbol">:a0b</span>] button clicked</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">28</span> 08<span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">11.675</span> RWReactivePlayground[<span class="number">18203</span><span class="symbol">:a0b</span>] button clicked</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">28</span> 08<span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">12.605</span> RWReactivePlayground[<span class="number">18203</span><span class="symbol">:a0b</span>] button clicked</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">28</span> 08<span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">12.766</span> RWReactivePlayground[<span class="number">18203</span><span class="symbol">:a0b</span>] button clicked</span><br><span class="line"><span class="number">2013</span>-<span class="number">12</span>-<span class="number">28</span> 08<span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">12.917</span> RWReactivePlayground[<span class="number">18203</span><span class="symbol">:a0b</span>] button clicked</span><br></pre></td></tr></table></figure>
<p>现在按钮已经拥有了响应触摸事件的信号，下一步要做的就是将其和登录过程本身联系起来。这时遇到了一个问题，这很好，然而你并不介意这个问题是吗？打开<em>RWDummySignInService.h</em> 并看一下这个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void (^RWSignInResponse)(BOOL);</span><br><span class="line"></span><br><span class="line">@interface RWDummySignInService : NSObject</span><br><span class="line"></span><br><span class="line">- (void)signInWithUsername:(NSString *)username</span><br><span class="line">                  password:(NSString *)password </span><br><span class="line">                  complete:(RWSignInResponse)completeBlock;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这个方法需要username、password和已完成block 作为参数传入。这个传入的 block会在登录成功或者登录失败的时候运行。你可以在目前是输出点击事件的 <em>subscribeNext:</em> block 中直接使用，但是为什么能这样呢？这是一个关于异步、基于事件行为的ReactiveCocoa的初次尝试。</p>
<blockquote>
<p>注意：为了简单起见，本教程中使用了虚拟服务，因此你并不需要其他外部的 api。然而你现在运行程序会遇到一个真实的问题，你如何使用不实用信号表达的 api。</p>
</blockquote>
<h2 id="创建信号"><a href="#创建信号" class="headerlink" title="创建信号"></a>创建信号</h2><p>幸运的是，将已存在的异步接口转换为信号相当简单。首先从<em>RWViewController.m</em>.中移除当前的 <em>signInButtonTouched:</em> 方法。你并不需要这种逻辑，因为这将会被等效的响应式风格的代码所替换。</p>
<p>在<em>RWViewController.m</em> 中添加如下方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(RACSignal *)signInSignal &#123;</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [self.signInService</span><br><span class="line">     signInWithUsername:self.usernameTextField.text</span><br><span class="line">     password:self.passwordTextField.text</span><br><span class="line">     complete:^(BOOL success) &#123;</span><br><span class="line">       [subscriber sendNext:@(success)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">     &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法创建了一个包含用户名和密码的登录信号。现在是时候对其组成部分进行细分了。</p>
<p>上述代码使用了信号的创建方法<em>createSignal:</em>。描述此信号的 block 是单个参数的，并传递给此方法。当这个信号拥有订阅者的时候，block 中的代码都会被执行。</p>
<p>block 传递一个遵循<em>RACSubscriber</em>协议的subscriber实例，这个协议具有发出事件的所调用的方法。你可以发送多个<em>next</em>事件，或者发出<em>error</em>或<em>complete</em>终结事件。在这个例子中，只发出了一个 <em>next</em> 事件来指示是否登录成功，接着是 <em>complete</em> 事件。</p>
<p>block 的返回值是一个 <em>RACDisposable</em> 对象，这对象允许你在订阅取消或者被丢弃的时候执行可能会需要的清理操作。如果信号并需要任何的清理操作就返回 nil。</p>
<p>正如你所见的，使用信号封装一个异步的api 是出奇的简单。</p>
<p>现在为了使用新信号，将你在上一节添加到viewDidLoad 结尾的方法更新为如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   map:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>上述代码使用之前使用的 <em>map</em> 操作符，将按钮的触摸信号转换为登录信号。订阅者会进行非常简单的输出。</p>
<p>如果你构建并运行，接着点击登录按钮，你会在 Xcode 的控制台中看到上述代码的结果，但是结果并不是你所期望的样子。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">01</span>-08 <span class="number">21</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">25.919</span> RWReactivePlayground[<span class="number">33818</span><span class="symbol">:a0b</span>] Sign <span class="keyword">in</span> <span class="symbol">result:</span></span><br><span class="line">                &lt;<span class="symbol">RACDynamicSignal:</span> <span class="number">0xa068a00</span>&gt; <span class="symbol">name:</span> +<span class="symbol">createSignal:</span></span><br></pre></td></tr></table></figure>
<p><em>subscribeNext:</em> block确实收到一个信号，但是这个信号并不是登录信号的结果。</p>
<p>是时候用图表来展示管道，用以指示到底发生了什么：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/SignalOfSignals.png" alt="SignalOfSignals"></p>
<p>当按钮点击的时候<em>rac_signalForControlEvents</em>发送一个 <em>next</em> 事件(以源按钮作为事件数据)。map 操作创建并返回一个登录信号，这表明管道的下一步现在接收到一个信号。这就是你在<em>subscribeNext:</em> 中观察到的步骤。</p>
<p>上面的情况有时被称为信号中的信号，换句话来说就是一个外部信号包裹着一个内部信号。如果你真的想，你可以在外部信号的<em>subscribeNext:</em> block中订阅内部信号。但是这回造成嵌套混乱！不过幸运的是这是一个常见的问题，并且<em>ReactiveCocoa</em>也已经为此情况准备了解决方案。</p>
<h2 id="信号中的信号"><a href="#信号中的信号" class="headerlink" title="信号中的信号"></a>信号中的信号</h2><p>这个问题的解决方案是十分直截了当的，只要将 map 操作符替换为flattenMap操作符即可。我们看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>就想之前的一样，这将按钮的触摸信号映射为登录信号，但也同时将内部信号的事件传递给外部信号。</p>
<p>构建并运行，注意观察控制台，现在应该输出的内容是登录是否成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign in result: 0</span><br><span class="line">2013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign in result: 1</span><br></pre></td></tr></table></figure>
<p>真是令人兴奋！</p>
<p>现在管道真正做了你所希望发生的事，最后一步就是在<em>subscribeNext</em>步骤中添加登录成功所需的跳转逻辑。使用如下代码替换管道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">  rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">  flattenMap:^id(id x) &#123;</span><br><span class="line">    return [self signInSignal];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">    BOOL success = [signedIn boolValue];</span><br><span class="line">    self.signInFailureText.hidden = success;</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><em>subscribeNext:</em>的block 中取到了登录信号的结果，相应地更新<em>signInFailureText</em>输入框的可见性，然后根据需要执行页面跳转。</p>
<p>构建并运行，然后再次享受可爱的猫咪吧。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/ReactivePlaygroundStarter.jpg" alt="ReactivePlaygroundStarter"></p>
<p>你是否注意到在目前的应用程序中的小小的影响用户体验的问题？当登录服务验证登录凭证的时候，登录按钮应该是处于不可用状态的，这是为了防止用户重复多次点击登录按钮。此外，当发生登录失败，用户再次点击登录按钮，这时候错误信息应该被隐藏。</p>
<p>但是如何在管道中添加这样的逻辑呢？更改按钮的状态并不是一个转变操作，也不是 filter 或者目前所见到的任何的概念。相反，它就是所谓的副作用;或者想要在下一个事件发生时在管道中执行的逻辑，但它实际上并没有改变事件本身的性质。</p>
<h2 id="添加副作用"><a href="#添加副作用" class="headerlink" title="添加副作用"></a>添加副作用</h2><p>使用如下的代码代替现有管道:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   doNext:^(id x) &#123;</span><br><span class="line">     self.signInButton.enabled = NO;</span><br><span class="line">     self.signInFailureText.hidden = YES;</span><br><span class="line">   &#125;]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">     self.signInButton.enabled = YES;</span><br><span class="line">     BOOL success = [signedIn boolValue];</span><br><span class="line">     self.signInFailureText.hidden = success;</span><br><span class="line">     if (success) &#123;</span><br><span class="line">       [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>你可以看到如何在按钮触摸事件被创建之后将<em>doNext:</em>步骤添加到管道。请注意，<em>doNext:</em> 的 block 并没有任何的返回值，因为这是一个副作用，这不会造成事件本身的改变。</p>
<p>上面<em>doNext:</em> 的 block将按钮的 enable 属性设置为 NO，并隐藏失败信息。同时<em>subscribeNext:</em>的 block 又重新启用按钮，但是并不基于登录结果来显示或者隐藏失败信息。</p>
<p>是时候升级包含副作用的示意图了，请尽情享受它带给你的便捷：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第1-2部分/SideEffects.png" alt="SideEffects"></p>
<p>构建并运行程序以确保登录按钮会如你所期望的那样启用或禁用按钮，显示或隐藏信息。</p>
<p>并且，到这里你的任务就已经完成了，现在应用程序中的完全是响应式的了。</p>
<p>如果你感到迷失，你可以在这里下载<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Final.zip" target="_blank" rel="noopener">最终的项目</a>，或者你也可以在 <a href="https://github.com/ColinEberhardt/RWReactivePlayground" target="_blank" rel="noopener">GitHub</a> 上获取代码。其中有一个提交匹配本教程中的每个构建和运行步骤。</p>
<blockquote>
<p>注意：当异步活动正在进行的时候禁用按钮是一个常见的问题，<em>ReactiveCocoa</em> 的小问题再次出现。<em>RACCommand</em>包裹了这个概念，并且有一个启用的信号，允许您将按钮的启用属性连接到信号。您可能想尝试一下这个类。</p>
</blockquote>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>希望本教程为您提供了一个很好的基础，可以帮助您在自己的应用程序中开始使用ReactiveCocoa。习惯这些概念可能需要一些练习，但就像任何语言或程序一样，一旦掌握了它，它就会非常简单。 ReactiveCocoa的核心是信号，它们只不过是事件流。有什么比这更简单？</p>
<p>使用ReactiveCocoa我发现的一个有趣的事情是有很多方法可以解决同样的问题。您可能希望尝试使用此应用程序，并调整信号和管道以更改它们拆分和组合的方式。</p>
<p>值得考虑的是ReactiveCocoa的主要目标是使您的代码更清晰，更易于理解。就我个人而言，如果使用流畅的语法将其逻辑表示为清晰的管道，我会发现更容易理解应用程序的作用。</p>
<p>在本系列教程的第二部分——<a href="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/" title="ReactiveCocoa教程 - 权威介绍：第2/2部分">ReactiveCocoa教程 - 权威介绍：第2/2部分</a>中，您将学习更高级的主题，例如错误处理以及如何管理在不同线程上执行的代码。在那之前，玩得开心！</p>
]]></content>
      <tags>
        <tag>iOS翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>arm汇编命令</title>
    <url>/2021/12/02/arm%E6%B1%87%E7%BC%96%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="寄存器组成"><a href="#寄存器组成" class="headerlink" title="寄存器组成"></a>寄存器组成</h3><p>arm64 通用寄存器：x0~x30 一共31 个64bit 寄存器。这 31 个通用的 64bit 寄存器又各包含了一个 32bit 寄存器w0~w30，一个 31 个 32bit 通用寄存器。</p>
<p>通用寄存器：</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:left">寄存器名称</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x0~x7</td>
<td>用于传递子程序的参数，使用时不需要保存，多余参数保存在调用者栈中，通过栈传递给被调用函数。其中x0寄存器还可以作为返回值寄存器使用。</td>
</tr>
<tr>
<td style="text-align:left">x8</td>
<td>间接结果寄存器，使用时不需要保存，一般用于传递间接结果的地址，比如函数返回一个大的结构体，x8保存结构体地址。</td>
</tr>
<tr>
<td style="text-align:left">x9~x15</td>
<td>临时寄存器，子程序使用时不需要保存。</td>
</tr>
<tr>
<td style="text-align:left">x16~x17</td>
<td>又名IP0、IP1，内部过程调用寄存器，常用于动态链接中的plt寻址等指令。</td>
</tr>
<tr>
<td style="text-align:left">x18</td>
<td>平台预留寄存器，在不同的操作系统使用不一样。</td>
</tr>
<tr>
<td style="text-align:left">x19~x28</td>
<td>临时寄存器，子程序使用时必须保存。</td>
</tr>
<tr>
<td style="text-align:left">x29</td>
<td>帧指针寄存器（FP），用于连接栈帧，使用时必须保存。</td>
</tr>
<tr>
<td style="text-align:left">x30</td>
<td>链接寄存器（LR），用于保存子程序的返回地址。</td>
</tr>
</tbody>
</table>
<p>特殊作用的几个寄存器：</p>
<ul>
<li>pc 寄存器：用作程序计数器，功能相当于 8086 的 cs+ip 的功能。不是通用寄存器，无法直接访问。</li>
<li>sp 寄存器：别名是SP_EL0，用于存放当前栈顶指针。</li>
<li>fp寄存器：用于存放当前栈底指针，栈顶指针和栈底指针之间的空间是当前栈空间，在 backtrace 时可以查看到方法调用栈。</li>
<li>lr寄存器：当程序调用子程序时，lr 储存程序的返回地址。</li>
<li>程序状态寄存器：正常状态使用CPSR，异常状态使用SPSR，类似 8086 的标志寄存器。</li>
</ul>
<p>注意：没有名为 X31/W31 的寄存器，根据指令不同，寄存器 31 是栈指针(SP)或者零寄存器(32bit：WZR或64bit：XZR)。</p>
<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="指令分组"><a href="#指令分组" class="headerlink" title="指令分组"></a>指令分组</h3><p>指令分为四组：</p>
<ol>
<li>分支和控制：<ul>
<li>分支到子程序，并从子程序返回。</li>
<li>向后分支，以形成循环。</li>
<li>在条件结构中向前分支。</li>
<li>产生和返回异常。</li>
</ul>
</li>
<li>数据处理：这些指令使用通用寄存器进行加减、移位等操作。</li>
<li>寄存器加载和存储：这些指令从内存加载或从单个寄存器或寄存器对的值。</li>
<li>系统寄存器访问：这些指令将系统寄存器的内容移到通用寄存器或从通用寄存器移出。</li>
</ol>
<h3 id="具体指令"><a href="#具体指令" class="headerlink" title="具体指令"></a>具体指令</h3><h4 id="分支和控制指令"><a href="#分支和控制指令" class="headerlink" title="分支和控制指令"></a>分支和控制指令</h4><p>B：无条件转移指令，跳转到一个与 PC 相关的偏移量，类似 8086 的 jmp指令。</p>
<p>BL：无条件转移指令，跳转到 PC 相关的偏移量，并且 X30(PC)+=4。类似 8086 的 call指令，将保存SP、FP、LR和参数寄存器到栈，类似 8086 的 call 指令。</p>
<p>RET：从子程序返回。</p>
<h5 id="转移条件"><a href="#转移条件" class="headerlink" title="转移条件"></a>转移条件</h5><table>
<thead>
<tr>
<th>后缀</th>
<th>标志</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td>Z = 1</td>
<td>相等，上次标志设置结果为零</td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Z = 0</td>
<td>不相等，最后一次标志设置结果非零</td>
</tr>
<tr>
<td><code>CS or HS</code></td>
<td>C = 1</td>
<td>更高或相同，无符号</td>
</tr>
<tr>
<td><code>CC or LO</code></td>
<td>C = 0</td>
<td>较低，无符号</td>
</tr>
<tr>
<td><code>MI</code></td>
<td>N = 1</td>
<td>负的</td>
</tr>
<tr>
<td><code>PL</code></td>
<td>N = 0</td>
<td>正或零</td>
</tr>
<tr>
<td><code>VS</code></td>
<td>V = 1</td>
<td>溢出</td>
</tr>
<tr>
<td><code>VC</code></td>
<td>V = 0</td>
<td>无溢出</td>
</tr>
<tr>
<td><code>HI</code></td>
<td>C = 1 和 Z = 0</td>
<td>更高，无符号</td>
</tr>
<tr>
<td><code>LS</code></td>
<td>C = 0 或 Z = 1</td>
<td>较低或相同，无符号</td>
</tr>
<tr>
<td><code>GE</code></td>
<td>N = V</td>
<td>大于或等于，有符号</td>
</tr>
<tr>
<td><code>LT</code></td>
<td>N != V</td>
<td>小于，已签</td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Z = 0 且 N = V</td>
<td>大于，有符号</td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Z = 1 和 N != V</td>
<td>小于或等于，有符号</td>
</tr>
<tr>
<td><code>AL</code></td>
<td>可以有任何价值</td>
<td>总是。这是未指定后缀时的默认值。</td>
</tr>
</tbody>
</table>
<h4 id="寄存器加载和存储指令"><a href="#寄存器加载和存储指令" class="headerlink" title="寄存器加载和存储指令"></a>寄存器加载和存储指令</h4><p>在 ARM 中一个字(word)是32-bits，双字(dword)是64-bits。</p>
<h6 id="load-加载"><a href="#load-加载" class="headerlink" title="load 加载"></a>load 加载</h6><p>LDR：据基址寄存器值和偏移寄存器值计算内存地址加载数据，从内存中加载一个字(32bit)，并加载到指定寄存器。</p>
<p>LDUR：基址寄存器和立即偏移量计算内存地址，取其 32 或 64 位数据，并对其使用0 补充，并加载到指定寄存器。</p>
<h6 id="store-存储"><a href="#store-存储" class="headerlink" title="store 存储"></a>store 存储</h6><p>STR：根据基址寄存器值和偏移寄存器值计算内存地址，将 32 或 64 位信息从寄存器保存内存。</p>
<p>STUR：根据基址寄存器值和立即偏移量计算地址，将 32 或 64 位信息从寄存器保存内存。</p>
<p>STP：根据基址寄存器值和立即偏移量计算地址，并将两个 32 位字或两个 64 位双字从两个寄存器存储到计算出的地址。</p>
<h4 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h4><p>ADD：加法。</p>
<p>ADC：进位加法。</p>
<p>ADCS：进位加法，设置标志位，并根据加法结果设置条件标志。</p>
<p>SUB：减法。</p>
<p>AND：按位与。</p>
<p>ORR：按位或。</p>
<p>UDIV：无符号除法。</p>
<p>SDIV：带符号除法。</p>
<p>MADD：乘法，<code>MADD &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Wa&gt;</code>类似于<code>Wd = Wn * Wm + Wa</code>，该指令由 MUL 使用。</p>
<p>MUL：乘法，MADD 的别名。</p>
<p>MOV：赋值指令。</p>
<p>CMP：将两个寄存器内容或者立即数相减，根据结果设置标志位，并丢弃结果。</p>
<blockquote>
<p>资料:</p>
<p><a href="https://developer.arm.com/documentation/102374/0101?lang=en" target="_blank" rel="noopener">学习AArch64指令集架构</a></p>
<p><a href="https://support.huaweicloud.com/ref-kunpenggrf/kunpenggrffaq_10_0057.html#kunpenggrffaq_10_0057__table106609423185" target="_blank" rel="noopener">ARM 64通用寄存器-华为云</a></p>
<p><a href="https://developer.arm.com/documentation/dui0801/k/Overview-of-AArch64-state?lang=en" target="_blank" rel="noopener">AArch64 状态概览-armDeveloper</a></p>
<p><a href="https://developer.arm.com/documentation/ddi0602/2021-09" target="_blank" rel="noopener">Arm Armv9-A A64 指令集架构</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
        <tag>iOS逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS CALayer 教程:入门</title>
    <url>/2019/01/01/iOS-CALayer-%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>原文链接:<a href="https://www.raywenderlich.com/402-calayer-tutorial-for-ios-getting-started" target="_blank" rel="noopener">CALayer Tutorial for iOS: Getting Started</a></p>
<p>作者:Michael Ciurus</p>
<p>最近在研究 CALayer 和 UIView 之间的联系和区别，看完这篇文章介绍的 <code>CALayer</code>子类和其使用介绍的挺详细的，所以翻译一下这篇文章。</p>
<p>译者注：原文中 layer 可能在文章中被翻译为’图层’，corner radius 被翻译为’角半径’</p>
</blockquote>
<p>在这篇教程中，你将会学习到什么是<code>CALayer</code>，并且能看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p><strong>升级说明</strong>：本教程已由<a href="https://www.raywenderlich.com/u/michalciurus" target="_blank" rel="noopener">Michael Ciurus</a>升级到 iOS11，Swift4和Xcode9。原教程作者是<a href="https://www.raywenderlich.com/u/scotteg" target="_blank" rel="noopener">Scott Gardner</a>。</p>
<p>可能正如你知道的，在 iOS App 中你看到的所有的东西都是View。有button view,table view,slider view,甚至是包含其他视图的父视图。</p>
<p>你可能不知道的是每个在 iOS 中的每个 view都由一个另外的名为图层——<code>CALayer</code>的类提供支持。</p>
<p>在本篇教程中，你将会了解到什么是<code>CALayer</code>并且知道它是如何工作的。你同样也会看到十种使用<code>CALayer</code>生成酷炫效果的例子，例如图形，渐变，甚至是例子系统。</p>
<p>本文章的前提是你已经了解了作为 iOS App 的基础和Swift，包括使用 storyboard构建 UI。</p>
<a id="more"></a>
<blockquote>
<p><strong>注意：</strong>如果你并不擅长这个，别担心。我们关于这个主题我们有多个教程和书籍，例如 <a href="http://www.raywenderlich.com/77176/learn-to-code-iOS-apps-with-swift-tutorial-4" target="_blank" rel="noopener">Learn to Code iOS Apps with Swift</a>and <a href="http://www.raywenderlich.com/store/iOS-apprentice" target="_blank" rel="noopener">The iOS Apprentice</a>。</p>
</blockquote>
<h2 id="CALayer-和UIView-有何关系？"><a href="#CALayer-和UIView-有何关系？" class="headerlink" title="CALayer 和UIView 有何关系？"></a>CALayer 和UIView 有何关系？</h2><p><code>UIView</code>处理非常多的事情，例如：布局、响应事件等。有一点很有意思，<code>UIView</code>并不直接参与处理绘制或者动画，而是<code>UIView</code>将其交付给它的兄弟——<code>Core Animation</code>来处理。事实上<code>UIView</code>是<code>CALayer</code>的包装容器。当你在一个<code>UIView</code>上设置了<code>bounds</code>之后，视图只是将<code>bounds</code>设置在了其背后的<code>CALayer</code>上。如果你在<code>UIView</code>上调用了<code>layoutIfNeed</code>方法，该方法会转发给其根<code>CALayer</code>。每个<code>UIView</code>都有一个能够拥有<code>subLayers</code>的根<code>CALayer</code>。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/uiview.png" alt="uiview"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>最简单的了解<code>layer</code>是什么的途径就是在看它们在实际运用中的效果。你将会从一个简单的项目开始使用layers。<a href="https://koenig-media.raywenderlich.com/uploads/2017/08/LayerStarterProject.zip" target="_blank" rel="noopener">下载</a>这个简单的只在中心插入了视图的 App。</p>
<p>在 <strong>ViewController.swift</strong>中使用如下代码替换其内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> viewForLayer: <span class="type">UIView</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> layer: <span class="type">CALayer</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> viewForLayer.layer</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setUpLayer()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">setUpLayer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    layer.backgroundColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line">    layer.borderWidth = <span class="number">100.0</span></span><br><span class="line">    layer.borderColor = <span class="type">UIColor</span>.red.cgColor</span><br><span class="line">    layer.shadowOpacity = <span class="number">0.7</span></span><br><span class="line">    layer.shadowRadius = <span class="number">10.0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如之前提到的，每一个<code>UIView</code>都有一个<code>layer</code>与其关联，并且你能够是用<code>.layer</code>获得它。以上代码的第一件事情就是创建了一个名为<code>layer</code>的计算属性来访问<code>viewForLayer</code>的<code>layer</code>。</p>
<p>代码中同样也调用了<code>setUpLayer()</code>方法，用以设置图层的一些属性——阴影、蓝色的背景颜色和巨大的红色边框颜色。等会你将会学习到更多关于<code>setUpLayer()</code>方法，但是现在首先要做的事情是构建并运行iOS模拟器来查看你自己定义的图层。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-1-281x500.png" alt=""></p>
<p>只使用了短短几句代码就实现了酷炫的效果，对吧？并且由于所有的<code>view</code>都是由<code>layer</code>提供支持的，所以你可以在你的 app 中对所有的视图做如上操作。</p>
<h2 id="基础CALayer属性"><a href="#基础CALayer属性" class="headerlink" title="基础CALayer属性"></a>基础<code>CALayer</code>属性</h2><p><code>CALayer</code>拥有一些列的方法让你可以自定义外观。回想一下你刚才所做的事情:</p>
<ul>
<li>将其图层的背景颜色从默认的无颜色设置为蓝色。</li>
<li>改变图层的<code>borderWidth</code>从默认的0设置为100来赋予其边框。</li>
<li>改变其边框颜色，从默认的黑色改变为红色。</li>
<li>并且最后，改变其<code>shadowOpacity</code>属性，从默认的0(完全透明)到0.7，来赋予其阴影。仅这一点就会使得阴影显示出来，然后下一步增加了其阴影半径，从默认的3到10。</li>
</ul>
<p>这还只是您可以在<code>CALayer</code>设置的部分属性。接下来我们继续尝试两个属性。在<code>setUpLayer()</code>的底部添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>在<code>CALayer</code>中的<code>contents</code>属性允许你使用图片设置其内容，所以在这里你是使用名为’star’的图片设置了其图层内容。该图片已经在初始项目中提供。</p>
<p>构建并运行然后花点时间欣赏一下那令人惊叹的艺术品:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-2-179x320.png" alt="CALayerPlayground-2"></p>
<p>为什么五角星会在被定位在中心呢？这是因为你将<code>kCAGravityCenter</code>设置到了其属性<code>contentsGravity</code>上。正如你所预料的那样，你同样能够将其位置设置为顶部、顶部偏右、右侧、底部偏右、底部、底部偏左、左侧和顶部偏左。</p>
<h2 id="改变图层的外观"><a href="#改变图层的外观" class="headerlink" title="改变图层的外观"></a>改变图层的外观</h2><p>初始项目包含了<code>tap</code>和<code>pinch</code>的手势识别器。</p>
<p>将<code>tapGestureRecognized(_:)</code>方法改变为如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tapGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">  layer.shadowOpacity = layer.shadowOpacity == <span class="number">0.7</span> ? <span class="number">0.0</span> : <span class="number">0.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码将告诉<code>viewForLayer</code>的图层当视图响应<code>tap</code>时，将其图层的阴影不透明在0和0.7之间切换。</p>
<p>你可能会问，那视图呢？当然你也可以覆写<code>CALayer</code>的 <code>hitTest(_:)</code> 来做同样的事情，并且你也会在本文的后面看到这种方式。但是<code>hitTest</code>是图层能做的全部了，因为图层无法响应手势识别器。这就是为什么你在视图中创建<code>tap</code>的手势识别器。</p>
<p>现在将 <code>pinchGestureRecognized(_:)</code> 中的实现改为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">pinchGestureRecognized</span><span class="params">(<span class="number">_</span> sender: UIPinchGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> offset: <span class="type">CGFloat</span> = sender.scale &lt; <span class="number">1</span> ? <span class="number">5.0</span> : -<span class="number">5.0</span></span><br><span class="line">  <span class="keyword">let</span> oldFrame = layer.frame</span><br><span class="line">  <span class="keyword">let</span> oldOrigin = oldFrame.origin</span><br><span class="line">  <span class="keyword">let</span> newOrigin = <span class="type">CGPoint</span>(x: oldOrigin.x + offset, y: oldOrigin.y + offset)</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="type">CGSize</span>(width: oldFrame.width + (offset * -<span class="number">2.0</span>), height: oldFrame.height + (offset * -<span class="number">2.0</span>))</span><br><span class="line">  <span class="keyword">let</span> newFrame = <span class="type">CGRect</span>(origin: newOrigin, size: newSize)</span><br><span class="line">  <span class="keyword">if</span> newFrame.width &gt;= <span class="number">100.0</span> &amp;&amp; newFrame.width &lt;= <span class="number">300.0</span> &#123;</span><br><span class="line">    layer.borderWidth -= offset</span><br><span class="line">    layer.cornerRadius += (offset / <span class="number">2.0</span>)</span><br><span class="line">    layer.frame = newFrame</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你基于用户的<code>pinch</code>来创建一个正的或者一个负的偏移量，并接着调整图层<code>frame</code>中的大小、边框宽度和边框的角半径。</p>
<p>一个图层(layer)的角半径默认是零，这就意味着此时是标准的拥有90度角的正方形。可以通过增加角半径来创建圆角。想要将正方形转变为圆形？只需要将其角半径设置为其宽度的一半。</p>
<p>构建并运行，然后尝试点击和捏合你的视图:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayerPlayground-3-179x320.png" alt="CALayerPlayground-3"></p>
<p>只需要一点润色你就可以自己拥有一个非常漂亮的头像。</p>
<h2 id="很棒的CALayer-之旅"><a href="#很棒的CALayer-之旅" class="headerlink" title="很棒的CALayer 之旅"></a>很棒的CALayer 之旅</h2><p><code>CALayer</code>不仅仅只拥有方法和属性可以设置，它还有一系列具有特有方法和属性子类。</p>
<p>有什么比查看教程更好的符合raywenderlich.com风格的方式来了解这些很棒的 API 呢?</p>
<p>在本文接下来的部分中，你需要如下准备：</p>
<ul>
<li><a href="https://github.com/raywenderlich/LayerPlayer" target="_blank" rel="noopener">The Layer Player Source Code</a></li>
<li><a href="http://bit.ly/AppStoreLayerPlayer" target="_blank" rel="noopener">The Layer Player App (可选)</a></li>
</ul>
<p>这是一个拥有你将在本文中学习到的十种不同<code>CALayer</code>子类范例的便捷 App。这里有许多很棒的例子：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/starter-480x285.png" alt="Layer Player screenshots"></p>
<p>当你浏览下面每个例子之前，我建议你先使用一下上述<code>CALayer</code>的 App，并且看看源码。在本文的剩余部分中，你并不需要真正写任何代码，所以请放心坐下并防松阅读。</p>
<h2 id="范例1：CALayer"><a href="#范例1：CALayer" class="headerlink" title="范例1：CALayer"></a>范例1：CALayer</h2><p>你已经看过了使用<code>CALayer</code>的例子，并且设置了一些它的属性。</p>
<p>以下还有一些之前尚未提到过的内容：</p>
<ul>
<li><strong>图层能够拥有子图层</strong>。就类似视图能够拥有子视图一样，图层能够拥有子图层。你可以使用这个来创建一些酷炫的效果。</li>
<li><strong>图层属性具有动画效果</strong>。当你改变了图层的属性，默认情况下会对其进行动画处理。你也可以根据自己的时间来自定义动画行为。</li>
<li><strong>图层是轻量级的</strong>。图层相较于视图来说更加轻量级，因此它能够带来更高的性能。</li>
<li><strong>图层拥有大量使用的属性</strong>。你已经在之前看到过其部分的属性了，现在让我们看更多属性。</li>
</ul>
<p>你接下来将会看到<code>CALayer</code>的一个完整属性列表，其中有部分你还尚未接触过，它们非常方便！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> layer = <span class="type">CALayer</span>()</span><br><span class="line">layer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line">layer.contents = <span class="type">UIImage</span>(named: <span class="string">"star"</span>)?.cgImage</span><br><span class="line">layer.contentsGravity = kCAGravityCenter</span><br></pre></td></tr></table></figure>
<p>正如你之前看到的，上述代码是创建了一个<code>CALayer</code>实例，并将<code>someView</code>的<code>bounds</code>赋值给它。接着将图片设置为图层的内容并将其在图层内居中。请注意，此处使用的是底层Quartz图片数据(<code>CGImage</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.magnificationFilter = kCAFilterLinear</span><br><span class="line">layer.isGeometryFlipped = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当图片通过<code>contentsGravity</code>被扩大尺寸时使用如上滤镜，这可以用于调整尺寸(调整大小、调整宽高比和调整宽高比填充)和位置(例如：中心、顶部、顶部偏右、右侧等)。</p>
<p>如上的变更并不具有动画效果，并且如果<code>isGeometryFlipped</code>并非被设置为<code>true</code>。那么该图层的几何位置和阴影将会上下颠倒。我们接着继续：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">11</span>/<span class="number">255.0</span>, green: <span class="number">86</span>/<span class="number">255.0</span>, blue: <span class="number">14</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">layer.opacity = <span class="number">1.0</span></span><br><span class="line">layer.isHidden = <span class="literal">false</span></span><br><span class="line">layer.masksToBounds = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>你将图层的颜色设置为Ray 最喜欢的绿色阴影。这能够使得图层不透明并且可见。同时，你告诉图层不要遮罩其本身内容，这意味着当其本身尺寸大小小于其内容(五角星形图片)时，图片不会被裁剪。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.cornerRadius = <span class="number">100.0</span></span><br><span class="line">layer.borderWidth = <span class="number">12.0</span></span><br><span class="line">layer.borderColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>将图层的角半径设置为其宽度的一半，这样来创建出一个圆形带边框的图层。请注意这里的图层颜色将被设置为Quartz颜色的引用(<code>CGColor</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.shadowOpacity = <span class="number">0.75</span></span><br><span class="line">layer.shadowOffset = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">layer.shadowRadius = <span class="number">3.0</span></span><br><span class="line">someView.layer.addSublayer(layer)</span><br></pre></td></tr></table></figure>
<p>你创建了阴影并且将<code>shouldRasterize</code>属性设置为<code>true</code>(稍后讨论)，接着将图层添加到视图层次中。</p>
<p>最终结果如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CALayer-250x250.png" alt="CALayer"></p>
<p><code>CALayer</code>拥有两个额外属性，这两个额外的属性可以提升其性能：<code>shouldRasterize</code> 和 <code>drawsAsynchronously</code>。</p>
<p><code>shouldRasterize</code>默认是<code>false</code>，并且当其被设置为<code>true</code>的时候能够提升性能，这是因为图层只需要被渲染一次。这对于那些在屏幕内具有动画效果但是外观不会改变的对象十分有用。</p>
<p><code>drawsAsynchronously</code>与<code>shouldRasterize</code>洽洽相反。<code>shouldRasterize</code>默认也是<code>false</code>。当图层内容被反复绘制的时候将该属性设置为<code>true</code>将会提升性能，例如当你使用<code>emitter layer</code>持续渲染具有动效的粒子。(在随后的<code>CAEmitterLayer</code>例子中可以看到)</p>
<blockquote>
<p>一句忠告：在设置<code>drawsAsynchronously</code>或<code>shouldRasterize</code>之前先考虑其意义。对比在开启和关闭这两项特性时的性能，这样你能够真正了解这两项性能是否真的能够带来性能上的提升。如果误用，可能会导致性能急转直下。</p>
</blockquote>
<p>现在将你的注意力转移到<strong>Layer Player</strong>上。它包含了多个控件来控制<code>CALayer</code>的属性:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/1-180x320.png" alt="CALayer properties"></p>
<p>试试调节各个控件吧，这是一个很棒的方式来让你了解<code>CALayer</code>到底能够做什么！</p>
<blockquote>
<p>注意：图层并不是响应连的一部分，因此他们并不向视图一样响应直接响应手势和触摸，正如你在CALayerPlayground项目中看到的那样。</p>
<p>然而你可以对其进行点击测试(hit test)，正如你在<code>CATransformLayer</code>实例代码中看到的那样。当你看到<code>CAReplicatorLayer</code>时你将会看到你同样可以对图层的动画进行自定义。</p>
</blockquote>
<h2 id="范例2：CAScrollLayer"><a href="#范例2：CAScrollLayer" class="headerlink" title="范例2：CAScrollLayer"></a>范例2：CAScrollLayer</h2><p><code>CAScrollLayer</code>展示一个可滑动图层的一部分。<code>CAScrollLayer</code>相当基础并且无法直接响应触摸或者用户点击事件来检测可滑动视图的边界，但是它可以做一些有意思的事情，例如：可以防止滑动超出其边界范围。</p>
<p><code>UIScrollView</code>并未使用<code>CAScrollLayer</code>来完成其工作，而是使用直接改变其图层边界的方式代替它。</p>
<p><code>CAScrollLayer</code>能够将其本身设置为横向或者纵向滑动或者横向纵向均可滑动，并且可以通过编程的方式来告诉它滑动到一个特殊的点或者区域。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> scrollingViewLayer: <span class="type">CAScrollLayer</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> scrollingView.layer <span class="keyword">as</span>! <span class="type">CAScrollLayer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  scrollingViewLayer.scrollMode = kCAScrollBoth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">panRecognized</span><span class="params">(<span class="number">_</span> sender: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newPoint = scrollingView.bounds.origin</span><br><span class="line">  newPoint.x -= sender.translation(<span class="keyword">in</span>: scrollingView).x</span><br><span class="line">  newPoint.y -= sender.translation(<span class="keyword">in</span>: scrollingView).y</span><br><span class="line">  sender.setTranslation(<span class="type">CGPoint</span>.zero, <span class="keyword">in</span>: scrollingView)</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  scrollingViewLayer.scroll(to: newPoint)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> sender.state == .ended &#123;</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollingViewLayer.scroll(to: <span class="type">CGPoint</span>.zero)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中：</p>
<ol>
<li>计算属性用于返回<code>scrollingView</code>的图层为<code>CAScrollLayer</code>。</li>
<li>将滑动模式设置为横向纵向均可滑动。</li>
<li>当滑动手势被识别，一个新的点会在此时被创建出来并且滑动图层会以使用<code>UIView</code>动画的方式滑动到这个点。注意<code>scroll(to:)</code>并没有自带动画效果。</li>
</ol>
<p>Layer Player演示了一个拥有图片视图的CAScrollLayer，这个图片视图带有一个图片，这个图片超过其滑动视图的边界。当你运行上述代码，并移动视图，其结果应该如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAScrollLayer.gif" alt="CAScrollLayer"></p>
<p> Layer Player包含了两个控件用以锁定水平滑动或者竖直滑动。</p>
<p>以下是一些当你使用(或者不适用)<code>CAScrollLayer</code>的经验之谈:</p>
<ul>
<li>当你想要一些轻量级并且只能通过代码来滑动，那么不妨考虑一下使用<code>CAScrollLayer</code>。</li>
<li>如果你想要用户能够滑动，可能使用<code>UIScrollView</code>更好。想要了解更多这方面的东西，请点击我们的课程 <a href="http://www.raywenderlich.com/93104/video-tutorial-swift-scroll-view-school-part-0-introduction" target="_blank" rel="noopener">18-part video tutorial series</a>。</li>
<li>如果你是滑动一个非常巨大的图片，请考虑使用<code>CATiledLayer</code>(稍后将会带来讲解)。</li>
</ul>
<h2 id="范例3：CATextLayer"><a href="#范例3：CATextLayer" class="headerlink" title="范例3：CATextLayer"></a>范例3：CATextLayer</h2><p><code>CATextLayer</code>能够简单并且快速渲染普通字符串或者属性字符串(attributed strings)。和<code>UILabel</code>不同的是<code>CATextLayer</code>无法拥有<code>UIFont</code>，它只能使用<code>CTFontRef</code>或者<code>CGFontRef</code>。</p>
<p>在如下的代码块中，能够改变字体、字体大小、颜色、对其方式、文字截断方式以及其动画效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> textLayer = <span class="type">CATextLayer</span>()</span><br><span class="line">textLayer.frame = someView.bounds</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="type">String</span>(</span><br><span class="line">  repeating: <span class="string">"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit </span></span><br><span class="line"><span class="string">             congue dictum. "</span>,</span><br><span class="line">  <span class="built_in">count</span>: <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">textLayer.string = string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">textLayer.font = <span class="type">CTFontCreateWithName</span>(fontName, fontSize, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">textLayer.foregroundColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line">textLayer.alignmentMode = kCAAlignmentLeft</span><br><span class="line">textLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">someView.layer.addSublayer(textLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码说明:</p>
<ol>
<li>创建<code>CATextLayer</code>实例并且将<code>someView</code>的视图边界设置给它。</li>
<li>创建重复的字符串文本，并将其设置给文字图层(text layer)。</li>
<li>创建字体，并将字体设置到文字图层上(text layer)。</li>
<li>设置图层能够换行并且左对齐，(你可以对其方式设置为自然对其方式、右对齐、居中、和文本对其)并且将其<code>contentsScale</code>到屏幕，然后将它加入视图层。</li>
</ol>
<p>所有图层类，不止是<code>CATextLayer</code>渲染放大因子(scale factor)默认为1。当图层依附于视图(view)时，图层会自动拥有一个适应当前屏幕所最合适的放大因子。你需要手动为图层创建确切的<code>contentsScale</code>，或者他们的放大因素为1，但是会在 retain 屏幕上显示像素化。</p>
<p>如果添加到方形<code>UIView</code>中，被创建出的文字图层可能会如下所示:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-250x250.png" alt="CATextLayer"></p>
<p>当你希望使用省略号代表被剪切的文本时，截断(Truncation)是你可以使用的非常合适的设置。截断(Truncation)默认是无(none)，但是你也可以设置为起始位置、中间位置和结束位置：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-StartTruncation.png.png" alt="起始位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-MiddleTruncation.png.png" alt="中间位置"></p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATextLayer-EndTruncation.png" alt="结束位置"></p>
<p>Layer Player拥有多个控件来改变<code>CATextLayer</code>的值:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/3-180x320.png" alt="CATextLayer 属性"></p>
<h2 id="范例4：AVPlayerLayer"><a href="#范例4：AVPlayerLayer" class="headerlink" title="范例4：AVPlayerLayer"></a>范例4：AVPlayerLayer</h2><p><code>AVPlayerLayer</code>向AVFoundation中添加了一个美妙好用的图层。它拥有一个<code>AVPlayer</code>来播放音视频多媒体文件(<code>AVPlayerItem</code>)。如下是一个创建<code>AVPlayerLayer</code>的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> player: <span class="type">AVPlayer</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> playerLayer = <span class="type">AVPlayerLayer</span>()</span><br><span class="line">  playerLayer.frame = someView.bounds</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"someVideo"</span>, withExtension: <span class="string">"m4v"</span>)</span><br><span class="line">  player = <span class="type">AVPlayer</span>(url: url!)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  player.actionAtItemEnd = .<span class="keyword">none</span></span><br><span class="line">  playerLayer.player = player</span><br><span class="line">  someView.layer.addSublayer(playerLayer)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                         selector: #selector(playerDidReachEnd),</span><br><span class="line">                                         name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                         object: player.currentItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的接要点如下:</p>
<ul>
<li>创建一个新的播放图层(playerLayer)并设置其边界</li>
<li>使用音视频文件创建播放器(player)</li>
<li>告诉播放器当其播放停止时不做任何额外的操作。额外的操作包括有暂停或播放下一个音视频文件，如果情况允许的话。</li>
<li>注册一个多媒体播放器停止播放的通知。(并将控制器作为观察者在控制器析构的时候移除)。</li>
</ul>
<p>接着，当播放按钮被点击时，播放音视频文件并且设置按钮标题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">playButtonTapped</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> playButton.titleLabel?.text == <span class="string">"Play"</span> &#123;</span><br><span class="line">    player.play()</span><br><span class="line">    playButton.setTitle(<span class="string">"Pause"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    player.pause()</span><br><span class="line">    playButton.setTitle(<span class="string">"Play"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在播放器播放结束时将播放光标移动到初始位置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">playerDidReachEnd</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> playerItem = notification.object <span class="keyword">as</span>! <span class="type">AVPlayerItem</span></span><br><span class="line">  playerItem.seek(to: kCMTimeZero, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意这里只是一个让你入门的简单示例，在真实的项目中，通常不建议切换按钮的标题。</p>
<p>使用以上代码创建出来的 <code>AVPlayerLayer</code> 和他的 <code>AVPlayer</code> 将会以<code>AVPlayerItem</code>实例的第一帧呈现，类似如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AVPlayerItem.png" alt="AVPlayerItem"></p>
<p><code>AVPlayerLayer</code>有两个额外的属性:</p>
<ul>
<li><code>videoGravity</code>设置视频显示的尺寸调整行为。</li>
<li><code>isReadyForDisplay</code>检查视频是否已经可以准备播放。</li>
</ul>
<p>从另一方面来说，<code>AVPlayer</code>拥有很多额外的属性和方法。其中有一个需要<code>rate</code>属性需要注意，它表示播放速率以0~1的速率为例。0表示暂停，1表示以正常速率播放(1x)。</p>
<p>然而设置<code>rate</code>同样表示以此速率开始播放。换句话来说调用<code>pause()</code>和将<code>rate</code>设置为0所做的事一样，同理调用<code>play()</code>和设置<code>rate</code>为1也是一致的。</p>
<p>那关于快进、慢放或者是倒放操作呢？ <code>AVPlayer</code> 也能让你满意。将<code>rate</code>设置为任何大于1的数等同于要求播放器将播放速率设置为其值乘以正常速度，举个例子，将<code>rate</code>设置为2表示两倍速。</p>
<p>正如你假设的那样，将<code>rate</code>设置为负值表示将播放速率乘以正常速度倒放。</p>
<p>在以任意非正常速度播放之前会有适当的变量来验证该<code>AVPlayerItem</code>是否能够以该速度播放:</p>
<ul>
<li><code>canPlayFastForward</code>：对于任何大于1的数。</li>
<li><code>canPlaySlowForward</code>：对于任何大于0小于且不包含1的数。</li>
<li><code>canPlayReverse</code>：对于-1。</li>
<li><code>canPlaySlowReverse</code>：大于-1小于0但不包含0。</li>
<li><code>canPlayFastReverse</code>：对于任意小于-1的数。</li>
</ul>
<p>大多数视频通常可以以各种快进速度播放，但它们倒放的典型情况较少。和其他范例一样，Layer Player同样也有播放控件:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/4-180x320.png" alt="AVPlayerLayer properties"></p>
<h2 id="范例5：CAGradientLayer"><a href="#范例5：CAGradientLayer" class="headerlink" title="范例5：CAGradientLayer"></a>范例5：CAGradientLayer</h2><p><code>CAGradientLay</code>让混合两种或更多颜色变得简单，使其更加合适作为背景。为了配置它，你需要设置一个<code>CGColor</code>的数组和用以指定CAGradientLayer起始位置和结束位置的<code>startPoint</code>、<code>endPoint</code>。</p>
<p>请注意 <code>startPoint</code> 和<code>endPoint</code>并不是一个确切的点。相反它们声明于单位坐标空间上，并且它们会在图层被绘制的时候去映射图层边界。也就是说x 的值为1的时候表示该点位于图层的右边缘，y 的值为1的时候表示该点位于图层的底部边缘。</p>
<p><code>CAGradientLayer</code>有一个<code>type</code>字段，虽然<code>kCAGradientLayerAxial</code>是唯一的选项，它能线性的过渡数组中的颜色。</p>
<p>这意味着如果你在<code>startPoint</code>和<code>endPoint</code>绘制一条线(A)，渐变将沿着垂直于A的假想线（B）发生，沿B的所有点都是相同的颜色：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/AxialGradientLayerType.gif" alt="AxialGradientLayerType"></p>
<p>另外，你也可以使用0~1之间的数来控制<code>locations</code>，这些值可以指定<code>colors</code>数组中使用的下一个颜色的相对相对起始位置。</p>
<p>如果忘了指定<code>locations</code>属性，则其默认是均分图层用以使用相同的间隔显示颜色。如果<code>locations</code>被设置了，则其数量必须要与<code>colors</code>数量一致，否则会发生一些预想不到的问题。</p>
<p>如下是创建渐变图层的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cgColor</span><span class="params">(red: CGFloat, green: CGFloat, blue: CGFloat)</span></span> -&gt; <span class="type">CGColor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UIColor</span>(red: red/<span class="number">255.0</span>, green: green/<span class="number">255.0</span>, blue: blue/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>).cgColor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame = someView.bounds</span><br><span class="line">gradientLayer.colors = [cgColor(red: <span class="number">209.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">102.0</span>, blue: <span class="number">34.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">255.0</span>, green: <span class="number">218.0</span>, blue: <span class="number">33.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">221.0</span>, blue: <span class="number">0.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">17.0</span>, green: <span class="number">51.0</span>, blue: <span class="number">204.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">34.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">102.0</span>),</span><br><span class="line">                        cgColor(red: <span class="number">51.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">68.0</span>)]</span><br><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">1</span>)</span><br><span class="line">someView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码中，你创建了一个渐变图层并将<code>someView</code>的bounds 设置给它，然后设置其<code>colors</code>数组，设置起始位置和结束位置，接着将其加到视图的图层层次结构上。以下是可能出现的结果:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAGradientLayer-250x250.png" alt="CAGradientLayer"></p>
<p>多么五彩缤纷啊！你能够编写一只蝴蝶，从应用程序中飘出来搔痒你的鼻子。 ：]</p>
<p>Layer Player提供了多个用于更改起始位置、结束位置、颜色和位置。</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/5-180x320.png" alt="AVPlayerLayer controls"></p>
<h2 id="范例6：CAReplicatorLayer"><a href="#范例6：CAReplicatorLayer" class="headerlink" title="范例6：CAReplicatorLayer"></a>范例6：CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>会在指定时间内以指定次数复制某个图层，这可以让你你创建一些酷炫的效果。</p>
<p>每个图层副本都可以改变其颜色和位置，并且可以延迟创建它们用以为replicator layer创建一些动画效果。为了赋予replicator layer 3D 效果还可以给设置他们的深度(Depth)。以下是一个例子:</p>
<p>首先创建一个<code>CAReplicatorLayer</code>并将<code>someView</code>的大小位置赋值给它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> replicatorLayer = <span class="type">CAReplicatorLayer</span>()</span><br><span class="line">replicatorLayer.frame = someView.bounds</span><br></pre></td></tr></table></figure>
<p>接下来设置复制器图层(replicator layer)所拷贝的副本的数量(instanceCount)并延时绘制。同样的要将复制器图层(replicator layer)设置为2D 模式(<code>preservesDepth = false</code>)然后将实例颜色设置为白色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">replicatorLayer.instanceCount = <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceDelay = <span class="type">CFTimeInterval</span>(<span class="number">1</span> / <span class="number">30.0</span>)</span><br><span class="line">replicatorLayer.preservesDepth = <span class="literal">false</span></span><br><span class="line">replicatorLayer.instanceColor = <span class="type">UIColor</span>.white.cgColor</span><br></pre></td></tr></table></figure>
<p>下一步将对每个连续的副本实例设置其各自的红色/绿色/蓝色的颜色偏移量的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">replicatorLayer.instanceRedOffset = <span class="number">0.0</span></span><br><span class="line">replicatorLayer.instanceGreenOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceBlueOffset = -<span class="number">0.5</span></span><br><span class="line">replicatorLayer.instanceAlphaOffset = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>上述属性每个默认都是零，并且这样赋值的方式有效的在所有实例中保留了其颜色的值。然而在这个例子中，最初的实例颜色被设置为白色，这意味着红色/绿色/蓝色均已为1。因此设置绿色和蓝色的值为负值，这允许红色更加突出。类似的将alpha 偏移设置到连续拷贝副本的 alpha 属性。</p>
<p>在这之后创建一个形变(transform)来以圆形旋转每个连续的拷贝副本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> angle = <span class="type">Float</span>(<span class="type">Double</span>.pi * <span class="number">2.0</span>) / <span class="number">30</span></span><br><span class="line">replicatorLayer.instanceTransform = <span class="type">CATransform3DMakeRotation</span>(<span class="type">CGFloat</span>(angle), <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">someView.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure>
<p>然后为拷贝器图层(replicator layer)创建一个可使用的图层实例并将其设置上大小和边界(frame)，因此首个被创建的实例将会被绘制到横坐标的中心(center x)并且位于<code>someView</code>边界的顶部(top of <code>someView</code>‘s bounds)。同样的设置图层实例的颜色并将创建的图层实例添加到复制器图层(replicator layer)上:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instanceLayer = <span class="type">CALayer</span>()</span><br><span class="line"><span class="keyword">let</span> layerWidth: <span class="type">CGFloat</span> = <span class="number">10.0</span></span><br><span class="line"><span class="keyword">let</span> midX = someView.bounds.midX - layerWidth / <span class="number">2.0</span></span><br><span class="line">instanceLayer.frame = <span class="type">CGRect</span>(x: midX, y: <span class="number">0.0</span>, width: layerWidth, height: layerWidth * <span class="number">3.0</span>)</span><br><span class="line">instanceLayer.backgroundColor = <span class="type">UIColor</span>.white.cgColor</span><br><span class="line">replicatorLayer.addSublayer(instanceLayer)</span><br></pre></td></tr></table></figure>
<p>现在创建以不透明度从1到0的渐隐动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fadeAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"opacity"</span>)</span><br><span class="line">fadeAnimation.fromValue = <span class="number">1.0</span></span><br><span class="line">fadeAnimation.toValue = <span class="number">0.0</span></span><br><span class="line">fadeAnimation.duration = <span class="number">1</span></span><br><span class="line">fadeAnimation.repeatCount = <span class="type">Float</span>.greatestFiniteMagnitude</span><br></pre></td></tr></table></figure>
<p>并在最后设置图层实例的不透明度为0，这样能让图层实例在被绘制和设置其颜色透明度钱前保持透明。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">instanceLayer.opacity = <span class="number">0.0</span></span><br><span class="line">instanceLayer.add(fadeAnimation, forKey: <span class="string">"FadeAnimation"</span>)</span><br></pre></td></tr></table></figure>
<p>如下是上述代码的结果：</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CAReplicatorLayer.gif" alt="CAReplicatorLayer"></p>
<p>Layer Player包含了很多控件可以让你来操纵<code>CAReplicatorLayer</code>的大部分属性。</p>
<h2 id="范例7：CATiledLayer"><a href="#范例7：CATiledLayer" class="headerlink" title="范例7：CATiledLayer"></a>范例7：CATiledLayer</h2><p><code>CATiledLayer</code>对一小块图层中内容异步绘制。当你同时只能看一个很大图片或者其他内容中的一小部分(tile)时，这是非常有用的。因为你不必非要等到其内容全部加载到内存中才可以看到。</p>
<p>如下有几种方式来响应绘图。其一是重写<code>UIView</code>并使用<code>CATiledLayer</code>反复绘制小块内容(tile)直到填充满view的background，类似如下:</p>
<p>一个控制器展示一个<code>TiledBackgroundView</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">  @IBOutlet weak var tiledBackgroundView: TiledBackgroundView! </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被重写的<code>TiledBackgroundView</code>视图的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class TiledBackgroundView: UIView &#123;</span><br><span class="line">  </span><br><span class="line">  let sideLength: CGFloat = 50.0</span><br><span class="line">  </span><br><span class="line">  // 1</span><br><span class="line">  override class var layerClass: AnyClass &#123;</span><br><span class="line">    return CATiledLayer.self</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    super.init(coder: aDecoder)</span><br><span class="line">    srand48(Int(Date().timeIntervalSince1970))</span><br><span class="line">    let layer = self.layer as! CATiledLayer</span><br><span class="line">    let scale = UIScreen.main.scale</span><br><span class="line">    layer.contentsScale = scale</span><br><span class="line">    layer.tileSize = CGSize(width: sideLength * scale, height: sideLength * scale)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  override func draw(_ rect: CGRect) &#123;</span><br><span class="line">    let context = UIGraphicsGetCurrentContext()</span><br><span class="line">    let red = CGFloat(drand48())</span><br><span class="line">    let green = CGFloat(drand48())</span><br><span class="line">    let blue = CGFloat(drand48())</span><br><span class="line">    context?.setFillColor(red: red, green: green, blue: blue, alpha: 1.0)</span><br><span class="line">    context?.fill(rect)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下是上述代码的作用:</p>
<ul>
<li><code>layerClass</code>被重写了，所以这视图的图层是被作为<code>CATiledLayer</code>类实例创建的。</li>
<li><code>rand48()</code>方法会在<code>draw(_:)</code>中创建出多个随机颜色。接着缩放layer(本例中是<code>CATiledLayer</code>)的内容到屏幕的缩放大小和小块内容(tile)尺寸。</li>
<li>重写<code>draw(_:)</code>方法来创建多个带随机颜色的小块内容图层(tiled layers)填充视图。</li>
</ul>
<p>最终，上述代码绘制出6*6格带有随机色的正方形小块内容(tiled)，类似如下:</p>
<p><img src="/2019/01/01/iOS-CALayer-教程-入门/CATiledLayer-250x250.png" alt="CATiledLayer"></p>
]]></content>
      <tags>
        <tag>iOS翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 面试题(一)</title>
    <url>/2018/07/19/iOS-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%80/</url>
    <content><![CDATA[<p>1、如何令自己所写的对象具有拷贝功能?</p>
<p>在 iOS 让对象具有拷贝功能即是让对象具备发送 <code>copy</code> 消息或者是 <code>mutableCopy</code> 消息。但是在 iOS 中并不是所有对象都能发送这两个消息，而是只有在遵循了<code>NSCopying</code> 或者是<code>NSMutableCopying</code>的协议的类才能发送这两个消息。详细请看这里——<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a></p>
<a id="more"></a>
<p>2、说说你理解的<code>weak</code>属性</p>
<p>详细请看这里——</p>
<p>3、Swift mutating关键字的使用?</p>
<p>4、UIView和CALaver是什么关系?</p>
<p>详细请看这里——</p>
]]></content>
      <tags>
        <tag>iOS面试题</tag>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa教程 - 权威介绍：第2/2部分</title>
    <url>/2018/06/04/ReactiveCocoa%E6%95%99%E7%A8%8B-%E6%9D%83%E5%A8%81%E4%BB%8B%E7%BB%8D%EF%BC%9A%E7%AC%AC2-2%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>对于一个英语渣来说，翻译一篇文章这个过程真的好艰难，第一部分断断续续的翻译耗时有近一个月(期间把 Effective Objective-C 看完了)，耗费的时间很长，并且翻译质量也不是很好，不过在这个过程中，我对这篇文章的理解又加深了很多。翻译外文博客真的是一个能提升自身水平的极好的一个方式，话不多说，接下来就请看我为大家带来的第二篇翻译吧。</p>
<p>原文:<a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="noopener">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<p>作者:Colin Eberhardt</p>
</blockquote>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>是一个允许你使用<a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">函数响应式编程</a>技术来构建iOS 应用程序的框架。在ReactiveCocoa系列教程的的<a href="https://www.raywenderlich.com/?p=62699" target="_blank" rel="noopener">第一部分</a>带领你了解到了如何使用信号发送事件流来的方式来代替标准的 action 和事件响应逻辑。并且你也应该熟悉了如何转换、分解和组合信号。</p>
<p>在此系列的第二部分中，你将会了解到ReactiveCocoa的更多高级特性，包括：</p>
<ul>
<li>另外两个事件类型:Error 和 Completed</li>
<li>Throttling</li>
<li>Threading</li>
<li>Continuations</li>
<li>….和更多的特性！</li>
</ul>
<p>是时候开始了！</p>
<a id="more"></a>
<h2 id="Twitter时刻"><a href="#Twitter时刻" class="headerlink" title="Twitter时刻"></a>Twitter时刻</h2><p>在此部分中你要开发的应用程序名为Twitter时刻(以 Google 概念为蓝本)，Twitter搜索将会在你输入的时候实时更新你的搜索结果。</p>
<p>在这个程序的<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterInstant-Starter2.zip" target="_blank" rel="noopener">初始项目</a>中包含了一些基础的用户接口和一些你在项目开始时需要的普通代码。和<a href="https://www.raywenderlich.com/?p=62699" target="_blank" rel="noopener">第一部分</a>一样，你需要使用<a href="http://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a>来获得并整合ReactiveCocoa到你的框架中。初始化项目已经包含了必须的 Podfile文件，所以你只需要打开终端并输入如下代码即可：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>如果执行正常，则你会看到如下输入信息：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Using ReactiveCocoa (<span class="number">2.1</span>.<span class="number">8</span>)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure>
<p>这时候应该会产生一个 Xcode workspace 文件，名为 <em>TwitterInstant.xcworkspace</em> 。打开这个 workspace 并确认是否包含了如下两个项目：</p>
<ul>
<li><em>TwitterInstant</em>：保存你应用逻辑的地方。</li>
<li><em>Pods</em>：这是你项目中第三方依赖存在的地方，此时只包含一个<em>ReactiveCocoa</em>。</li>
</ul>
<p>构建并运行程序，你将看到以下内容：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/TwitterInstantStarter.png" alt="TwitterInstantStarter"></p>
<p>先花点时间熟悉一下项目代码。这是非常简单的基于split view controller的应用程序。左侧的面板是<em>RWSearchFormViewController</em>，这个控制器通过 storyboard添加了少量的UI 控件，并将搜索输入框连接为一个 outlet。右侧面板则是<em>RWSearchResultsViewController</em>，它是一个<em>UITableViewController</em>的子类。</p>
<p>如果你打开<em>RWSearchFormViewController.m</em>文件，你会看到在 viewDidLoad 方法中，将结果控制器关联到<em>resultsViewController</em>这个私有属性。程序中的大部分逻辑将会存在于<em>RWSearchFormViewController</em>中，并且<em>resultsViewController</em>属性将向<em>RWSearchResultsViewController</em>提供搜索结果。</p>
<h2 id="验证搜索内容"><a href="#验证搜索内容" class="headerlink" title="验证搜索内容"></a>验证搜索内容</h2><p>首先你将要验证的是确保搜索内容的长度应该要大于两个字符的长度。如果你完成了此系列中的<a href="https://www.raywenderlich.com/?p=62699" target="_blank" rel="noopener">第一部分</a>,那么这将是一个愉快的复习。</p>
<p>在<em>RWSearchFormViewController.m</em> 的 <em>viewDidLoad</em> 方法之后添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)isValidSearchText:(NSString *)text &#123;</span><br><span class="line">  return text.length &gt; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简单的操作确保了搜索字符必须长度大于两个字符。对于这个简单的逻辑，你可能会感到疑问：为什么将这个方法在文件中独立出来？</p>
<p>目前的逻辑非常简单，如果万一以后的逻辑变得非常的复杂呢？在上述例子中，你只需要在一个地方改变就行。此外，上述代码能够让你的代码变得更加直观和指示出为什么你要检查字符串的长度。我们都应该遵循良好的编程习惯，不是吗？</p>
<p>在相同文件的顶部导入ReactiveCocoa：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;ReactiveCocoa.h&gt;</span><br></pre></td></tr></table></figure>
<p>并在此文件中的 <em>viewdidLoad</em> 方法中加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>不清楚上述代码有什么作用？请看如下解析：</p>
<ul>
<li>获取搜索框的文字信号</li>
<li>将其转换为用以指示是否有效的颜色</li>
<li>接着在<em>subscribeNext:</em>的 block 中应用到搜索框的背景颜色的属性上</li>
</ul>
<p>构建并运行程序，接着观察如果目前的搜索字符串长度过于短的情况下输入框如何使用黄色的背景颜色指示其无效。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/ValidatedTextField.png" alt="ValidatedTextField"></p>
<p>这个简单的响应式管道如下图所示：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/TextValidationPipeline.png" alt="TextValidationPipeline"></p>
<p>每次搜索框内容改变时<em>rac_textSignal</em>信号都会发出包含当前搜索框内容的next 事件。在<em>subscribeNext:</em>操作要将值赋值给搜索框的background属性时，map 操作会将文本值转换为颜色。</p>
<p>当然，你应该还记得从<a href="https://www.raywenderlich.com/?p=62699" target="_blank" rel="noopener">第一部分</a>学到的这些知识对吗？如果你不记得了，你可能需要重新阅读一下上篇文章。</p>
<p>在我们添加 Twitter 的逻辑之前，我们要先提到一些更有意思的主题。</p>
<h2 id="管道格式化"><a href="#管道格式化" class="headerlink" title="管道格式化"></a>管道格式化</h2><p>当你在深入研究<em>ReactiveCocoa</em>代码格式的时候，被普遍接受的公约是每个操作符都另起一行，并且在竖直方向对其所有操作。</p>
<p>在下面这张图片中，你会看到从上个部分中更加复杂的例子的对齐方式：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/PipelineFormatting.png" alt="PipelineFormatting"></p>
<p>这种方式能让你更清楚，更直观的看到管道的操作。此外还能最小化每个block 中的代码量，任何需要多行展示的代码都应该使用私有方法来替代。</p>
<p>不幸的是，Xcode 并不喜欢这种风格的编程格式，所以你会发现你会和自动缩进逻辑在做斗争。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>考虑到你在<em>TwitterInstant</em> 应用中添加的代码，你可能正对管道是其被创造时如何保留的感到疑惑？当然，因为它没有分配给属性或者变量以至于并不会造成引用计数的增加，所以它注定会被销毁吗？</p>
<p>ReactiveCocoa 的设计目标之一就是允许这样一种编程风格——管道可以匿名形成。目前你所书写的代码都是响应式风格的，这会让代码看起来非常直观。</p>
<p>为了支持这种模式，ReactiveCocoa引用和保留他自己的全局信号集合。如果包含一个或多个订阅者，信号就会被激活。如果所有的订阅者都被移除了，信号就能够被解除分配。更多有关ReactiveCocoa如何管理过程的信息请看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/MemoryManagement.md" target="_blank" rel="noopener">内存管理</a>这篇文章。</p>
<p>这就只剩最后一个问题了：你如何在信号中取消订阅？在 <em>completed</em> 或者 <em>error</em> 事件之后，订阅会自动被移除(你会在不久之后学到有关这个过程的更多信息)。也可以通过RACDisposable手动删除。</p>
<p>所有订阅<em>RACSignal</em>的方法都会返回一个<em>RACDisposable</em>的实例，这个实例可以允许你通过<em>dispose</em>方法手动移除订阅。如下是一个使用<em>RACDisposable</em>的简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *backgroundColorSignal =</span><br><span class="line">  [self.searchText.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return [self isValidSearchText:text] ?</span><br><span class="line">        [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">RACDisposable *subscription =</span><br><span class="line">  [backgroundColorSignal</span><br><span class="line">    subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">      self.searchText.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">// at some point in the future ...</span><br><span class="line">[subscription dispose];</span><br></pre></td></tr></table></figure>
<p>你以后会发现自己不会经常这样做，但是这种可能性还是需要了解的。</p>
<blockquote>
<p>注意：作为这个的推论，如果你创建了一个管道但是并没有订阅它，那么这个管道就永远不会被执行，这也包括任何副作用例如<em>doNext:</em>的 block。</p>
</blockquote>
<h2 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h2><p>虽然当ReactiveCocoa在后台做了很多聪明的事，这使得你并不用过于担心信号的内存管理问题，但是你还是需要关注一个和内存有关的重要的问题。</p>
<p>如果你注意到你刚才添加的响应式代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><em>subscribeNext:</em>的 block 中为了获得输入框的引用使用了 <em>self</em>。block 会捕获并保留封闭范围的值，所以如果一个强引用存在于 self 和 信号之间，这将会造成循环引用。这是否有关系取决于self 对象的生命周期。如果存活时间是App 持续时间，则对于本例来说这毫无问题。但是对于更复杂的程序来说，这种情况很少发生。</p>
<p>为了避免这种潜在的循环引用，苹果的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16" target="_blank" rel="noopener">block 使用文档</a>推荐捕获一个self 对象的弱引用。对于当前的代码你可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak RWSearchFormViewController *bself = self; // Capture the weak reference</span><br><span class="line"></span><br><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    bself.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>上述代码中的 bself被标记为__weak以获得 self 对象的弱引用。我们注意到<em>subscribeNext:</em>的 block现在使用了 bself变量，但是这看上去不是十分优雅。</p>
<p>ReactiveCocoa框架包含了一个可以代替上述代码的小技巧。在文件的顶部导入如下文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;RACEXTScope.h&quot;</span><br></pre></td></tr></table></figure>
<p>然后使用如下代码替换原有代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@weakify(self)</span><br><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p> <em>@weakify</em>和@<em>strongify</em>表达式实际上是宏是被定义在<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener">Extended Objective-C</a>库中，它们也包含在ReactiveCocoa中。@<em>weakify</em>宏允许你创建一个弱引用的阴影变量(如果你需要，你可以传入多个变量以获得多个弱引用)。<em>@strongify</em>宏允许你为之前传入到@<em>weakify</em>中的变量创建一个强引用。</p>
<blockquote>
<p>注意：如果你对 <em>@weakify</em>和<em>@strongify</em>到底做了什么很感兴趣，请在 Xcode 中选择 <em>Product -&gt; Perform Action -&gt; Preprocess “RWSearchForViewController”</em>。这会对 viewcontroller 进行预处理，会对宏展开，并允许你查看最终输出。</p>
</blockquote>
<p>最后一条警告提示：当你在 block 中使用实例变量的时候要小心。这种操作也会导致block 捕获self 的强引用。当你发生了这种问题的时候，你可以开启编译器警告来提示自己。在项目中的<em>build settings</em>中搜索<em>retain</em>并找到指示选项，过程如下：</p>
<p><img src="/Users/sq/Desktop/Hexo/source/_posts/ReactiveCocoa教程-权威介绍：第2-2部分/AvoidRetainSelf.png" alt="AvoidRetainSelf"></p>
<p>好了，现在你完成了理论，恭喜你！现在你了解的更多并已经准备好进入到一个有趣的步骤：在你的应用中添加一些真实的功能!</p>
<blockquote>
<p>注意：请注意，亲爱的读者们，你们中的有的人会注意到，在教程的第一部分中你可以通过使用<em>RAC</em>宏的方式来代替<em>subscribeNext:</em>的 block在管道中使用。如果你发现了这一点，那么你就赶紧给自己点个赞吧并开始改变吧。</p>
</blockquote>
<h2 id="请求访问-Twitter"><a href="#请求访问-Twitter" class="headerlink" title="请求访问 Twitter"></a>请求访问 Twitter</h2><p>为了允许 Twitter 实例程序搜索 twi，你将使用到<em>Social Framework</em>这个框架。为了获得 Twitter 访问权限你将会使用到<em>Accounts Framework</em>这个框架。有关<em>Social Framework</em>更多更详细的信息，请在<a href="https://www.raywenderlich.com/?page_id=19968" target="_blank" rel="noopener">iOS6教程</a>中专门讲述此框架的文章中了解。</p>
<p>再添加此代码之前，你需要在运行此 App 的模拟器或者ipad 上导入 Twitter 凭证。打开设置，并选中 Twitter 菜单选项，然后将你的凭证添加到右手边的屏幕中：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/TwitterCredentials.png" alt="TwitterCredentials"></p>
<p>初始化项目已经添加过这些框架了，所以你只需要添加框架的头文件就行了。在<em>RWSearchFormViewController.m</em>文件的顶部输入如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Accounts/Accounts.h&gt;</span><br><span class="line">#import &lt;Social/Social.h&gt;</span><br></pre></td></tr></table></figure>
<p>再导入操作代码的下面添加如下枚举和常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTwitterInstantError) &#123;</span><br><span class="line">    RWTwitterInstantErrorAccessDenied,</span><br><span class="line">    RWTwitterInstantErrorNoTwitterAccounts,</span><br><span class="line">    RWTwitterInstantErrorInvalidResponse</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static NSString * const RWTwitterInstantDomain = @&quot;TwitterInstant&quot;;</span><br></pre></td></tr></table></figure>
<p>你将会很快使用到这些标识符错误。</p>
<p>在同个文件的属性声明的下方，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) ACAccountStore *accountStore;</span><br><span class="line">@property (strong, nonatomic) ACAccountType *twitterAccountType;</span><br></pre></td></tr></table></figure>
<p><em>ACAccountsStore</em>类提供你的设备能够连接的多种社交媒体账号的访问。<em>ACAccountType</em>代表一个特殊的账户类型。</p>
<p>在同一个文件的 viewDidLoad 方法的尾部添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.accountStore = [[ACAccountStore alloc] init];</span><br><span class="line">self.twitterAccountType = [self.accountStore </span><br><span class="line">  accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];</span><br></pre></td></tr></table></figure>
<p>上述代码创建了accounts store和Twitter 凭证。</p>
<p>当应用请求访问社交媒体账号，用户会看到弹出窗口。这是一个异步的操作，于是为了使用响应式风格，这就非常适合封装进信号。</p>
<p>还是在当前文件中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)requestAccessToTwitterSignal &#123;</span><br><span class="line">  </span><br><span class="line">  // 1 - define an error</span><br><span class="line">  NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                             code:RWTwitterInstantErrorAccessDenied</span><br><span class="line">                                         userInfo:nil];</span><br><span class="line">  </span><br><span class="line">  // 2 - create the signal</span><br><span class="line">  @weakify(self)</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    // 3 - request access to twitter</span><br><span class="line">    @strongify(self)</span><br><span class="line">    [self.accountStore</span><br><span class="line">       requestAccessToAccountsWithType:self.twitterAccountType</span><br><span class="line">         options:nil</span><br><span class="line">      completion:^(BOOL granted, NSError *error) &#123;</span><br><span class="line">          // 4 - handle the response</span><br><span class="line">          if (!granted) &#123;</span><br><span class="line">            [subscriber sendError:accessError];</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            [subscriber sendNext:nil];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有如下作用：</p>
<ul>
<li>如果用户拒绝授权，会定义一个 error 并发送出去。</li>
<li>正如本系列第一部分中所述，类方法<em>createSignal</em>会返回一个<em>RACSignal</em>的实例。</li>
<li>通过<em>account store</em>访问Twitter 是必须的。对于这一点，用户将会看到 app 请求访问他们 Twitter 账号的提示。</li>
<li>在用户同意授权或者拒绝授权之后，信号会发出事件。如果用户获得了访问授权，next 事件会随着 completed 事件一起被发出。如果用户拒绝授权，则会发出一个 error 事件。</li>
</ul>
<p>如果你还记得教程的第一部分，你应该知道信号能够发出三种类型的事件：</p>
<ul>
<li>Next</li>
<li>Completed</li>
<li>Error</li>
</ul>
<p>观察信号的存活时间，它可能不发送事件，可能发送一个或者多个next 事件和一个 completed 事件或者会发送一个 error 事件。</p>
<p>最后为了确保要使用信号，在 viewDidLoad 方法的最后添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self requestAccessToTwitterSignal]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;Access granted&quot;);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>如果你构建并运行，你将会看到下图中的提示:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/RequestAccessToTwitter.png" alt="RequestAccessToTwitter"></p>
<p>如果你点击 ok，<em>subscribeNext:</em>的 block 中要打印的信息将会出现在控制台中。而如果你点击<em>Don’t Allow</em>按钮，则 error 的 block将会执行并输出各自信息。</p>
<p>Accounts Framework这个框架会记住你所做的决定。因此，为了测试两种方式，你需要通过<em>iOS Simulator -&gt; Reset Contents and Settings</em> 的菜单选项来重置模拟器。这过程会有点痛苦，因为这需要你重新输入你的 Twitter 凭证。</p>
<h2 id="链接信号"><a href="#链接信号" class="headerlink" title="链接信号"></a>链接信号</h2><p>一旦用户获得了 Twitter账户的访问授权，则 App 为了搜索 Twitter需要一直监控textfield的改变。应用程序需要等待请求访问 Twitter发送 completed 事件，并接着订阅 textfield 的信号。不同信号连接顺序是常见的问题，但是正在ReactiveCocoa 中处理的非常优雅。</p>
<p>使用如下代码代替 viewDidLoad 方法末尾的管道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><em>then</em>方法等待completed 事件被发送，接着订阅这个 block参数返回的信号。这有效地控制了从一个信号传递到另一个信号。</p>
<blockquote>
<p>注意：在上述代码前你已经为管道准备好了weak 的 self，所以这里就不需要在管道前加上<em>@weakify(self)</em>。</p>
</blockquote>
<p>then 方法传递error事件，因此最终<em>subscribeNext:error:</em>的 block仍会收到由初始请求访问步骤发送的 error。</p>
<p>如果你构建并运行程序，接着获取到了访问权限，你应该会看到你在 textfield 中输入的内容被显示在控制台。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-01-04 08:16:11.444 TwitterInstant[39118:a0b] m</span><br><span class="line">2014-01-04 08:16:12.276 TwitterInstant[39118:a0b] ma</span><br><span class="line">2014-01-04 08:16:12.413 TwitterInstant[39118:a0b] mag</span><br><span class="line">2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi</span><br><span class="line">2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic</span><br><span class="line">2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!</span><br></pre></td></tr></table></figure>
<p>接着向管道中添加一个<em>filter</em>操作以移除无效的字符串。在这个例子中，无效的字符串是少于三个字符串度的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>再次构建并运行以观察过滤操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi</span><br><span class="line">2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic</span><br><span class="line">2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!</span><br></pre></td></tr></table></figure>
<p>以图形的方式来说明目前应用程序的管道，它看上去类似下图:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/PipelineWithThen.png" alt="PipelineWithThen"></p>
<p>应用程序管道从<em>requestAccessToTwitterSignal</em>开始，接着选择<em>rac_textSignal</em>。与此同时，next 事件通过过滤并最终进入到订阅操作的 block中。你也可以看到任意 error事件被第一步骤发出并在subscribeNext:error:的 block 中处理。</p>
<p>现在你拥有了发送搜索内容的信号，是时候使用它来搜索 Twitter了！你是否正玩的开心？你应该如此，因为现在你真正到了获取 Twitter 搜索内容的时候了。</p>
<h2 id="搜索-Twitter"><a href="#搜索-Twitter" class="headerlink" title="搜索 Twitter"></a>搜索 Twitter</h2><p><em>Social Framework</em> 是访问Twitter 搜索接口的一个选项。然而，可能正如你预料的那样，<em>Social Framework</em>并不是响应式风格的。下一步是将调用所需要的接口方法包装到信号中。你现在应该掌握这个过程。</p>
<p>在<em>RWSearchFormViewController.m</em>中添加如下的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (SLRequest *)requestforTwitterSearchWithText:(NSString *)text &#123;</span><br><span class="line">  NSURL *url = [NSURL URLWithString:@&quot;https://api.twitter.com/1.1/search/tweets.json&quot;];</span><br><span class="line">  NSDictionary *params = @&#123;@&quot;q&quot; : text&#125;;</span><br><span class="line">  </span><br><span class="line">  SLRequest *request =  [SLRequest requestForServiceType:SLServiceTypeTwitter</span><br><span class="line">                                           requestMethod:SLRequestMethodGET</span><br><span class="line">                                                     URL:url</span><br><span class="line">                                              parameters:params];</span><br><span class="line">  return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这创建通过 <a href="https://dev.twitter.com/docs/api/1.1" target="_blank" rel="noopener">v1.1 REST API</a>搜索 Twitter 的请求。上述代码使用q 作为搜索参数去搜索包含给定字符穿的 Twitter。你可以在<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="noopener">Twitter API docs</a>中看到更多关于搜索接口的信息和其他你能传入的参数。</p>
<p>接下来要做的就是要创建一个基于该网络请求的信号。在同一文件中加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)signalForSearchWithText:(NSString *)text &#123;</span><br><span class="line"></span><br><span class="line">  // 1 - define the errors</span><br><span class="line">  NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                                 code:RWTwitterInstantErrorNoTwitterAccounts</span><br><span class="line">                                             userInfo:nil];</span><br><span class="line">  </span><br><span class="line">  NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                                      code:RWTwitterInstantErrorInvalidResponse</span><br><span class="line">                                                  userInfo:nil];</span><br><span class="line">  </span><br><span class="line">  // 2 - create the signal block</span><br><span class="line">  @weakify(self)</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    </span><br><span class="line">    // 3 - create the request</span><br><span class="line">    SLRequest *request = [self requestforTwitterSearchWithText:text];</span><br><span class="line">    </span><br><span class="line">    // 4 - supply a twitter account</span><br><span class="line">    NSArray *twitterAccounts = [self.accountStore</span><br><span class="line">      accountsWithAccountType:self.twitterAccountType];</span><br><span class="line">    if (twitterAccounts.count == 0) &#123;</span><br><span class="line">      [subscriber sendError:noAccountsError];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      [request setAccount:[twitterAccounts lastObject]];</span><br><span class="line">      </span><br><span class="line">      // 5 - perform the request</span><br><span class="line">      [request performRequestWithHandler: ^(NSData *responseData,</span><br><span class="line">                                          NSHTTPURLResponse *urlResponse, NSError *error) &#123;</span><br><span class="line">        if (urlResponse.statusCode == 200) &#123;</span><br><span class="line">          </span><br><span class="line">          // 6 - on success, parse the response</span><br><span class="line">          NSDictionary *timelineData =</span><br><span class="line">             [NSJSONSerialization JSONObjectWithData:responseData</span><br><span class="line">                                             options:NSJSONReadingAllowFragments</span><br><span class="line">                                               error:nil];</span><br><span class="line">          [subscriber sendNext:timelineData];</span><br><span class="line">          [subscriber sendCompleted];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          // 7 - send an error on failure</span><br><span class="line">          [subscriber sendError:invalidResponseError];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按顺序介绍各个步骤的作用:</p>
<ol>
<li>你需要定义几个不同的 error，一个表示用户并没有在其设备上添加任何的 Twitter 账号，另一个用以表示当其执行搜索时出现问题。</li>
<li>像之前一样创建信号。</li>
<li>使用上一步添加的方法创建一个搜索给定字符串的请求。</li>
<li>搜索account store 以找到第一个可用的 Twitter 账号。如果没有可用的账号则发送一个error 事件。</li>
<li>执行搜索。</li>
<li>在事件成功(HTTP 响应码为200)的回调中,返回的JOSN数据是经过解析的并且作为 next 事件发送，接着就是一个 completed 事件。</li>
<li>在事件不成功的响应中，发送一个error 事件。</li>
</ol>
<p>现在我们就来使用这个新信号吧！</p>
<p>在这个教程的第一部分，你已经学到了如何使用<em>flattenMap</em>来对每个 next 事件映射到一个新的、将要订阅的信号上。是时候使用这个新信号了。在 viewDidLoad 方法的末尾为管道添加<em>flattenMap</em>操作符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>构建并运行，然后再搜索框中输入一些内容。一旦输入的字符超过是三个字符串长度，你应该能在Twitter 搜索的结果显示在控制台上。</p>
<p>以下仅显示您将看到的多种数据类型之一的片段：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-01-05 07:42:27.697 TwitterInstant[40308:5403] &#123;</span><br><span class="line">    &quot;search_metadata&quot; =     &#123;</span><br><span class="line">        &quot;completed_in&quot; = &quot;0.019&quot;;</span><br><span class="line">        count = 15;</span><br><span class="line">        &quot;max_id&quot; = 419735546840117248;</span><br><span class="line">        &quot;max_id_str&quot; = 419735546840117248;</span><br><span class="line">        &quot;next_results&quot; = &quot;?max_id=419734921599787007&amp;q=asd&amp;include_entities=1&quot;;</span><br><span class="line">        query = asd;</span><br><span class="line">        &quot;refresh_url&quot; = &quot;?since_id=419735546840117248&amp;q=asd&amp;include_entities=1&quot;;</span><br><span class="line">        &quot;since_id&quot; = 0;</span><br><span class="line">        &quot;since_id_str&quot; = 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    statuses =     (</span><br><span class="line">                &#123;</span><br><span class="line">            contributors = &quot;&lt;null&gt;&quot;;</span><br><span class="line">            coordinates = &quot;&lt;null&gt;&quot;;</span><br><span class="line">            &quot;created_at&quot; = &quot;Sun Jan 05 07:42:07 +0000 2014&quot;;</span><br><span class="line">            entities =             &#123;</span><br><span class="line">                hashtags = ...</span><br></pre></td></tr></table></figure>
<p><em>signalForSearchText:</em>方法同样会发送<em>subscribeNext:error:</em>接受的 error事件。你可能接受了我的话，但是还是想测试一下！</p>
<p>在模拟器的设置中选择你的 Twitter 账号，然后点击删除按钮来删除账号。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/RemoveTwitterAccount.png" alt="RemoveTwitterAccount"></p>
<p>如果你重新运行程序，这还是拥有 Twitter 账户的访问授权，但是这并没有可用的账号。所以<em>signalForSearchText</em>会报如下错误:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">01</span>-<span class="number">05</span> <span class="number">07</span><span class="symbol">:</span><span class="number">52</span><span class="symbol">:</span><span class="number">11.705</span> TwitterInstant[<span class="number">41374</span><span class="symbol">:</span><span class="number">1403</span>] An error <span class="symbol">occurred:</span> Error </span><br><span class="line">  Domain=TwitterInstant Code=<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (TwitterInstant error 1.)"</span></span><br></pre></td></tr></table></figure>
<p>Code = 1是代表RWTwitterInstantErrorNoTwitterAccounts错误。在正式的应用程序中，你可能会想要错误码并用它来做一些比输出更有意义的事情。</p>
<p>这说明了error事件非常重要的一点：一旦信号发出 error 事件，它会直接进入错误处理的 block 中。这是一个特殊的流程。</p>
<blockquote>
<p>注意：当 Twitter 请求返回一个 error时，会进入特殊的错误处理流程中。这是一个快速提示，请试着将请求参数更改为无效内容！</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>我觉得对你来说将JSON输出内容关联到 UI 上易如搔痒，但是在你做这个之前还需要做最后一件事情。为了知道这是什么，你还需要做一些探索！</p>
<p>在如图所示位置为<em>subscribeNext:error:</em>步骤添加一个断点:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/BreakpointLocation.png" alt="BreakpointLocation"></p>
<p>重新运行程序，如果需要请重新输入Twitter 凭证，接着向搜素框中输入一些内容。如果断点被触发，你应该会看到类似如图所示的内容：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/BreakpointResult.png" alt="BreakpointResult"></p>
<p>注意到调试器断点处的代码并没有在主线程上执行，主线程在上图中是<em>Thread1</em>。请注意主线程是你唯一能够更新 UI 的线程。因此如果你想要在 UI 上显示Twitter的列表，你将要选择主线程。</p>
<p>这说明了ReactiveCocoa框架一个非常重要的点。上面显示的操作会在信号发出时间的原始线程上执行。尝试着在管道其他步骤上添加断点，你可能会惊喜的发现他们会在一个或则多个不同的线程上执行！</p>
<p>所以你该如何去更新 UI呢？经典的方式是使用操作队列(请看本网站其他作者的教程<a href="https://www.raywenderlich.com/5293-operation-and-operationqueue-tutorial-in-swift" target="_blank" rel="noopener">如何使用 NSOperation和 NSOperationQueue</a>)，然而ReactiveCocoa有更简单的解决办法。</p>
<p>在<em>flattenMap:</em>之后添加<em>deliverOn:</em>操作来更新管道，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>现在重新运行app，并向搜索框中输入一些字符来触发这个断点。你应该能看到<em>subscribeNext:error:</em>的块现在执行在主线程上:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/BreakpointNowOnUIThread.png" alt="BreakpointNowOnUIThread"></p>
<p>什么？！只需要一个简单的操作就可以将事件流分编到不同的分组上，这真是太棒了？！</p>
<p>你能安全地继续升级你的 UI。</p>
<blockquote>
<p>注意：如果你观察了<em>RACScheduler</em>这个类，你会看到交付线程是有十分多种不同的优先级可以选择的，也可以选择在管道中添加延时。</p>
</blockquote>
<p>是时候看到这些 Twitter 了！</p>
<h2 id="更新-UI"><a href="#更新-UI" class="headerlink" title="更新 UI"></a>更新 UI</h2><p>如果你打开<em>RWSearchResultsViewController.h</em>文件，你会发现已经存在了<em>displayTweets:</em>这个方法。这个方法会产生右手侧的视图控制器，并将提供的 Twitter 数组显示上去。这个实现非常简单，就是一个标准的UITableView 的数据源。displayTweets:方法的单个参数希望收到包含<em>RWTweet</em>实例的<em>NSArray</em>。你同时也会发现RWTweet模型对象已经被作为初始工程的一部分提供。</p>
<p>到达<em>subscibeNext:error:</em>步骤的数据类型目前是<em>NSDictionary</em>，它是通过解析在<em>signalForSearchWithText:</em>中的 JSON 数据得到的。所以，该如何确定这个字典的内容呢？</p>
<p>如果你看过<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="noopener">Twitter API 文档</a>，你会看到一个简单的响应信息。NSDictionary就是这个结构的镜像，所以你应该能够发现它有一个名为statuses的键，这个键对应着的是Twitter 数组，这个数组中包含的同样也是NSDictionary的实例。</p>
<p>在RWTweet中已经拥有了类方法tweetWithStatus:，它使用给定格式的NSDictionary，并提取出其中需要用到的数据。你所要做的就是写一个循环并迭代其中的数组，以为每条 Twitter 创建一个RWTweet实例。</p>
<p>然而，你并不要做这个，因为在store中还有更好的东西。</p>
<p>这篇文章是关于ReactiveCocoa和函数式编程的。数据从一个格式转换到另一个格式在当你使用函数式编程的时候是更加优雅的。你讲使用<a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="noopener">LinqToObjectiveC</a>来执行此项任务。</p>
<p>选择TwitterInstant工作区，并在文本编辑器中打开你在教程第一部分所创建的Podfile。并升级代码以添加新的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &apos;7.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;ReactiveCocoa&apos;, &apos;2.1.8&apos;</span><br><span class="line">pod &apos;LinqToObjectiveC&apos;, &apos;2.0.0&apos;</span><br></pre></td></tr></table></figure>
<p>打开终端，并进入相同的文件夹然后输入以下命令:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure>
<p>你将会看到类似如下的输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing LinqToObjectiveC (2.0.0)</span><br><span class="line">Using ReactiveCocoa (2.1.8)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure>
<p>重新打开工作区，并确认如图所示的内容已经存在</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/AddedLinqToObjectiveC.png" alt="AddedLinqToObjectiveC"></p>
<p>打开<em>RWSearchFormViewController.m</em>并在文件的顶部导入如下文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;RWTweet.h&quot;</span><br><span class="line">#import &quot;NSArray+LinqExtensions.h&quot;</span><br></pre></td></tr></table></figure>
<p>NSArray+LinqExtensions.h是<em>LinqToObjectiveC</em>的头文件，并向 NSArray 中添加了多个方法以允许你使用流畅的 api对数据进行转换、排序、分组和筛选。</p>
<p>那么现在我们就在 viewDidLoad 方法的末尾使用这些方法为现有的管道添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(NSDictionary *jsonSearchResult) &#123;</span><br><span class="line">    NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;];</span><br><span class="line">    NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;</span><br><span class="line">      return [RWTweet tweetWithStatus:tweet];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.resultsViewController displayTweets:tweets];</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>正如你在上图所见到的，<em>subscribeNext:</em>的 block获得了 Twitter的数组。<em>linq_select</em>方法为NSDictionary实例中的每一个数组通过使用提供的 block 转换为RWTweet实例。</p>
<p>一旦转换完毕，Twitter 数据会被发送给显示结果的视图控制器。</p>
<p>构建并运行，可以看到最终数据显示到了UI上。</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/FinallyWeSeeTweets.png" alt="FinallyWeSeeTweets"></p>
<blockquote>
<p>注意：ReactiveCocoa和LinqToObjectiveC有着相似的灵感。同时ReactiveCocoa是基于的微软的<a href="http://msdn.microsoft.com/en-gb/data/gg577609.aspx" target="_blank" rel="noopener">响应式扩展</a>的库。LinqToObjectiveC则是基于其语言提供的搜索 api和LINQ，特别是<a href="http://msdn.microsoft.com/en-us/library/bb397919.aspx" target="_blank" rel="noopener">Linq to Objects</a>。</p>
</blockquote>
<h2 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h2><p>你可能会注意到每条 Twitter 的左侧都有一段空隙。这个空间是用来显示 Twitter 用户头像的。</p>
<p><em>RWTweet</em>类已经拥有profileImageUrl属性,这个属性填充一个用于获取图片的合适的 URL。为了让tableview 滑动的更平顺，你需要确保从给定 URL 获取图片的代码不是执行在主线程上。这可以使用GCD 或者NSOperationQueue来实现，但是为什么不用ReactiveCocoa实现呢？</p>
<p>打开<em>RWSearchResultsViewController.m</em>文件并在文件底部添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl &#123;</span><br><span class="line">  </span><br><span class="line">  RACScheduler *scheduler = [RACScheduler</span><br><span class="line">                         schedulerWithPriority:RACSchedulerPriorityBackground];</span><br><span class="line">  </span><br><span class="line">  return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    [subscriber sendNext:image];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;] subscribeOn:scheduler];</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在应该对这段代码非常熟悉了吧！</p>
<p>上述代码首先获取一个后台调度器，因为希望该信号执行在非主线程所在的线程上。接着，就是创建一个用于下载图片的信号，并且该信号在拥有订阅者之后会为订阅者发送一个UIImage。最后一块魔法是subscribeOn:，它确保信号执行在指定的调度器上。</p>
<p>简直就是魔法！</p>
<p>现在在同一个文件中对<em>tableView:cellForRowAtIndex:</em>方法return 之前的代码使用如下代码升级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cell.twitterAvatarView.image = nil;</span><br><span class="line"></span><br><span class="line">[[[self signalForLoadingImage:tweet.profileImageUrl]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(UIImage *image) &#123;</span><br><span class="line">   cell.twitterAvatarView.image = image;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>上述代码第一步是重置 cell 的图片，因为当cell 被重用时可能包含旧数据。接着创建一个必须的信号来获取图片数据。就像之前遇到的一样，在<em>deliverOn:</em>管道步骤中，将 next 事件分编到主线程上，以便其可以安全地执执行。</p>
<p>完美并且简单。</p>
<p>构建并运行，然后可以看到用户头像目前被正确地显示了：</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/AvatarsAtAlast.png" alt="AvatarsAtAlast"></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>你会发现每次你输入一些新字符的时候，Twitter 会马上执行搜索。如果你快速输入(或者简单地一直按住删除键)，这可能会造成应用程序在一秒之内执行多次搜索服务。由于如下几个原因，这并不理想：首先，你在使用Twitter 搜索 API 的同时会抛弃大部分的搜索结果。其次，你不断的更新搜索结果会使用户分心。</p>
<p>一个更好的方法是当用户短时间内不改变搜索字符串的时候再执行搜索，比如这个时间可以是500毫秒。</p>
<p>正如你想到的，ReactiveCocoa可以使这项任务及其简单。</p>
<p>打开<em>RWSearchFormViewController.m</em>并在 viewDidLoad 方法末尾的管道中在 filter 步骤之后添加throttle步骤，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  throttle:0.5]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(NSDictionary *jsonSearchResult) &#123;</span><br><span class="line">    NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;];</span><br><span class="line">    NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;</span><br><span class="line">      return [RWTweet tweetWithStatus:tweet];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.resultsViewController displayTweets:tweets];</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>throttle操作只会在给定时间之内没有收到下一个 next 事件的时候发送 next 事件，这真是非常简单。</p>
<p>构建并运行程序，以确保搜索结果只会在停止输入500毫秒之后显示结果。感到更简单了不是吗？你的用户也会有同样的想法！</p>
<p>随着这一步的结束，也代表着你的Twitter Instant程序也完成了。给你自己鼓个掌，并跳个开心的舞蹈。</p>
<p>如果你在其中的某一步迷失了，你可以下载<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterInstant-Final.zip" target="_blank" rel="noopener">最终项目</a>(请别忘记在项目目录中运行pod install)，或者你可以从 GitHub 上获取本教程每一步建议并运行的项目。</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>在你开始享受一杯胜利的咖啡之前，这值得欣赏一下最后的管道:</p>
<p><img src="/2018/06/04/ReactiveCocoa教程-权威介绍：第2-2部分/CompletePipeline.png" alt="CompletePipeline"></p>
<p>这是一个十分复杂的数据流，全部使用异常简洁的响应式风格的代码。这是一种非常好的视觉效果。你能够想象如果使用非响应式风格的代码会让程序变得多么复杂吗?在这个 App 中多难看到数据流？听起来就非常笨重，但是现在你并需要走上这条老路！</p>
<p>现在你知道ReactiveCocoa到底有多么棒了吧！</p>
<p>最后一点，ReactiveCocoa使得使用视图模型 viewModel 或者 MVVM设计模式分割 程序的视图模型和逻辑模型成为可能。如果你们中有对后续ReactiveCocoa的 MVVM 设计模式文章感兴趣，请马上让我知道。我希望听到你的想法和经历！</p>
]]></content>
      <tags>
        <tag>iOS翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的 weak</title>
    <url>/2018/12/03/iOS-%E4%B8%AD%E7%9A%84-weak/</url>
    <content><![CDATA[<p>前段时间因为项目忙(lan)，好久没有写博客了，现在趁着项目结束，赶紧写两篇博客来巩固一下知识。今天我们来了解一下 <code>weak</code>。</p>
<p>首先，<code>weak</code>是一个修饰符，也是内存管理语义的一种(有关内存管理语义请看<a href="http://devjohn.cn/2018/08/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89/">这里</a>)，用于修饰对象的所有权。请注意<code>weak</code>修饰符是在自动引用计数出现前就已经存在了，在那个时候iOS 的内存管理机制还是垃圾收集机制。</p>
<p><code>weak</code>定义的是一种非拥有关系，为这个属性设置新值的时候，设置方法既不会保留新值，也不会释放旧值。</p>
<p>接下来我们用一个例子来了解一下，具体<code>weak</code>是如何实现的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    __weak NSObject *obj233 = [NSObject new];</span><br><span class="line">    __weak NSString *str233 = @&quot;test_Str&quot;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;obj233 = %@&quot;,obj233);</span><br><span class="line">    NSLog(@&quot;str233 = %@&quot;,str233);	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请读者猜测一下具体会输出什么信息？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-12-04 10:14:25.468487+0800 oc中的 weak[20959:6105765] obj233 = (null)</span><br><span class="line">2018-12-04 10:14:25.468958+0800 oc中的 weak[20959:6105765] str233 = test_Str</span><br></pre></td></tr></table></figure>
<p>首先我们分析一下，<code>obj233</code>为什么会输出(null)(这里的(null)其实输出的就是 nil)。</p>
<p>众所周知，阅读代码的顺序是从右至左，第一步调用的是<code>[NSObject new]</code>，这里创建了一个新的<code>NSObject</code>对象(为了方便理解，我们将该变量命名为o1)，第二步是申明一个被<code>weak</code>修饰的指针，这个指针指向的是刚创建的变量o1。由于<code>weak</code>的特性——不增加引用计数。所以o1并没有被任何指针或对象所拥有此时的引用计数仍然为0，因此o1变量会在创建赋值之后不久就被销毁。并且又因为<code>weak</code>的第二个特性，当指向的对象被销毁的时候，被<code>weak</code>修饰的指针会自动被置为 nil。</p>
<p>那么同理的<code>str233</code>为什么就不为<code>nil</code>呢？这是由于<code>Objective-C</code>中字符串的特性导致的。</p>
<p>到底是字符串的什么特性导致的呢？我们先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)stringTest</span><br><span class="line">&#123;</span><br><span class="line">    NSString *s1 = [[NSString alloc] initWithString:@&quot;str1&quot;];</span><br><span class="line">    NSString *s2 = @&quot;str1&quot;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;str1 = %p&quot;,@&quot;str1&quot;);</span><br><span class="line">    NSLog(@&quot;s1 = %p&quot;,s1);</span><br><span class="line">    NSLog(@&quot;s2 = %p&quot;,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到底回输出什么呢？我们构建并运行之后了解一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-12-04 16:37:38.994474+0800 oc中的 weak[311:12354] str1 = 0x102fd00f0</span><br><span class="line">2018-12-04 16:37:38.994487+0800 oc中的 weak[311:12354] s1 = 0x102fd00f0</span><br><span class="line">2018-12-04 16:37:38.994498+0800 oc中的 weak[311:12354] s2 = 0x102fd00f0</span><br></pre></td></tr></table></figure>
<p>从这一段输出我们能发现，打印出的字符串指针地址都是一样的。这说明<code>s1</code>、<code>s2</code>、<code>@&quot;str1&quot;</code>实际上都是同一个指针。然后我们接着测试，这次测试其引用计数。在<code>stringTest</code>方法中添加查看引用计数的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)stringTest</span><br><span class="line">&#123;</span><br><span class="line">    NSString *s1 = [[NSString alloc] initWithString:@&quot;str1&quot;];</span><br><span class="line">    printf(&quot;s1 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s1)));</span><br><span class="line">    NSString *s2 = @&quot;str1&quot;;</span><br><span class="line">    printf(&quot;s2 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s2)));</span><br><span class="line">    NSString *s3 = s2;</span><br><span class="line">    printf(&quot;s3 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(s3)));</span><br><span class="line">    printf(&quot;str1 retain count = %ld\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(@&quot;str1&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后结果如下:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s1 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">s2 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">s3 retain count = <span class="number">1152921504606846975</span></span><br><span class="line">str1 retain count = <span class="number">1152921504606846975</span></span><br></pre></td></tr></table></figure>
<p>从上述结果你能看到，字符串的引用计数不会随着引用增加该增加。现在我们回到最初的问题上，这时候就能够解释为什么被<code>weak</code>修饰的<code>str233</code>字符串不会为 nil——<strong>字符串的生命周期不受引用计数的影响</strong>。</p>
<p>看到这里你可能会有疑问，在引用计数变为0之后，是立刻将对象置为 nil，还是在一个特定的时间置 nil。我们接着看下去。</p>
<h2 id="weak-修饰符的背后"><a href="#weak-修饰符的背后" class="headerlink" title="weak 修饰符的背后"></a>weak 修饰符的背后</h2><h3 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h3><p>首先我们在<code>viewDidLoad</code>中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj233 = [NSObject new];</span><br><span class="line">__weak NSObject *obj1 = obj233;</span><br></pre></td></tr></table></figure>
<p>上述代码将<code>obj233</code>赋值给被<code>weak</code>修饰的obj1，接下来我们开启Xcode 的反汇编功能(Xcode-&gt;Debug-&gt;Debug Workflow-&gt;Always show Disassembly)，并在为<code>obj1</code>赋值之后打上断点，接着构建并运行程序，查看。</p>
<p><img src="/2018/12/03/iOS-中的-weak/断点查看汇编.png" alt="image-断点查看汇编"></p>
<p>我们看右侧的注释，首先<code>objc_msgSendSuper2</code>是<code>ViewDidLoad</code>方法中的<code>[super viewDidLoad];</code>。</p>
<p>接着是<code>objc_msgSend</code>这里是源代码中的<code>NSObject *obj233 = [NSObject new];</code>。</p>
<p>接下来三个方法就是我们今天要研究的代码。</p>
<p>首先是<code>objc_initWeak</code>这个方法，看到这个方法的前缀首先<code>cmd+shift+o</code>搜索该方法。但是该方式无法搜索到该方法，所以我们需要去下载<code>Objective-C</code>的源码，并搜索该方法。(请点击<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">这里下载</a>，下载完成之后解压，并打开objc.xcodeproj)。</p>
<p>找到该方法，见下图</p>
<p><img src="/2018/12/03/iOS-中的-weak/objc_initWeak-function-des.png" alt="image-20181206151850180"></p>
<p>我们着重看第一句说明：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Initialize a fresh weak pointer to some object location. </span><br><span class="line">中文释义</span><br><span class="line">初始化一个新的弱指针，这个指针指向某个对象地址。</span><br></pre></td></tr></table></figure>
<p>接着我们去Clang编译器官网查看关于该方法的<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-initweak" target="_blank" rel="noopener">部分</a>。</p>
<p><img src="/2018/12/03/iOS-中的-weak/id objc_initWeak.png" alt="image-20181207113924683"></p>
<p>这里说明了一个前提：</p>
<blockquote>
<p><code>object</code> is a valid pointer which has not been registered as a <code>__weak</code> object. <code>value</code> is null or a pointer to a valid object.</p>
</blockquote>
<p><code>object</code>要是一个有效的并且尚未被注册为<code>__weak</code>的对象。<code>value</code>是一个空或者非空的指向一个有效对象的指针。这里的意思我理解为一个对象不能被<code>__weak</code>多次修饰。</p>
<p>然后是接下来的一句:</p>
<blockquote>
<p>If <code>value</code> is a null pointer or the object to which it points has begun deallocation, <code>object</code> is zero-initialized. Otherwise, <code>object</code> is registered as a <code>__weak</code> object pointing to <code>value</code></p>
</blockquote>
<p>如果<code>value</code>是一个空指针或者是一个已经开始释放的对象，<code>object</code>则进行零初始化。否则<code>object</code>被注册为指向<code>value</code>的<code>__weak</code>对象。</p>
<p>接着我们继续分析<code>objc_initWeak</code>这个方法，这个方法传入两个参数，分别是类型为<code>id *location</code>和<code>id newObj</code>，<code>id</code>在 Objective-C 中是最常见的类型类型之一，但是<code>id *</code>是代表着什么呢？</p>
<p>在回答这个问题之前，再问一个问题：<code>id</code>是什么？</p>
<p>“<code>id</code>可以代表任意类型的Objective-C 对象。”这样说没错，但是我如果接着问呢？什么是 <code>Objective-C</code>对象?</p>
<p>这个是时候，可能就会把一部分人给难住。但是别着急，我们接着看下去，代码不会欺骗我们。</p>
<p>打开<code>objc.h</code>中找到如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们可以得知，<code>id</code>就是<code>objc_object *</code>的一个别名。那什么是<code>objc_object</code>呢，这里不做多说明，想知道的朋友请看看这篇文章——</p>
<p>好了，那现在我们知道了<code>id</code>类型，那么什么是<code>id *</code>类型呢？</p>
<p>我们再来看看这个方法，这个方法的作用是将字符串输出到指定路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error;</span><br></pre></td></tr></table></figure>
<p>在这个方法中<code>error</code>的类型是这样的<code>NSError * *</code>的，类似于我们将<code>id *</code>转换为其原本形式<code>objc_object **</code>。那这时候我们怎么传入参数呢？就以上述方法为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">    [@&quot;eat chicken tonight&quot; writeToFile:@&quot;/file.txt&quot; atomically:true encoding:NSUTF8StringEncoding error:&amp;error];</span><br></pre></td></tr></table></figure>
<p>这时候传入<code>error</code>参数时必须要加一个<code>&amp;</code>符号，这个符号是什么意思呢？并且我们经常看到的<code>*</code>又是什么意思呢？请看我这篇文章的分析——</p>
<blockquote>
<p>关于&amp;、*、指针、和二级指针</p>
<ul>
<li>取地址运算符&amp;：&amp;是一元运算符，返回操作数的内存地址。</li>
<li>间接寻址运算符 *：也是一元运算符，是&amp;运算符的补充。返回操作数指定地址的变量的值。</li>
</ul>
<p>但是在声明对象的时候<code>*</code>代表着该对象是指针(指针表示这个变量中保存的内容是另一个变量的地址)，<code>* *</code>则代表着该变量是二级指针。二级指针中保存的内容是另一个指针的地址。</p>
<p>为什么会出现这种情况呢，因为一个函数只能有一个返回值，当一个函数需要返回两个数的时候，常规的办法并无法解决。所以这时候出现了二级指针，并且在函数中无法改变形参(让其指向一个新的变量)，但是可以通过二级指针来改变其当前所指向的变量。因此这时候就出现了方法中需要传入二级指针的情况。</p>
</blockquote>
<p>所以我们可以知道<code>id *</code>实际上就是一个二级指针，所以调用该方法的时候需要传入该变量的地址。</p>
<p>所以我们回到刚才的问题，我们能够得知，<code>objc_initWeak</code>方法需要传入一个指针地址和一个指针，然后返回一个新的指针。</p>
<p>那为什么会有这样的设计呢？这是因为<strong>Runtime维护了一个 weak 表，用于储存指向某个对象的 weak 指针，和这个对象。这个 weak 表实际上是一个(hash)哈希表(又称散列表)，表以对象地址作为 key，weak 指针地址作为 value ，并且由于一个对象可能被多个 weak 指针所指向，所以weak 表中一个 key 可能会有多个 value。</strong>这个存入就是和销毁就是通过<code>storeWeak</code>方法来实现。</p>
<p>我们看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj233 = [NSObject new];</span><br><span class="line">__weak NSObject *obj1 = obj233;		// ocjc_initWeak(&amp;obj1,obj233)</span><br><span class="line">__weak NSObject *obj2 = obj233;		// ocjc_initWeak(&amp;obj2,obj233)</span><br></pre></td></tr></table></figure>
<p> 在这个例子中，</p>
<h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><p>打开<code>NSObject.mm</code>文件，并找到<code>storeWeak</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 更新一个 weak 变量。如果HaveOld为true，则该变量具有一个需要清除的现有值。这个值可能是nil。如果</span><br><span class="line">// HaveNew为true，则有个新值需要被分配到该变量中。这个值可能会是nil。如果CrashIfDeallocating是 </span><br><span class="line">// true，则如果 newobj 正在取消分配或 newobj 的类不支持弱引用, 则该过程将停止。如果</span><br><span class="line">// CrashIfDeallocating是false，则是用nil储存。</span><br><span class="line">enum CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = false, DoCrashIfDeallocating = true</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用此方法时在新值和旧值之间必须要有一个</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    // 如果传递新值 newObj 不能为 nil</span><br><span class="line">    if (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // 为新值和旧值获取锁</span><br><span class="line">    // Order by lock address to prevent lock ordering problems. </span><br><span class="line">    // Retry if the old value changes underneath us.</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent a deadlock between the weak reference machinery</span><br><span class="line">    // and the +initialize machinery by ensuring that no </span><br><span class="line">    // weakly-referenced object has an un-+initialized isa.</span><br><span class="line">    if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            // If this class is finished with +initialize then we&apos;re good.</span><br><span class="line">            // If this class is still running +initialize on this thread </span><br><span class="line">            // (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            // then we may proceed but it will appear initializing and </span><br><span class="line">            // not yet initialized to the check above.</span><br><span class="line">            // Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看接口的说明</p>
<blockquote>
<p>Update a weak variable. If HaveOld is true, the variable has an existing value that needs to be cleaned up. This value might be nil.If HaveNew is true, there is a new value that needs to be assigned into the variable. This value might be nil.If CrashIfDeallocating is true, the process is halted if newObj is deallocating or newObj’s class does not support weak references. If CrashIfDeallocating is false, nil is stored instead.</p>
</blockquote>
<p>中文释义</p>
<blockquote>
<p>更新一个 weak 变量。如果<code>HaveOld</code>为<code>true</code>，则该变量具有一个需要清除的现有值。这个值可能是<code>nil</code>。如果<code>HaveNew</code>为<code>true</code>，则有个新值需要被分配到该变量中。这个值可能会是<code>nil</code>。如果<code>CrashIfDeallocating</code>是 <code>true</code>，则如果 newobj 正在取消分配或 newobj 的类不支持弱引用, 则该过程将停止。如果<code>CrashIfDeallocating</code>是<code>false</code>，则是用<code>nil</code>储存。</p>
</blockquote>
<blockquote>
<p>参考资料</p>
<p>1.深入理解 Objective-C 中的字符串常量：<a href="https://blog.csdn.net/qijianli/article/details/7826962" target="_blank" rel="noopener">https://blog.csdn.net/qijianli/article/details/7826962</a></p>
<p>2.浅谈iOS之weak底层实现原理：<a href="https://blog.csdn.net/Future_One/article/details/81606895" target="_blank" rel="noopener">https://blog.csdn.net/Future_One/article/details/81606895</a></p>
<p>3.iOS __weak的底层实现：<a href="https://www.jianshu.com/p/48044cc54392" target="_blank" rel="noopener">https://www.jianshu.com/p/48044cc54392</a></p>
<p>4.细说weak：<a href="https://www.jianshu.com/p/10c0f49f4755" target="_blank" rel="noopener">https://www.jianshu.com/p/10c0f49f4755</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的拷贝(copy 和 mutableCopy)</title>
    <url>/2018/07/20/iOS-%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D-copy-%E5%92%8C-mutableCopy/</url>
    <content><![CDATA[<h2 id="NSCopying和NSMutableCopying协议"><a href="#NSCopying和NSMutableCopying协议" class="headerlink" title="NSCopying和NSMutableCopying协议"></a>NSCopying和NSMutableCopying协议</h2><p>在 iOS 中并不是所有的的对象都具有拷贝功能，而是只有遵守了NSCopying 或 NSMutableCopying协议的类的对象才能具有拷贝功能。遵守了NSMutableCopying类的对象可以发送 mutableCopy 消息，遵守了NSCopying的类的对象可以发送 copy 消息。</p>
<p>对于NSCopying协议我们先看看官方文档是怎么写的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSCopying declares one method, copyWithZone:, but copying is commonly invoked with </span><br><span class="line">the convenience method copy. The copy method is defined for all objects inheriting </span><br><span class="line">from NSObject and simply invokes copyWithZone: with the default zone.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>NSCopying 声明了一个copyWithZone:方法，但是通常使用便捷方法(convenience method)copy 方法进行拷贝。copy 方法是为所有继承了 NSObject 类的对象所定义的，其使用时默认调用传入一个默认 zone 的 copyWithZone: 方法。</p>
<p>遵守 NSCoping 也是有要求的。官方文档描述如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your options for implementing this protocol are as follows:</span><br><span class="line"></span><br><span class="line">1.Implement NSCopying using alloc and init... in classes that don’t inherit copyWithZone:.</span><br><span class="line"></span><br><span class="line">2.Implement NSCopying by invoking the superclass’s copyWithZone: when NSCopying behavior is inherited. If the superclass implementation might use the NSCopyObject function, make explicit assignments to pointer instance variables for retained objects.</span><br><span class="line"></span><br><span class="line">3.Implement NSCopying by retaining the original instead of creating a new copy when the class and its contents are immutable.</span><br><span class="line">    </span><br><span class="line">4.If a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first.</span><br></pre></td></tr></table></figure>
<p>遵守该协议的注意点：</p>
<ol>
<li>如果一个类不是继承自实现了 NSCopying 协议的超类，那么需要使用 alloc 和 init 来初始化对象。</li>
<li>当继承了超类的 NSCopying 协议，需要调用超类的 copyWithZone: 方法实现 NSCopying:。如果超类实现了可能使用 NSCopyObject 方法，则显式地为持有对象的指针实例变量进行赋值。</li>
<li>当类和其内容是不可变的情况下，会使用保留其原始内容的方式代替创建一个新的副本来实现 NSCopying。</li>
<li>如果当子类从其超类继承了 NSCopying 协议并且声明了额外的实例变量，那么子类在覆写 copyWithZone: 方法时必须先调用父类的实现才能确保正确处理本身的实例变量。</li>
</ol>
<p>对于 NSMutableCopying 协议我们来看看官方文档是怎么说明的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The NSMutableCopying protocol declares a method for providing mutable copies of an</span><br><span class="line">object. Only classes that define an “immutable vs. mutable” distinction should </span><br><span class="line">adopt this protocol. Classes that don’t define such a distinction should adopt </span><br><span class="line">NSCopying instead.</span><br></pre></td></tr></table></figure>
<p>NSMutableCopying 协议定义了一个提供对象可变拷贝的方法。只有定义了“可变和不可变”区别的类才可以采用此协议。否则需要采用 NSCopying协议。</p>
<p>当然NSMutableCopying也有其需要注意的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.NSMutableCopying declares one method, mutableCopyWithZone:, but mutable copying is commonly invoked with the convenience method mutableCopy. The mutableCopy method is defined for all NSObjects and simply invokes mutableCopyWithZone: with the default zone.</span><br><span class="line"></span><br><span class="line">2.If a subclass inherits NSMutableCopying from its superclass and declares additional instance variables, the subclass has to override mutableCopyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first.</span><br></pre></td></tr></table></figure>
<p>1.NSMutableString定义了一个方法：mutableCopyWithZone:但通常都调用便捷方法 mutableCopy 来实现拷贝。mutableCopy 方法是为所有的 NSObject 定义的，并且只需传入默认的 zone 调用mutableCopyWithZone: 方法。</p>
<p>2.如果一个子类继承自一个遵循了NSMutableCopying协议的超类并定义了一个额外的实例变量，那么子类必须覆写 mutableCopyWithZone: 方法并先调用超类的实现以确保正确处理了其本身的实例变量。</p>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>我们着重讨论NSCopying 的第三条，第三条注意点引出了 iOS 中一个重要的概念——深拷贝(Deep copy)和浅拷贝(Shallow copy)。</p>
<p>浅拷贝(Shallow copy):拷贝对象的指针，而不拷贝对象的内容。</p>
<p>深拷贝(Deep copy):将对象的内容拷贝至新的内存空间。</p>
<p>简单来说就是浅拷贝拷贝了对象的指针，而深拷贝开辟一块新的内存空间并拷贝了对象的内容。</p>
<p>关于指针可以看我这篇文章——<a href="/2018/07/20/iOS-中的指针、指针变量和对象/" title="iOS-中的指针、指针变量、变量和对象">iOS-中的指针、指针变量、变量和对象</a></p>
<p><a href="https://en.wikipedia.org/wiki/Object_copying" target="_blank" rel="noopener">这里</a>是维基百科对深拷贝和浅拷贝的释义。</p>
<p><strong>深拷贝：</strong></p>
<p>深拷贝过程：</p>
<p><img src="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/Deep_copy_in_progress.svg.png" alt="深拷贝过程"></p>
<p>深拷贝结束：</p>
<p><img src="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/400px-Deep_copy_done.svg.png" alt="深拷贝结束"></p>
<p><strong>浅拷贝：</strong></p>
<p>浅拷贝过程：</p>
<p><img src="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/400px-Shallow_copy_in_progress.svg.png" alt="浅拷贝过程"></p>
<p>浅拷贝结束：</p>
<p><img src="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/400px-Shallow_copy_done.svg.png" alt="浅拷贝结束"></p>
<p>根据深拷贝和浅拷贝的定义再结合NSCopying 的第三条注意点，我们可以得出结论，<strong>对于一个类和内容都不可变的对象来说 copy 方法是进行了浅拷贝。</strong></p>
<p>所以判断是浅拷贝还是深拷贝的依据就是查看新的指针变量所指向的对象的地址是否和原指针对象所指向的对象的地址一致。</p>
<p>接下来我们开始做实验</p>
<p><strong>NSString</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str1 = @&quot;11111&quot;;</span><br><span class="line">NSString *str2 = [str1 copy];</span><br><span class="line">NSString *str3 = [str1 mutableCopy];</span><br><span class="line">NSString *str4 = str1;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str1 address%p&quot;,str1);</span><br><span class="line">NSLog(@&quot;str2 address%p&quot;,str2);</span><br><span class="line">NSLog(@&quot;str3 address%p&quot;,str3);</span><br><span class="line">NSLog(@&quot;str4 address%p&quot;,str4);</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 address0x100a4c238</span><br><span class="line">str2 address0x100a4c238</span><br><span class="line">str3 address0x1c02564a0</span><br><span class="line">str4 address0x100a4c238</span><br></pre></td></tr></table></figure>
<p>从结果上来看可以说明，NSString 的 copy 是浅拷贝，而 mutableCopy 是深拷贝。</p>
<p><strong>NSMutableString</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableString *mStr1 = [NSMutableString stringWithString: @&quot;11111&quot;];</span><br><span class="line">   NSMutableString *mStr2 = [mStr1 copy];</span><br><span class="line">   NSMutableString *mStr3 = [mStr1 mutableCopy];</span><br><span class="line">   NSMutableString *mStr4 = mStr1;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;mStr1 address%p&quot;,mStr1);</span><br><span class="line">   NSLog(@&quot;mStr2 address%p&quot;,mStr2);</span><br><span class="line">   NSLog(@&quot;mStr3 address%p&quot;,mStr3);</span><br><span class="line">   NSLog(@&quot;mStr4 address%p&quot;,mStr4);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mStr1 address0x1c4649660</span><br><span class="line">mStr2 address0xa000031313131315</span><br><span class="line">mStr3 address0x1c4648160</span><br><span class="line">mStr4 address0x1c4649660</span><br></pre></td></tr></table></figure>
<p>这说明对于 NSMutableString 来说 copy 和 mutableCopy 方法都是深拷贝。</p>
<h2 id="copy-标识符"><a href="#copy-标识符" class="headerlink" title="copy 标识符"></a><strong>copy 标识符</strong></h2><p>讲到 copy 操作可能你会觉得非常的眼熟——属性标识符也有一个 copy。</p>
<p>copy 标识符：由 copy 标识符所标识的变量其设置方法不会保留新值，而是将其”拷贝(copy)”</p>
<p>我们来测试一下改变自定义对象 copy 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface CopyTest : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (copy,nonatomic) NSMutableString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">self.test1 = [[CopyTest alloc]init];</span><br><span class="line">self.test1.name = [NSMutableString stringWithString:@&quot;测试&quot;];</span><br><span class="line">[self.test1.name appendString:@&quot;1&quot;];</span><br><span class="line">NSLog(@&quot;name%@&quot;,self.test1.name);</span><br></pre></td></tr></table></figure>
<p>运行程序，程序会崩溃并报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;Attempt to mutate immutable object with appendString:&apos;</span><br></pre></td></tr></table></figure>
<p>造成崩溃的原因是:name 属性是由 copy 声明的，所以在其 setter 方法中，并不是利用‘=’赋值而是使用 copy 方法赋值。类似如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setName:(NSMutableString *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy 方法默认创建的是’其不可变‘的副本，所以此时_name 指向的是一个不可变的副本，因此给 name 调用 appendString 方法其实是使用一个不可变的字符串调用 appendString 所以会报错。</p>
<p>对于 NSArray和 NSmutableArray、NSDictionary 和 NSMutableDictionary 进行相同的实现，会发现结果如下图所示：</p>
<p><img src="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/copy_table.png" alt="总结"></p>
<blockquote>
<p>参考资料：</p>
<p>Deep vs. Shallow与Lazy copy:<a href="https://blog.csdn.net/orzorz/article/details/5350152" target="_blank" rel="noopener">https://blog.csdn.net/orzorz/article/details/5350152</a></p>
<p>Object copying:<a href="https://en.wikipedia.org/wiki/Object_copying" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Object_copying</a></p>
<p>iOS 之对象复制:<a href="https://www.jianshu.com/p/ac07c26f467d" target="_blank" rel="noopener">https://www.jianshu.com/p/ac07c26f467d</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-中的指针、指针变量、变量和对象</title>
    <url>/2018/07/20/iOS-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是 C 语言的一个重要概念。OC 系统类型的变量,自定义类型的变量都是指针。</p>
<p>在很多国内的博客中将指针和指针变量分为两个概念，他们认为<strong>指针是一个变量的地址，而指针变量是保存另一个变量指针的变量</strong>。</p>
<p>而我查了很多资料发现大部分资料上写的，<strong>指针就是一个变量，他是保存另一个变量的地址的变量</strong>。就是国内很多博客中说到的’指针变量‘其实就是指针。关于指针的定义有如下几个可以参考：</p>
<a id="more"></a>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">维基百科</a>)：在计算机科学中，指针（英语：Pointer），是编程语言中的<strong>一类数据类型及其对象或变量</strong>，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。</p>
<p><a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">百度百科</a>：指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。</p>
<p><a href="https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm" target="_blank" rel="noopener">tutorialspoint</a>：指针是一个变量，其值是另一个变量储存单元的直接地址。</p>
<p>我比较倾向的是维基百科的这种说法，指针是一个变量，其值是另一个变量的地址。</p>
<p>这是维基百科关于指针的说明图和说明文字。</p>
<p><img src="/2018/07/20/iOS-中的指针、指针变量和对象/440px-Pointers.svg.png" alt="指针"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 名为 a 的指针，指向一个存储器地址，当中的值为 b。要注意的是，在这个示意状况中使用的计算结构，对指针及非指针，都使用相同的地址空间以及表示法，但是在真实状况中，不同的计算结构可能有不同做法。</span><br></pre></td></tr></table></figure>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><p>对于计算机访问内存的方式有两种：</p>
<ul>
<li>直接访问：直接访问是直接通过定义的变量来获取变量的值。</li>
<li>间接访问：间接访问是通过访问变量的地址来获取变量的值。</li>
</ul>
<p>有一个形象的小例子可以说明直接访问和间接访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. 直接访问某个地址，就相当于你知道某个物品放在某个抽屉里，然后你去那个抽屉，然后访问你的物品。</span><br><span class="line">b. 间接访问就是，你知道某个抽屉放着一个纸条，纸条写着：某某物品存放于某某另外一个抽屉。</span><br><span class="line"></span><br><span class="line">a里面的抽屉，就是变量，</span><br><span class="line">b里面存放纸条的抽屉，就是指针，指针的值，就是那个纸条，纸条指向另外一个抽屉（变量），另外一个抽屉存放的东西，就是一个变量的值。</span><br><span class="line">// 引用自百度知道&lt;https://zhidao.baidu.com/question/239578288212956844.html&gt;</span><br></pre></td></tr></table></figure>
<p>这样可以很形象的说明直接访问和间接访问的区别。</p>
<h3 id="基本指针运算符"><a href="#基本指针运算符" class="headerlink" title="基本指针运算符"></a>基本指针运算符</h3><p>关于指针的两个基本运算符:</p>
<ul>
<li>取地址运算符&amp;：&amp;是一元运算符，返回操作数的内存地址。</li>
<li>间接寻址运算符 *：也是一元运算符，是&amp;运算符的补充。返回操作数指定地址的变量的值。</li>
</ul>
<p>我们借用<a href="https://blog.csdn.net/senwin2009/article/details/48439361" target="_blank" rel="noopener">这篇文章</a>的例子转为 oc 的例子来说明:</p>
<p>我们先看这个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)swap_int:(int)i1 another:(int)i2</span><br><span class="line">&#123;</span><br><span class="line">    int temp = i1;</span><br><span class="line">    i1 = i2;</span><br><span class="line">    i2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	int p1 = 1;</span><br><span class="line">    int p2 = 10;</span><br><span class="line">    // 传入p1,p2</span><br><span class="line">    [self swap_int:p1 another:p2];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 = %d&quot;,p1);</span><br><span class="line">    NSLog(@&quot;p2 = %d&quot;,p2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个最后输出的结果是啥呢？我们先不急着公布答案，我们先了解一下 oc 中的参数和参数传递。</p>
<p>我们知道 oc 中调用方法有实参和形参之分，我们看看百度百科对其的解释。</p>
<p><a href="https://baike.baidu.com/item/%E5%BD%A2%E5%8F%82" target="_blank" rel="noopener">形参</a>：全称为“形式参数”是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。形参的作用是实现主调函数与被调函数之间的联系，通常将函数所处理的数据，影响函数功能的因素或者函数处理的结果作为形参。没有形参的函数在形参表的位置应该写int main(void) 函数也可以有形参和返回值，其形参也称为命令行参数，由操作系统在启动程序时初始化，其返回值传递给操作系统。</p>
<p><a href="https://baike.baidu.com/item/%E5%AE%9E%E5%8F%82" target="_blank" rel="noopener">实参</a>：实参，actual parameters，全称为”实际参数”是在调用时传递给函数的参数，即传递给被调用函数的值。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p>一句话概括就是：<strong>实参是调用方法时真正传入的参数，而形参是在函数中’接收‘实参的参数。</strong></p>
<p>形参接收实参的过程是这样的：<strong>首先根据形参的类型开辟出一个合适的内存空间用来保存形参，然后将实参所保存的内容拷贝一份给形参，所以实参和形参的地址是不相同的。</strong></p>
<p>就用我们上面的例子来讲，实参是p1,p2而形参是 i1,i2。将实参p1,p2传入方法时，方法首先会开辟出两块内存空间分别用来存放形参i1,i2，接着会将实参p1,p2所保存的内容赋值给相应的形参。所以<strong>p1,i1和p2,i2是对不同的int 变量</strong>，只是<strong>它们所保存的内容恰好相等</strong>而已。所以当你在方法中改变形参p1,p2值的时候并不会去改变实参所保存的内容(它们俩本就是不同的变量)。这个道理对于形参类型是指针也是一样的，只是指针所保存的内容是另一个对象的地址。如果要将转换例子中p1,p2的值该怎么做呢？请继续看下去。</p>
<p>将swap_int改为如下实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)swap_int:(int *)i1 another:(int *)i2</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;i1 address %p&quot;,&amp;i1);</span><br><span class="line">    NSLog(@&quot;i2 address %p&quot;,&amp;i2);</span><br><span class="line">    NSLog(@&quot;i1 value address %p&quot;,&amp;(*i1));</span><br><span class="line">    NSLog(@&quot;i2 value address %p&quot;,&amp;(*i2));</span><br><span class="line"></span><br><span class="line">    // 将指针i1所指向地址的变量的值赋值给变量 temp</span><br><span class="line">    int temp = *i1;</span><br><span class="line">    // 将i2所指向地址的变量的值赋值给 i1所指向地址的变量的值。</span><br><span class="line">    *i1 = *i2;</span><br><span class="line">    // 将变量 temp 的值(temp 不是指针，所以其保存的值不是一个地址而是一个正常的值)赋值给i2指针所指向地址的变量的值。</span><br><span class="line">    *i2 = temp;</span><br><span class="line">    // 将 i1,i2均赋值为nil</span><br><span class="line">    i1 = i2 = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    int p1 = 1;</span><br><span class="line">    int p2 = 10;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 address %p&quot;,&amp;p1);</span><br><span class="line">    NSLog(@&quot;p2 address %p&quot;,&amp;p2);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 将 pi 和 p2 的地址作为实参传入(因为这个方法的参数需要传入的是指针，指针对应的对象)</span><br><span class="line">    [self swap_int:&amp;p1 another:&amp;p2];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;p1 = %d&quot;,p1);</span><br><span class="line">    NSLog(@&quot;p2 = %d&quot;,p2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 输出结果:</span><br><span class="line">p1 = 10</span><br><span class="line">p2 = 1</span><br></pre></td></tr></table></figure>
<p>根据刚才参数传递过程的解释，我们发现因为形参是一个新创建的变量，所以传入实参的值并没有办法去改变实参的值。到底要如何去做呢？我们反过来想一想，如果要改变p1,p2的值，其实就是要<strong>改变 p1,p2所在的内存地址中保存的值</strong>。那就是说只要将p1,p2的内存地址给形参，然后<strong>根据内存地址去获取保存在该内存地址中的值</strong>，并且改变它就可以了。所以我们需要使用指针操作符&amp;传入一个内存地址。但是因为传入的是内存地址，所以就不能使用int 类型来保存了。那要使用什么样的类型来保存这个地址呢?根据参数传递，我们知道形参是要开辟出一个新的内存空间来，并将这块内存空间的值设置为传入的实参的值。就是说形参的内容要是一个地址。那不就是一个指针！而且根据传入的实参p1,p2的类型是 int 所以我们确定了形参是int 的指针，就是 int * (注意这里的 * 并不是指针操作符的 *)。接下来我们需要做的就是根据形参获得实参所保存的内容。这里就要用到另一个指针操作符” * “，这个指针操作符是获取指针所保存的内存地址所对应的对象的值。听起来有点拗口，其实上对于该例子就是获取p1,p2变量所保存的内容。最后手动将i1,i2指针指向nil。</p>
<p>我们知道了参数传递事实上就是创建了一个新的内存并拷贝实参的值。如何证明它是创建了一个新的对象呢，如果是创建了一个新的对象，那它是深拷贝还是浅拷贝呢？关于深拷贝与浅拷贝的问题可以看我这篇文章——<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a>。很简单，我们只需要关注那几条打印语句就行了。运行的结果你会发现i1和p1、i2和p2的内存地址永远是不同的，这表明确实是创建了新的对象。我先解释一下”&amp;(*i1)”，代码执行都是从右到左执行的，首先我们先用 * 操作符去获取指针所指向的地址所对应的对象的值，然后根据这个值使用 &amp; 来获取这个值所属的内存地址。这样我们打印出的“i1 value address”和“i2 value address”也是永远和p1,p2的地址是相同的，所以这里我们又可以得到这次的拷贝是一次浅拷贝的结论。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>说到对象呢，就不能不提变量。我们先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str = @&quot;String!&quot;;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个 <strong>NSString 对象，它的名字是 str</strong>。</p>
<p>也可以这么说，上面的代码创建了一个<strong>变量，它的类型是 NSString，它的名字是 str</strong>。</p>
<p>在很多时候我们经常会把变量和对象的的概念给混淆(虽然说他们也没有很明显的区别)。但是区别还是有的，对于一个<strong>变量</strong>来讲，变量注重的是指<strong>编译器开辟出的一块内存</strong>，通常和变量名捆绑出现。我们可以这样去理解：<strong>一个人相当于一变量，而变量名则是其人名</strong>。当一个变量被创建的时候(编译器开辟出一块内存)就相当于人出生，一个人出生可能并没有名字，对于变量而言就是变量被创建可能没有变量名。 对于对象来讲，<strong>对象就是内存中一段有类型的区域</strong>。对象更注重的是对内存类型的描述。严格来说<strong>对象就是用来描述变量的</strong>。</p>
<p>用代码去理解就是这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">int i = 1;</span><br></pre></td></tr></table></figure>
<p>这里第一行的1其实就是一个变量，但是它并没有与之关联的变量名。但是它并不能被描述为一个对象，因为他的类型是不确定的。第二行的1也是一个变量，他的变量名是 i。在这里我们就能说它是一个 int 类型的对象其名为 i，其值是1。</p>
<p>关于变量和对象我推荐看<a href="https://blog.csdn.net/yby4769250/article/details/7377526" target="_blank" rel="noopener">这篇文章</a></p>
<p>关于这篇博客我找了很多的资料，但是没有找到比较权威的描述指针、指针变量、变量和对象的说明。所以这篇文章是我看了很多他人的博客加以总结并辅以自己的一些理解而写出来的，内容可能和事实上有偏差，所以我希望有了解的更深入的朋友告错我所在哪里，非常感谢！</p>
<blockquote>
<p>参考资料:</p>
<ul>
<li><p>Objective-C 指针:<a href="https://blog.csdn.net/senwin2009/article/details/48439361" target="_blank" rel="noopener">https://blog.csdn.net/senwin2009/article/details/48439361</a> </p>
</li>
<li><p>Objective-C 中的指针变量：<a href="https://www.jianshu.com/p/e93188a987c6" target="_blank" rel="noopener">https://www.jianshu.com/p/e93188a987c6</a> </p>
</li>
<li><p>iOS 之 OC中指针与对象的区别: <a href="https://www.jianshu.com/p/ca66606342f8" target="_blank" rel="noopener">https://www.jianshu.com/p/ca66606342f8</a> </p>
</li>
<li><p>iOS开发 – C语言基础8（指针）：<a href="https://www.jianshu.com/p/43f84673e8b1" target="_blank" rel="noopener">https://www.jianshu.com/p/43f84673e8b1</a> </p>
</li>
<li><p>tutorialspoint(OC 中的指针):</p>
<p><a href="https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/objective_c/objective_c_pointers.htm</a></p>
</li>
<li><p>维基百科——指针:</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)</a></p>
</li>
<li><p>关于指针的浅析:<a href="https://blog.csdn.net/qq_29924041/article/details/53822322" target="_blank" rel="noopener">https://blog.csdn.net/qq_29924041/article/details/53822322</a></p>
</li>
<li><p>C++ 指针运算符（&amp; 和 *）:<a href="http://www.runoob.com/cplusplus/cpp-pointer-operators.html" target="_blank" rel="noopener">http://www.runoob.com/cplusplus/cpp-pointer-operators.html</a></p>
</li>
<li><p>C++变量和对象的区别联系:<a href="https://blog.csdn.net/yby4769250/article/details/7377526" target="_blank" rel="noopener">https://blog.csdn.net/yby4769250/article/details/7377526</a></p>
</li>
<li><p>说说OC参数传递的那些坑：<a href="https://www.jianshu.com/p/d43dac503928" target="_blank" rel="noopener">https://www.jianshu.com/p/d43dac503928</a></p>
</li>
<li><p>二级指针与ARC不为人知的特性：<a href="https://www.jianshu.com/p/6a1cfef75092?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">https://www.jianshu.com/p/6a1cfef75092?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS代码签名</title>
    <url>/2021/12/02/iOS%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h2 id="什么是-iOS代码签名机制"><a href="#什么是-iOS代码签名机制" class="headerlink" title="什么是 iOS代码签名机制"></a>什么是 iOS代码签名机制</h2><p>代码签名是在 iOS 和 macOS 上保证代码来源可靠性的一个机制(当然不仅仅是 Apple 在使用)。</p>
<h2 id="代码签名过程"><a href="#代码签名过程" class="headerlink" title="代码签名过程"></a>代码签名过程</h2><blockquote>
<p>强烈推荐看 <a href="http://xelz.info/blog/2019/01/11/ios-code-signature/" target="_blank" rel="noopener">深度长文：细说iOS代码签名</a> 和 <a href="http://blog.cnbang.net/tech/3386/" target="_blank" rel="noopener">iOS App 签名的原理</a> 这两个大神写的博客，本篇博客仅仅是记录一些粗浅的知识。</p>
</blockquote>
<p>首先看整个代码签名逻辑：</p>
<a id="more"></a>
<ol>
<li>生成 CSR 文件：在本地使用 keychain 中的证书助理小工具，生成<code>*.certSigningRequest</code>(CSR)文件。在生成 CSR 文件之前会自动在本地产生一对公/私密钥对，并且自动导入到 keychain 中。而在 CSR 文件中保存的内容就是该公钥和<a href="https://en.wikipedia.org/wiki/Certificate_signing_request#Structure" target="_blank" rel="noopener">附加信息</a>。</li>
<li>上传 CSR 文件获得 cer 文件：在 Apple Developer 网站上将 CSR 上传到 Apple 的后台，上传成功后 Apple 会在后台取出 CSR 的中包含的 Mac 公钥，并使用 Apple 私钥对该公钥进行签名，签名后产生 cer 文件即证书文件，这个文件中所包含的信息就是 mac 公钥和对公钥的签名。</li>
<li>利用 cer 证书文件获得 mobilepervision 文件：在第二步中的 cer 文件保存到本地，并在 Apple Developer 网站上上传该 cer 文件，在 Apple 后台会使用 Apple 私钥对appid、entitlements、已注册的 deviceid 列表和 cer 中 Mac 私钥进行签名，并生成 mobileprovision 文件。</li>
<li>使用 codesign 命令，对 app 和 mobilepervision 和 entitlements 文件使用本地 mac 私钥进行签名，签名之后会产生_CodeSignature/CodeSignature 文件，CodeSignature实际上是一个 plist 文件，文件中保存的是对 app 中除了可执行文件以外所有文件的哈希值。对于可执行文件，则是产生 <code>LC_CODE_SIGNATURE</code> 加载命令和该加载命令相关的信息。</li>
<li>在安装到手机之后，点击 app 会有验证的步骤：<ol>
<li>使用iPhone中保存的Apple公钥信息对 mobileprovision 进行签名检验，</li>
<li>mobileprovision签名检验通过之后比对 mobileprovision 中的 Devices 是否包含此设备。</li>
<li>设备信息检验通过之后会取出 mobileprovision 中证书部分信息，对证书信息使用 iPhone 中保存的Apple 公钥进行签名验证。</li>
<li>证书签名验证通过之后会取出证书中所保存的 Mac 公钥信息，对 App 进行签名验证。</li>
<li>验证通过，成功运行 app。</li>
</ol>
</li>
</ol>
<p>注意，平时在不同 manc 之间共享的p12 实际上就保存了 mac 的私钥。</p>
<p>借用一下 bang 神的图片(<a href="http://blog.cnbang.net/tech/3386/" target="_blank" rel="noopener">原博客地址</a> )能够更加详细的说明：</p>
<p><img src="/2021/12/02/iOS代码签名/bang-codesign.png" alt="sign4"></p>
<h2 id="重签名"><a href="#重签名" class="headerlink" title="重签名"></a>重签名</h2><p>对于可执行文件修改过或者是 hook 过的 app 由于签名机制的关系无法直接安装到非越狱 iPhone 设备上，此时就需要对修改后的 app 进行重签名。</p>
<p>我们重温一下签名所需要的前置条件：</p>
<ul>
<li>开发者证书及其证书所对应的密钥。</li>
<li>entitlements文件。</li>
<li>mobileprovision文件。</li>
</ul>
<p>第一个条件没有什么要求，只要是付费开发者就行。第二个条件就必须要有前置条件，这个指定的 entitlements 文件需要包含可执行文件所需的权限。最后的 mobileprovision 也仅需包含新的 .entitlements 就行。</p>
<p>真正开始签名前，由于 app 功能的修改有两种方式，第一种直接修改可执行文件的源代码，使用这种方式修改代码的重签名只需直接使用 codesign命令就行。</p>
<p>对于使用 Tweak 之类产生 dylib 动态库的方式来 hook 代码的方式，则在签名前还需要额外的步骤。</p>
<p>由于 dylib 的加载信息是保存在 Mach-O 可执行文件中的，所以还要对 Mach-O 进行插入对动态库的引用。我们使用<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib</a>工具进行对 dylib 的插入工作，由于 <code>LC_LOAD_DYLIB</code> 加载命令在未找到指定动态库会杀掉进程，所以需要在使用 insert_dylib 工具的时候注意通过添加参数<code>--weak</code>的方式使用<code>LC_LOAD_WEAK_DYLIB</code>来加载动态库。完成动态库的插入之后执行正常的 codesign 命令步骤即可。</p>
]]></content>
  </entry>
  <entry>
    <title>iOS推送(APNs)</title>
    <url>/2019/09/02/iOS%E6%8E%A8%E9%80%81-APNs/</url>
    <content><![CDATA[<h2 id="什么是APNs"><a href="#什么是APNs" class="headerlink" title="什么是APNs"></a>什么是APNs</h2><p>iOS 在系统层面与苹果 APNs（Apple Push Notification service）服务器建立连接，应用通过观察者模式向 iOS 系统注册关注的消息，系统收到 APNs Server 消息后转发到相应的应用程序，整个过程很清晰，并且所有 APP 都共用同一个系统级的连接，减少了系统开销，虽然 APNs 能无障碍的访问，但实际使用过程中，发现延时和丢消息的情况偶有发生。</p>
<a id="more"></a>
<h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><ul>
<li><strong>本地通知：</strong>应用在本地配置通知详细信息并将其传递给系统，然后系统会根据所配置的通知内容选择适当的时机推送。</li>
<li><strong>远程通知：</strong>使用公司服务器或者第三方服务器通过 APNs 来将数据推送给用户设备。</li>
</ul>
<p><strong>本地通知：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/本地推送.jpg" alt="本地推送.jpg"></p>
<p><strong>远程通知:</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/远程推送.jpg" alt="远程推送.jpg"></p>
<p>本地通知和远程通知对用户来说看起来是一样的。两种类型的通知都具有相同的由系统提供的默认外观。在某些情况下可以自定义外观，可以使用如下选项之一来发送通知：</p>
<ul>
<li>通知横幅。</li>
<li>应用程序右上角的角标。</li>
<li>一个有声音的横幅或者有声音的角标。</li>
</ul>
<h2 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h2><p><strong>远程推送流程：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送流程.png" alt="简单推送流程.jpg"></p>
<p><strong>流程描述：</strong></p>
<ol>
<li><strong>服务器将消息先发送到苹果的 APNs。</strong></li>
<li><strong>APNs 将消息推送到用户设备。</strong></li>
<li><strong>由 iOS 系统将收到的消息传递给相应的 App。</strong></li>
</ol>
<p>首先我们着重观察这两个角色 Provider 和 APNs。</p>
<p>Provider：可以理解为我们的业务服务器，他的需要做以下几件事情：</p>
<ul>
<li>在 APNs 中接收全球唯一的、与应用对应的设备令牌(Device Token)和与其相关的数据。</li>
<li>根据通知系统的设计与业务来确定何时远程推送需要推送到每个设备。</li>
<li>构建远程通知并向 APNs 发送推送请求，每个请求都包含<strong>通知载荷</strong>和<strong>被传输的信息</strong>。APNs 接着代表您向目标设备发送相应通知。</li>
</ul>
<p>对于业务服务器向 APNs 发送的每一个远程通知请求，都必须遵守如下要求：</p>
<ol>
<li>构造一个包含通知载荷的 JSON 字典。</li>
<li>添加有效载荷、一个全球唯一的设备令牌和其他需要被交付的HTTP / 2请求信息。</li>
<li>通过持久、安全的通道向APNs发送包含加密凭证或证书的令牌。</li>
</ol>
<h3 id="有效载荷-payload"><a href="#有效载荷-payload" class="headerlink" title="有效载荷(payload)"></a>有效载荷(payload)</h3><p>Provider 给 APN 发送的每个通知都需要包含一个有效载荷。有效载荷包含要发送到应用程序的任何自定义数据，并包含一些系统默认的信息，这些默认信息是高度系统用何种方式通知用户。需要将有效载荷构造为 JSON 字典，并将其作为 HTTP/2消息的正文发送。</p>
<p>以下示例说明了 JSON 字典的结构以及可以包含在通知中的键。有效载荷中最重要的部分就是<code>aps</code>字典，其中包括了 Apple定义的键，这些键用在 APP 中控制推送消息所需要展示的样式。</p>
<p>请注意在以下所有的示例中，均有一个自定义的键<code>acme</code>，这个键只是作为演示作用出现。</p>
<p><strong>示例 1.</strong>只包含推送内容的简单推送样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Message received from Bob&quot; &#125;,</span><br><span class="line">    &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例1.png" alt="简单推送示例1"></p>
<p><strong>示例 2.</strong>以下有效载荷中包含了标题、副标题、消息内容并将 App 应用角标设置为 5。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &#123;</span><br><span class="line">            &quot;title&quot; : &quot;Game Request&quot;,</span><br><span class="line">            &quot;subtitle&quot; : &quot;This is subtitle&quot;</span><br><span class="line">            &quot;body&quot; : &quot;Bob wants to play poker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;badge&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme1&quot; : &quot;bar&quot;,</span><br><span class="line">    &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例2.png" alt="简单推送示例2"></p>
<p><strong>示例 3.</strong>以下有效载荷中包含了通知标题、应用角标和播放的声音。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &quot;You got your emails.&quot;,</span><br><span class="line">        &quot;badge&quot; : 9,</span><br><span class="line">        &quot;sound&quot; : &quot;bingbong.aiff&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme1&quot; : &quot;bar&quot;,</span><br><span class="line">    &quot;acme2&quot; : 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS推送-APNs/简单推送示例3.png" alt="image-20190902210414660"></p>
<p><strong>示例 4.</strong>添加指定的本地化键值内容来告诉 App 应该展示为什么语言。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;alert&quot; : &#123;</span><br><span class="line">            &quot;loc-key&quot; : &quot;GAME_PLAY_REQUEST_FORMAT&quot;,</span><br><span class="line">            &quot;loc-args&quot; : [ &quot;Jenna&quot;, &quot;Frank&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sound&quot; : &quot;Call.wav&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;acme&quot; : &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的Apple预定义的键值对请查阅<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html#//apple_ref/doc/uid/TP40008194-CH17-SW1" target="_blank" rel="noopener">有效载荷键参考</a>。</p>
<h3 id="设备令牌-device-token"><a href="#设备令牌-device-token" class="headerlink" title="设备令牌(device token)"></a>设备令牌(device token)</h3><p>设备令牌是由 Apple 创建的一串特定数据，这一串特定的数据可以将其分配给指定设备上的指定应用()。只有 Apple 能够对其解码并读取设备令牌内容。每个应用程序在向 APN 注册时都会收到其唯一的设备令牌，然后必须将其发送给我们对应的业务服务器。当业务服务器需要发起推送请求的时候必须包含该设备令牌，该请求以指定设备为目标。</p>
<p>APN 在以下情况下可能会分发新的设备令牌：</p>
<ul>
<li>用户在新设备上安装应用。</li>
<li>用户从备份中回复设备。</li>
<li>用户重新安装操作系统。</li>
<li>其他系统定义的事件</li>
</ul>
<h3 id="如何获取设备令牌"><a href="#如何获取设备令牌" class="headerlink" title="如何获取设备令牌"></a>如何获取设备令牌</h3><h4 id="设备和-APN-的连接"><a href="#设备和-APN-的连接" class="headerlink" title="设备和 APN 的连接"></a>设备和 APN 的连接</h4><p><img src="/2019/09/02/iOS推送-APNs/service_device_ct.png" alt="service_device_ct.jpg"></p>
<p>APN 与设备交互的原理如下：</p>
<ol>
<li>当设备启动时会与 APNs 开始建立 TLS 连接。</li>
<li>APN 向设备返回 APNs 证书。</li>
<li>操作系统成功认证该证书之后将设备证书发送给 APNs。</li>
<li>最后 APNs 验证设备证书，与设备建立信任。</li>
</ol>
<p>通过设备与 APNs 建立 TLS 连接之后，设备上的应用程序可以向 APNs 注册以接受其特定的<strong>设备令牌</strong>以进行远程通知。</p>
<p>由于设备令牌是用以标志特定设备指定应用程序的唯一标示，所以业务服务器必须存储该设备令牌。</p>
<p><strong>管理设备令牌过程如下图所示：</strong></p>
<p><img src="/2019/09/02/iOS推送-APNs/token_generation.png" alt="token_generation.jpg"></p>
<p>在设备与 APNs 建立连接之后，获取用于特定应用程序的设备令牌的流程如下：</p>
<ol>
<li>应用程序向 APNs 注册以进行远程通知。如果应用程序已经注册并且用于特定应用程序的设备令牌未更改，则系统将会快速将现有令牌返回到应用程序，此过程将跳至步骤3。</li>
<li>当需要新的设备令牌的时候，APNs 使用设备证书中包含的信息生成一个令牌。它使用令牌密钥加密令牌并将其返回到设备中。</li>
<li>收到令牌后，应用程序必须以二进制或者十六进制格式转发给你的业务服务器。若无此令牌，业务服务器无法向设备发送通知。</li>
</ol>
<p>在业务服务器接收到了设备令牌，此时业务服务器可以开始向 APNs发送通知请求，谨记每个请求必须包含着设备令牌。其流程如下所示：</p>
<p><img src="/2019/09/02/iOS推送-APNs/token_trust.png" alt="token_trust.jpg"></p>
<h4 id="Provider-与-APNs-的连接"><a href="#Provider-与-APNs-的连接" class="headerlink" title="Provider 与 APNs 的连接"></a>Provider 与 APNs 的连接</h4><p>Provider和 APNs 建立连接有两种方式：</p>
<ul>
<li>基于令牌建立连接。</li>
<li>基于证书建立连接。</li>
</ul>
<h5 id="基于令牌建立连接"><a href="#基于令牌建立连接" class="headerlink" title="基于令牌建立连接"></a>基于令牌建立连接</h5><p><img src="/2019/09/02/iOS推送-APNs/service_provider_ct.png" alt="service_provider_ct.jpg"></p>
<p>在开发者账号中进行配置，生成唯一的服务器 Token，使用该 Token 与 APNs 建立连接。</p>
<p><strong>基于 Token 的连接可以向包含这个证书的账号下的所有 app 发送推送。</strong></p>
<h5 id="基于证书建立连接"><a href="#基于证书建立连接" class="headerlink" title="基于证书建立连接"></a>基于证书建立连接</h5><p><img src="/2019/09/02/iOS推送-APNs/service_provider_ct_certificate.png" alt="service_provider_ct_certificate_2x.png"></p>
<p>基于证书的服务器连接只支持某一个特定的应用。证书需要在服务器上根据bundle 提前生成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/09/02/iOS推送-APNs/APNs-Push.jpg" alt="äºè§£iOSæ¶æ¯æ¨éä¸æå°±å¤ï¼å²ä¸æå¨iOS Pushææ¯è¯¦è§£_19.jpg"></p>
<ul>
<li>1) 首先是应用程序注册消息推送；</li>
<li>2) iOS跟APNS Server要deviceToken。应用程序接受deviceToken；</li>
<li>3) 应用程序将deviceToken发送给PUSH服务端程序；</li>
<li>4) 服务端程序向APNS服务发送消息；</li>
<li>5) APNS服务将消息发送给iPhone应用程序。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《Local and Remote Notification Programming Guide》：<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1</a></p>
<p>《什么是消息推送》：<a href="https://blog.csdn.net/qq_34531925/article/details/80250317" target="_blank" rel="noopener">https://blog.csdn.net/qq_34531925/article/details/80250317</a></p>
<p>《iOS 必知必会 - APNs篇》：<a href="https://www.jianshu.com/p/13185cba2abf" target="_blank" rel="noopener">https://www.jianshu.com/p/13185cba2abf</a></p>
<p>《了解iOS消息推送一文就够：史上最全iOS Push技术详解》：<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=1762&amp;highlight=%CD%C6%CB%CD" target="_blank" rel="noopener">http://www.52im.net/forum.php?mod=viewthread&amp;tid=1762&amp;highlight=%CD%C6%CB%CD</a></p>
<p>《苹果远程推送通知 APNs 详解》：<a href="https://segmentfault.com/a/1190000012019282" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012019282</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS脱壳与 Tweak</title>
    <url>/2021/12/02/iOS%E8%84%B1%E5%A3%B3%E4%B8%8E-Tweak/</url>
    <content><![CDATA[<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>加壳：利用特殊算法对可执行文件的编码进行改变(如压缩、加密)，以达到保护程序代码的目的。加壳后的可执行文件外层由壳程序运行，操作系统运行可程序，壳程序对可执行文件进行解密并运行可执行文件。</p>
<p>脱壳：摘掉壳程序，将未加密的可执行文件还原出来。</p>
<ul>
<li>软脱壳：在可执行文件运行时，从内存中导出解密过的可执行文件。</li>
<li>硬脱壳：对加壳过的可执行文件执行解密算法。</li>
<li>验证是否以脱壳：<ul>
<li>原理：Load Commands -&gt; LC_ENCRYPTION_INFO -&gt; Crypt ID的值，0代表未加密</li>
<li>命令：otool  -l  可执行文件路径  |  grep  crypt </li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>硬脱壳：</p>
<ul>
<li>Clutch：<ul>
<li>Clutch -i：打印已安装列表中被加密的应用程序。</li>
<li>Clutch-d APP 序号或 BundleID：对 App 进行脱壳。脱壳成功后会产生一个 ipa 文件。</li>
<li><a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a></li>
<li>ps:目前所有包含 Extension 的应用脱壳都会失败。</li>
</ul>
</li>
<li>dumpdecrypted：目前脱壳也会失败，</li>
</ul>
<p>软脱壳：</p>
<ul>
<li><p>frida：</p>
<ol>
<li><p>越狱手机在Cydia 中添加<code>https://build.frida.re</code>源后安装 frida。</p>
</li>
<li><p>在 mac 上安装 pip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="line">python3 get-pip.py</span><br><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆 <a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida 仓库</a>到本地</p>
</li>
<li><p>在 frida 文件夹中输入 <code>sudo pip install -r requirements.txt --upgrade</code>来安装依赖。</p>
</li>
<li><p>连接越狱手机用 usbmuxd 将本地端口与手机 ssh 端口映射（默认电脑端口 2222，手机端口 22，可以在<code>dump.py</code>中修改）。</p>
</li>
<li><p>cd 进入 frida 仓库下，在手机上运行希望脱壳的文件，并使用如下命令脱壳<code>python3 dump.py 目标App名或bundleID -o 输入路径/xxx.ipa</code>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h2><p>安装：</p>
<ol>
<li>克隆<code>https://github.com/AloneMonkey/MonkeyDev</code>到本地(原 class-dump 仓库年久失修，dump 时会遇到很多问题)。</li>
<li>将在MonkeyDev/bin/class-dump可执行文件放在/usr/local/bin目录下。</li>
<li>执行命令<code>class-dump</code>验证是否安装成功。</li>
</ol>
<p>导出头文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class-dump -S -s --arch arm64 已脱壳ipa -H -o 导出地址</span><br></pre></td></tr></table></figure>
<p>​    -S：方法以方法名排序。</p>
<p>​    -s：类与分类以名字排序。</p>
<p>​    –arch arm64：输出目标架构为 arm64。</p>
<p>​    -H：输入头文件信息。</p>
<p>​    -o 导出地址：输入目录</p>
<h2 id="theos"><a href="#theos" class="headerlink" title="theos"></a>theos</h2><blockquote>
<p>theos 资料:<a href="https://github.com/theos/theos/wiki、https://iphonedev.wiki/index.php/Theos" target="_blank" rel="noopener">https://github.com/theos/theos/wiki、https://iphonedev.wiki/index.php/Theos</a></p>
</blockquote>
<p>修改环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> THEOS=/opt/theos</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$THEOS</span>/bin</span><br><span class="line">// 注意：<span class="variable">$PATH</span> 表示原 PATH 值，:表示连接，指令中意为原 PATH 和 /opt/theos/bin 目录</span><br><span class="line">// 修改后使用 <span class="built_in">source</span> ~/.bash_profile 命令更新环境变量</span><br></pre></td></tr></table></figure>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/theos/theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure>
<p>使用tweak：</p>
<ol>
<li>在安装好 theos 之后在终端输入<code>nic.pl</code>启动 NIC。</li>
<li>输入 tweak 模板序号。</li>
<li>输入项目名。</li>
<li>输入 package 名。</li>
<li>输入作者名。</li>
<li>输入想要 hook 的原程序的 BundleID。</li>
<li>输入<code>tweak</code>安装完成后需要重启的应用，以进程名表示。</li>
<li>在<code>tweak</code>中编写需要 hook 的代码和类。</li>
<li>代码完成之后在同一文件夹下在终端中输入<code>make</code>，会编译当前<code>.xm/.x</code> 等文件。</li>
<li>代码完成之后在同一文件夹下在终端中输入<code>make package</code>并执行，执行成功之后会在同一目录中创建一个包含<code>.deb</code>的packages文件夹。</li>
<li>在同一文件夹下在终端中输入<code>make install</code>,接着 <code>.deb</code>文件安装到<code>Cydia</code>中。在桌面重启后 hook 功能生效。</li>
</ol>
<p>Tweak命令：</p>
<ul>
<li>清除已构建 deb 文件：<code>make clean</code>。</li>
<li>编译文件：<code>make</code></li>
<li>打包文件：<code>make package</code>，注意此命令也会包含<code>make</code>命令的功能和动作。打包正式版<code>make package debug=0</code>。</li>
<li>安装 deb：<code>make install</code>。</li>
</ul>
<p>tewak 文件结构及其功能：</p>
<ul>
<li>makefile:makefile 文件。</li>
<li>Tweak.x：编写代码的文件。</li>
<li>control：指定 deb 包的一些信息，包括名字、描述、版本号等。</li>
<li>.plist：包含了需要指定注入的目标程序的 BundleID。</li>
<li>layout 文件夹(可选)：若在 Tweak 时需要用到资源文件，可以放在 layout 文件夹目录下，thos 在安装 deb 包的时，会将资源文件按照 layout 文件中的路径放在手机中，例如：<code>layout/Library/Application\Support/TweakDemo/</code>会被放在<code>/Library/Application\Support/TweakDemo/</code>路径下，需要通过<code>contentOfFile:</code>方法读取该文件内容。</li>
</ul>
<p>tweak 使用 Logs 语法，参考 <a href="https://iphonedev.wiki/index.php/Logos" target="_blank" rel="noopener">Logos语法</a>：</p>
<ul>
<li><p>%hook className/%end：成对出现，%hook表示hook一个类的开始，%end 表示 hook 一个类的结束。</p>
</li>
<li><p>%log：在函数内部使用，功能是将函数名，参数等信息写入 syslog 中，格式<code>%log</code>或<code>%log([(&lt;type&gt;)&lt;expr&gt;, …])</code>。</p>
</li>
<li><p>%orig：打印原函数，并可以选择性的传递参数。格式<code>%orig</code>或<code>%orig(arg1, …)</code>。</p>
</li>
<li><p>%group groupName/%end和%init：</p>
<ul>
<li>%group 和%end 成对出现，表示一个hook 组的开始，在一个 group 中可以拥有多个 hook，所有未指定组的 hook 都会保存在%group _ungrouped中。</li>
<li>group需要初始化后才能被加载，初始化方法：%init(Groupname)，%init 可以在 group 中使用或者在%ctor 中使用。</li>
</ul>
</li>
<li><p>%ctor：tweak的构造器，完成初始化工作，若不显示定义，则会自动生成一个%ctor{…}，并在其中调用%init(_ungrouped)。</p>
</li>
<li><p>%dtor：tweak的解构器，与%ctor功能相反完成解构工作（程序退出时调用）。</p>
</li>
<li><p>%new：在%hook 内部使用，作用是给当前 class 添加新函数，功能与 objc_addMethod(char<em>)相同，格式：`%new<br>-(void)yourNewMethod { /</em> code */ }<code>。在使用</code>%new<code>的时候如果提示方法不存在，需要随意在一个</code>@interface xxx @end` 中声明这个方法，声明完毕之后才能调用。</p>
</li>
<li><p>%c：在%hook 或者%ctor 内使用，等同于 objc_getClass 或 NSClassFromString()。格式：<code>%c([+|-]Class)</code>，默认为-，表示普通类，+则表示元类。</p>
</li>
<li><p>logify.pl：可以将一个头文件快速转换成已经包含打印信息的 xm 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logify.pl xx.h &gt; xx.xm</span><br><span class="line">-------------------------</span><br><span class="line">%hook SSDownloadAsset</span><br><span class="line">- (NSString *)finalizedPath &#123; %log; NSString * r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">- (NSString *)downloadPath &#123; %log; NSString * r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">- (NSString *)downloadFileName &#123; %log; NSString * r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">+ (id)assetWithURL:(id)url type:(int)type &#123; %log; id r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">- (id)initWithURLRequest:(id)urlrequest type:(int)type &#123; %log; id r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">- (id)initWithURLRequest:(id)urlrequest &#123; %log; id r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">- (id)_initWithDownloadMetadata:(id)downloadMetadata type:(id)type &#123; %log; id r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ps.如果执行 make install 命令出错，则需要在 makefile 文件中设置环境变量<code>export THEOS_DEVICE_IP=手机IP</code>和<code>export THEOS_DEVICE_PORT=手机端口</code>。</p>
<h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><p>可被编译的文件类型：.m、.h、.xm、.x 等</p>
<p>步骤：</p>
<ol>
<li>创建自定义文件并放在 Tweak 文件目录下。</li>
<li>在.xm 文件中导入需要使用到的自定义文件。<code>#import xxx/xxx/xxx.h</code></li>
<li>在 <code>makefile</code>中<code>flipclockTweak_FILES</code>字段中添加需要参与编译的文件，以空格分隔。例：<code>flipclockTweak_FILES = Tweak.x classes/Signal.m</code>，也可以使用通配符表示文件夹下所有指定文件参与编译，例：<code>flipclockTweak_FILES = Tweak.x classes/*.m</code>。</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>在执行了<code>make package</code>之后会产生一个包含 Cydia 插件包的<code>package</code>文件夹和包含动态库文件、plist与多个文件夹的<code>.theos</code>文件夹。</li>
<li>在执行了<code>make install</code>后 theos 会通过 ssh 将产生的<code>.plist</code>和<code>.dylib</code>动态库通过 Cydia 使用 ssh 命令移动到设备中的<code>/Library/MobileSubstrate/DynamicLibraries/</code>目录下。</li>
<li>当App 程序执行之后，在<code>/Library/MobileSubstrate/MobileSubstrate</code>路径下的<code>.plist</code>中根据<code></code>BundleID<code>查找是否包含当前运行的 app，如果包含则会将</code>dyld<code>中的</code>DYLD_INSERT_LIBRARIES<code>变量设置为在步骤 2 中生成的动态库地址，并载入</code>dyld`共享库中。</li>
</ol>
<p>逆向可能用到的工具：<a href="https://iphonedev.wiki/index.php/Reverse_Engineering_Tools" target="_blank" rel="noopener">https://iphonedev.wiki/index.php/Reverse_Engineering_Tools</a></p>
<p>逆向遇到的问题：</p>
<ol>
<li>字符串编码变成 <code>\xe6\x9c\x80\xe6\x96\xb0</code> ，这为十六进制字符串，需要转换之后才能正常显示<ul>
<li>网站：<a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">https://www.bejson.com/convert/ox2str/</a></li>
</ul>
</li>
<li>实例变量需要在 implementation 中以 @public 定义之后才能用。</li>
<li>在调用原有方法或者新增方法时，Tweak 编译不通过，可以通过在任意 <code>@interface xxx @end</code>中添加方法声明来通过编译。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>内存管理语义</title>
    <url>/2018/08/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<p>每个属性都有其内存管理语义，要么默认设置，要么主动设置。内存管理语义定义了其属性的所有权。属性所有权仅影响 setter。</p>
<ul>
<li><p>assign： </p>
<p>assign一般用来修饰基本数据类型 int 、 float (基础类型没有引用关系)</p>
<p>意义：如果这个用assign属性修饰的property代表一个指向对象的指针，那么当这个指针指向某个对象时，这个对象的引用计数不应该被改变。也就是说，用assign属性修饰的property，不应该持有一个对象(引用计数不增加)。因为这个property不持有对象，所以它所指向的对象很可能已经在别处被释放了。这时它就有可能成为一枚悬垂指针，访问它指向的内存地址时，可能会发生意想不到的状况。 </p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>strong：</p>
<p>在ARC内存管理模式下，strong是一个代表对象类型的property的默认属性，并且它不能修饰用来代表简单数据类型的property。编译器在合成实例变量时，将使用__strong修饰符。</p>
<p>此特性表明该属性定义了一种”拥有关系“。为这种属性设置新值的时候，会先保留新值然后释放旧值，接着将新值赋值上去。(注意这里的顺序，一定是先保留新值然后释放旧值，不能相反，否则假设新值和旧值是同一个值的话会造成值被释放被设为 nil)。</p>
</li>
<li><p>weak: </p>
<ul>
<li>weak也不能修饰用来代表简单数据类型的property。</li>
<li>编译器将为weak修饰的property生成带__weak所有权修饰符的实例变量。</li>
<li>此特性定义了一种“非拥有关系”。为这个属性设置新值的时候，设置方法既不会保留新值，也不会释放旧值。此特性同 assign 类似，然而在此属性所知的对象被设置摧毁之后，属性值会被设置为 nil。</li>
</ul>
</li>
<li><p>retain： </p>
<ul>
<li>retain (基本等价于 Strong) :</li>
<li>retain不能修饰用来代表简单数据类型的property，否则编译器会报错</li>
<li>如果一个property被retain修饰，这代表着这个property应该持有它所指向的对象。<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW1" target="_blank" rel="noopener">官方文档</a>中展示了一个被retain修饰的property：</li>
</ul>
</li>
<li><p>atomic(默认)：单线程使用 ， 线程安全  ， 速度慢</p>
</li>
<li><p>nonatomic：可多线程使用 ， 线程不安全   ， 速度快</p>
</li>
<li><p>copy：</p>
<ul>
<li><p>copy也不能修饰用来代表简单数据类型的property，否则编译器会报错</p>
</li>
<li><p>如果一个property被copy修饰，那么赋值到这个property的对象，应该是原有对象的一份拷贝且不会增加引用计数。</p>
</li>
<li>对使用 copy 修饰的属性，若是调用了自定义的 setter 则一定要注意要使用 copy 方法。</li>
<li>只有实现了NSCopying协议，并且实现了其中的copyWithZone:方法的对象才能被拷贝。</li>
<li>但是并不是所有的拷贝都产生了新的对象，有些类在实现copyWithZone:方法时，有着它们自己的考虑。比如NSString： NSString 在Copy之后两个对象的内存地址相同</li>
<li><p>深拷贝和浅拷贝——具体请看<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a></p>
<ul>
<li>深拷贝 : 拷贝出来的对象与源对象地址不一致! 这意味着我修改拷贝对象的值对源对象的值没有任何影响.</li>
<li>浅拷贝 : 拷贝出来的对象与源对象地址一致! 这意味着我修改拷贝对象的值会直接影响到源对象.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料:</p>
<ul>
<li>IOS 内存管理机制  <a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">http://blog.devtang.com/2016/07/30/ios-memory-management/</a> </li>
<li>IOS 内存管理机制 <a href="http://www.jianshu.com/p/8b1ed04b3ba9" target="_blank" rel="noopener">http://www.jianshu.com/p/8b1ed04b3ba9</a> </li>
<li>iOS 从创建对象到销毁 <a href="https://juejin.im/entry/58a178060ce463005644ee4a" target="_blank" rel="noopener">https://juejin.im/entry/58a178060ce463005644ee4a</a></li>
<li>assign，retain，strong，weak，unsafe_unretained，还有copy : <a href="http://www.jianshu.com/p/4a1d1921284b" target="_blank" rel="noopener">http://www.jianshu.com/p/4a1d1921284b</a> </li>
<li>oc 属性修饰符讲解: <a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="noopener">http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html</a></li>
<li>打印引用计数 <a href="http://www.jianshu.com/p/e059a54fb5f3" target="_blank" rel="noopener">http://www.jianshu.com/p/e059a54fb5f3</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建篇</title>
    <url>/2018/06/01/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AF%87/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这是本博客开通之后正经的第一篇文章，博客搭建也是别人的经验才成功的，但是期间也遇到了挺多的坑。写这篇博客权当是记录一下这些坑吧。</p>
<p>博客搭建大纲:</p>
<ol>
<li>申请一个<code>github pages</code></li>
<li>在电脑中配置<code>Hexo</code>的环境</li>
<li>设置 Hexo 主题</li>
<li>绑定自己的域名(可以不绑定，绑定之后有逼格)</li>
<li>开始写博客</li>
</ol>
<a id="more"></a>
<h2 id="一、申请github-pages"><a href="#一、申请github-pages" class="headerlink" title="一、申请github pages"></a>一、申请github pages</h2><blockquote>
<p><a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">What is GitHub Pages?</a></p>
<p>GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</p>
</blockquote>
<p>github pages是一个静态网站托管服务。GitHub Pages 被设计来管理你的来自一个GitHub 库的个人的、组织的、或者项目的页面。了解更多不同的类型的GitHub Pages网站，你可以点击：”个人、组织和项目页”。</p>
<h3 id="创建-GitHub-账号"><a href="#创建-GitHub-账号" class="headerlink" title="创建 GitHub 账号"></a>创建 GitHub 账号</h3><ol>
<li>登录 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>网站注册账号.</li>
<li>账号注册成功之后创建仓库</li>
</ol>
<p><img src="/2018/06/01/博客搭建篇/创建仓库.png" alt="创建仓库"></p>
<p>仓库名需要设置<code>yourusername.github.io</code>样式,其中yourusername要改为你 GitHub 用户名，例如你叫<code>jjjjjohn</code>那么这里设置为<code>jjjjjohn.github.io</code></p>
<p><img src="/2018/06/01/博客搭建篇/ 创建仓库详情.png" alt=" 创建仓库详情"></p>
<h2 id="二、配置-Hexo-环境"><a href="#二、配置-Hexo-环境" class="headerlink" title="二、配置 Hexo 环境"></a>二、配置 Hexo 环境</h2><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 安装</a></p>
<p>由于安装教程很可能过期，所以推荐各位读者参考 Hexo 官网教程一步一步来安装。</p>
</blockquote>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>在 Hexo 环境安装好之后就可以进行建站，打开终端 cd 进入桌面并使用如下命令即可建好。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">hexo init folderName</span><br><span class="line">cd folderName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>其中 <code>folderName</code> 是一个你可以随意设置的名字。本文章假设<code>folderName</code>的文件夹名称是<code>Hexo</code>。</p>
<p>创建成功后会在桌面创建一个文件夹，该文件夹的名字是<code>folderName</code>。</p>
<blockquote>
<p>建好之后更多关于Hexo 的信息请查看<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<h3 id="关联-GitHub-Pages"><a href="#关联-GitHub-Pages" class="headerlink" title="关联 GitHub Pages"></a>关联 GitHub Pages</h3><p>首先进入你刚才创建的名为<code>folderName</code>的文件夹，找到其中名为<code>_config.yml</code>的文件，用文本编辑器打开，并且滚动到最下面添加如下配置信息(注意最下边有 <code>deploy</code>和<code>type</code>字段),覆盖这两个字段或者删除这两个字段后复制如下代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">type:</span> git</span><br><span class="line"><span class="symbol">repo:</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>RookieWsq/RookieWsq.github.io.git</span><br><span class="line"><span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure>
<p>注意这里<code>repo</code>字段所对应的值需要改为你刚才创建的GitHub Pages的地址。如果你刚才忘了自己的GitHub Pages地址，打开 GitHub 网站，选择刚才创建的仓库，复制该仓库浏览器的地址栏。复制的时候注意空格,在 repo:字段之后有一个空格。<img src="/2018/06/01/博客搭建篇/GitHubPage 地址.png" alt="GitHubPage 地址"></p>
<p>此时你的网站就已经建好了，接下来就是开启本地服务器，检查是否配置成功。首先使用终端进入你刚才创建的名为 <code>folderName</code> 的文件夹，然后使用<code>hexo s</code>(完整命令<code>hexo server</code>)命令开启本地服务器,如果成功会打印类似<code>Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</code>的一句话。接着用浏览器打开<code>localhost:4000</code>,就可以看到你刚才搭建的博客了。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>这时候按捺一下你的心情，接下来我们还有好多的事情需要做。</p>
<p>此时只是在本地服务器上搭建成功了，但是还未发布到 <code>GitHub Page</code>远端服务器。接下来需要做的就是发布到远端服务器。使用终端进入你刚才创建的名为 <code>folderName</code> 的文件夹接着输入如下代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p><code>hexo g</code>完整命令:<code>hexo generate</code>  生成静态页面</p>
<p><code>hexo d</code>完整命令<code>hexo deploy</code>  发布到远端</p>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 命令</a></p>
</blockquote>
<h2 id="三、配置-Hexo-主题"><a href="#三、配置-Hexo-主题" class="headerlink" title="三、配置 Hexo 主题"></a>三、配置 Hexo 主题</h2><p>配置 Hexo 主题是为了让博客页面看起来更加生动美观，但这个却不是搭建博客必要的。</p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>选择指定主题之后就可以下载主题，假设我们这里的主题是著名额 NexT。</p>
<p>下载主题</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/<span class="regexp">/ 进入你的hexo项目(即名为 folderName 的文件夹)中</span></span><br><span class="line"><span class="regexp">git clone https:/</span><span class="regexp">/github.com/iissnan</span><span class="regexp">/hexo-theme-next themes/next</span> <span class="comment"># 下载主题到themes下面的next文件夹下</span></span><br></pre></td></tr></table></figure>
<h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>在<code>folderName</code>文件夹下打开<code>_config.yml</code>并找到<code>theme</code>字段，修改该字段所对应的值</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">theme:</span> <span class="keyword">next</span>        /<span class="regexp">/ 注意主题名前有一个空格,这个名字是刚才主题下载到的文件夹</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 接着重启服务，并使用 debug 模式启动</span></span><br><span class="line"><span class="regexp">hexo s --debug</span></span><br></pre></td></tr></table></figure>
<h2 id="四、域名绑定"><a href="#四、域名绑定" class="headerlink" title="四、域名绑定"></a>四、域名绑定</h2><p>本篇文章最装逼的时刻到了——域名绑定。渴望像大神一样拥有一个自己的狂霸酷炫吊炸天的域名，并且输入这个域名就能跳转到你的网站？敬请欣赏装*时刻。</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ol>
<li>首先去<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>购买域名。</li>
<li>将域名和 GitHub Pages 绑定。</li>
</ol>
<p>假设你此时拥有一个可用的域名，修改该域名的 <code>DNS</code>,将 DNS 修改为<code>f1g1ns1.dnspod.net</code>和<code>f1g1ns2.dnspod.net</code>。</p>
<p><img src="/2018/06/01/博客搭建篇/修改 DNS.png" alt="修改 DNS"></p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>接着打开你之前创建的 <code>folderName</code>中的<code>source</code> 文件夹，并在该文件夹中使用<code>touch CNAME</code>创建一个名为<code>CNAME</code>文件。</p>
<p>然后使用文本编辑器打开，在里面添加你的域名信息。</p>
<p><img src="/2018/06/01/博客搭建篇/添加域名信息.png" alt="添加域名信息"></p>
<blockquote>
<p>填写完毕之后重新部署到 GitHub Pages 上。（部署简写命令hexo d -g)</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>下一步注册 <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpod</a>，然后添加域名，添加两条记录。<img src="/2018/06/01/博客搭建篇/DNSpod.png" alt="DNSpod"></p>
<p><img src="/2018/06/01/博客搭建篇/添加记录.png" alt="添加记录"></p>
<p>这里的 <code>CNAME</code>字段填写为你的 <code>githu Pages</code> 的地址。</p>
<p>一个<code>@</code>类型的记录值，该值填写你<code>GitHub Pages 的 IP</code> 地址。</p>
<blockquote>
<p>如何获取 GitHub Pages 的 IP 地址:在终端中输入命令</p>
<p>ping &lt;你的 GitHub Pages 地址&gt;    // 使用的时候去除尖括号</p>
</blockquote>
<p><img src="/2018/06/01/博客搭建篇/pingGitHubPages.png" alt="pingGitHubPages"></p>
<h2 id="五、开始写博客"><a href="#五、开始写博客" class="headerlink" title="五、开始写博客"></a>五、开始写博客</h2><p>打开你的博客网址，此时你会发现已经有了一篇博文了。这篇博文是保存在<code>folderName/source/_posts</code>中，以后所有的发布的博文都会被放在这里。</p>
<h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><ul>
<li>创建文章</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &apos;文件名&apos; //会在source/_posts创建一个文件名.md文件</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑文章，关于编辑文章，由于 Hexo 支持 Markdown 语法所以我选择使用可视化的工具<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>来帮助我。</li>
<li>发布文章</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">进入 folderName文件夹，并输入以下命令</span><br><span class="line">输入：hexo generate，回车，生成静态页面， </span><br><span class="line">再输入：hexo server，回车，到<span class="symbol">localhost:</span><span class="number">4000</span>预览博客效果， </span><br><span class="line">最后输入：hexo deploy，回车，同步到github上去就行了。</span><br></pre></td></tr></table></figure>
<p>补充:</p>
<ul>
<li>添加图片，使用 <code>Typora</code>非常的方便，首先需要在<code>source</code>文件夹下创建一个名为<code>images</code>的文件夹用来保存图片，接着只需要将所需要的图片拖拽到<code>Typora</code> 中即可，但是此时图片的路径是一个绝对路径，推荐改为相对路径。</li>
<li>所有的图片放入一个文件夹中会引起混乱。(至少我觉得非常混乱，我心里非常不舒服)。所以此时我推荐引入一个新的框架——<code>hexo-asset-image</code>。这个框架会在 <code>md</code>文件同级的文件夹下创建一个和<code>md</code>文件同名的文件夹，这个新创建的文件夹可以保存图片，这样就避免了混乱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装插件</span><br><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image -- save</span><br><span class="line">2.引用图片  只需要拖拽进入即可。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进入新公司一个月了，最近在研究 RAC，希望下一篇能是关于 RAC 的博客吧!</p>
</blockquote>
<p><a href="http://devjohn.cn/">我的博客</a>,努力学习 iOS 中，与各位看官一起成长！</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/834d7cc0668d" target="_blank" rel="noopener">我的博客是如何搭建的</a></li>
<li><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown语法</a></li>
<li><a href="https://blog.csdn.net/zhy421202048/article/details/77877580" target="_blank" rel="noopener">Hexo更改主题</a></li>
<li><a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">hexo博客图片问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>年度总结——追寻危机感</title>
    <url>/2019/01/27/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E8%BF%BD%E5%AF%BB%E5%8D%B1%E6%9C%BA%E6%84%9F/</url>
    <content><![CDATA[<p>白驹过隙白云苍狗，寒来暑往日月如梭………….(后面省略一万字)。文章断断续续写了好久，因为不知道从何开始讲起。我们现在就从我刚工作开始讲起吧。</p>
<a id="more"></a>
<p>说实在话，我的第一份工作也来的非常巧合。在大三结束前几个月我自认为学了点 iOS 开发的皮毛就到处投实习生简历，结果现实用事实告诉了我我当时连学到一点皮毛都算不上。甚至写几个简单的自定义视图都磕磕绊绊的。不过凑巧的是同学投中了一家公司约去面试，然后带上了我。一顿面试笔试结束之后同学不幸落选，而我却意外地进入到了人生的第一家公司里工作。刚开始的那段时间真的是让我真真切切感受到了”刘姥姥进大观园”时的感受。长连接、UIDynamic、实时通讯和大量的自定义视图。让我非常感兴趣也让我非常惊恐——公司里要求那么高不会不会无法通过实习期？此前，我还在校园里念书学习的时候并没有丝毫的这种紧张感和危机感。可能是因为真正要开始工作了，感受到了一个无形的担子压在了我的身上，就像一个落水的人只能向着远方的岸边奋力的游去。于是在那段时间里我在宿舍中唯一做的就是看代码，然后跟着敲一遍。遇到不懂得就去谷歌(当时还不知道如何查官方文档)。并且由于我刚开始学的是 Swift，但是到了公司之后发现实际上使用的仍然是 Objective-C 开发。当时的我也只能不断的告诉自己需要花费更多的时间才能够跟随的上公司的步伐，勤能补拙、人一己百。就这样我慢慢的踏出了开发的第一步。也正是因为那段时光让我和谷歌达成了“搜索战略协议“，并且也养成了一个好习惯——在能够谷歌的情况下绝对不问师傅。</p>
<p>不过既然今年是博客搭建的第一年，那么今年的总结不妨就从博客开始说起吧。</p>
<p>博客是去年的三月份就已经搭建好了，但是那段时间忙着大学毕业论文，所以虽然搭建了博客但是并没有投入使用。等到第一篇博客发布也是答辩完成——两个月后了。答辩完成前我先去找了一份工作，主要做的是房产中介 App 的开发。从这个时间开始一直到今年的一月份，刚开始的两到三个月内基本上都在维护和迭代旧版本的 App。再之后来了新的产品经理之后一直到离职位置均保持着一个月一个 App 的进度。包括重构老版本 App 和开发新 App。开发速度还有往上提提的空间，我一直想着要建一个本地私有库一直都没有完成，这算是一大遗憾。说到遗憾，其实去年对自己的表现评价一下的话也就最多只能打一个基础分六十分。因为去年有太多太多的 flag 尚未完成，又继续拖到了今年：</p>
<ul>
<li>建立本地私有库并记录自己的经历。</li>
<li>写一篇关于 RAC 的博客。</li>
<li>完成<code>iOS 中的 weak</code>。</li>
<li>完成<code>GPUImage 使用心得</code>。</li>
<li>完成<code>UIView和 CALayer</code>。</li>
<li>看完<code>精通 Objective-C</code>。</li>
</ul>
<p>确实有太多太多的设想和为自己设立的目标都未完成。连这篇博客都是初五晚上才堪堪写完。这一切都要归咎于自己对自己还不够严苛、不够自律并且执行力和行动力不足。最近偶然间看到一篇文章里面说道这么一句话——<strong>成大事者：事不拖，话不多，人不作！</strong>这句话总结的是曾国藩一生的做人做事之道。我还没到足够的高度来评价曾国藩，但是单论这句话中的事不脱却是说的极好的。从大学毕业真正踏入社会开始，我看见过很多朋友同事在计划或者工作任务未完成的时候说的都是——“我真的太懒了”、“我有拖延症”等等。这些无法是一个人工作未完成的理由。你不克服它你就不得丝毫寸进！我再写这篇博客的时候我在知乎上搜了一下<a href="https://www.zhihu.com/question/20357585" target="_blank" rel="noopener">如何克服严重的拖延症</a>这个话题的关注者人数是<strong>81768</strong>，而<a href="https://www.zhihu.com/topic/19555404/hot" target="_blank" rel="noopener">iOS 开发</a>的关注者是<strong>99329</strong>。光这两个数字就能说明拖延症并不在少数。这可不是一个好的征兆！所以我认为<strong>事不拖</strong>是一个成功者必须具备的条件之一。而话不多和人不作目前保持观望态度。</p>
<p>一言蔽之，去年的我需要更大的执行力和行动力。所以我对今年制定的第一个目标是——<strong>拥有更加强大的执行力和行动力。</strong></p>
]]></content>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>接口安全及签名规范</title>
    <url>/2019/01/17/%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E5%8F%8A%E7%AD%BE%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="0-敏感数据本地加密后传输"><a href="#0-敏感数据本地加密后传输" class="headerlink" title="0.敏感数据本地加密后传输"></a>0.敏感数据本地加密后传输</h2><ul>
<li>数据安全:所有敏感数据如：登录密码、支付密码、手机号等在传输过程之中需要加密。</li>
<li>加密方式:HMAC+MD5+key 。</li>
</ul>
<a id="more"></a>
<ul>
<li>流程<ul>
<li>用户注册：在用户注册的时候判断用户是否允许注册，若允许注册则由服务器产生加密所使用的 key并保存到数据库中，在客户端保存该 key(可以加密也可以明文)。调用注册接口进行注册时，传递加密后的密码，由服务器存入数据库。</li>
<li>用户登录：在用户登录的时候，若是客户端不存在 key，则需要向服务端获取。</li>
<li>一个用户一个 key，该 key 推荐定时更新。</li>
<li>若某客户端无可以，此时需要向服务端获取。但是服务端允许直接返回 key，而是服务端请求具有 key 的另外客户端询问是否授权。此时服务器需要维护一个用户所登录的设备集合。</li>
</ul>
</li>
</ul>
<p>类似用户密码、手机号等敏感数据在传输过程中需要加密，加密的方式选择RSA/SHA1/MD5/HMAC在敏感数据加盐后再加密用以保护。</p>
<h2 id="1-使用-token-标志用户"><a href="#1-使用-token-标志用户" class="headerlink" title="1.使用 token 标志用户"></a>1.使用 token 标志用户</h2><p>api_token、user_token、refresh_token</p>
<h2 id="2-网络请求添加签名"><a href="#2-网络请求添加签名" class="headerlink" title="2.网络请求添加签名"></a>2.网络请求添加签名</h2><ul>
<li><p>请求头</p>
<ul>
<li>sign : 密文主体</li>
<li>timestamp : 当前时间戳整形</li>
<li>nonce : 随机字符串用于签名和防重放</li>
<li>Authorization : 用户 token</li>
</ul>
<p>签名规则</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">nonce:</span>需要为不能重复的字符串，需要定义加密方法，例如<span class="symbol">:nonce=</span>时间戳+设备ip地址+设备 Mac 地址然后 MD5。服务端需要保存此值用于之后防重放(多个网络请求需要保存多个值，需要保存成集合)。请注意该集合需要被清理，具体的清理时间。这里我们使用nonce=MD5(时间戳+UUID)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.首先在请求头添加 sign 字段用于表示该网络请求所发起的时间。</span><br><span class="line"><span class="number">2</span>.将网络请求参数根据参数名的 ASCII 码从小到大进行排序，再使用 URL键值对的形式(即key1=value1&amp;key2=value2…请注意此处当参数为最后一个的时候将不需要拼接&amp;符号)拼接成字符串StringA。</span><br><span class="line"><span class="number">3</span>.在 StringA 最后拼接上 timestamp 、 token 、 nonce，接着对拼接之后的字符串进行 MD5/RSA 加密，再将加密结果得到的字符串全部转为大写并存入sign字段。</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 注意：POST/</span>GET请求需要使用相同的加密方法。 </span><br><span class="line">/<span class="regexp">/ 若是参数中存在字典或者数组，请将其转换为 JSON 字符串再进行拼接</span></span><br></pre></td></tr></table></figure>
<p>范例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulr:				https://baidu.com/login</span><br><span class="line">params:				</span><br><span class="line">&#123;</span><br><span class="line">    latitude = 121.58299,</span><br><span class="line">    longitude = 29.85297,</span><br><span class="line">    udi = 55;</span><br><span class="line">&#125;</span><br><span class="line">timestamp:			1547867794</span><br><span class="line">nonce:				b2a6675a75ed2d0b39da3e2f03805790	</span><br><span class="line">StringA:		    latitude=121.58299&amp;longitude=29.85297&amp;udi=55</span><br><span class="line"></span><br><span class="line">拼接后字符串:			</span><br><span class="line">latitude=121.58299&amp;longitude=29.85297&amp;udi=551547867794eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIgb2a6675a75ed2d0b39da3e2f03805790</span><br><span class="line"></span><br><span class="line">Authorization:		</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZnFxdjIuZmFuZ3FpYXFpYS5jb21cL2FwaVwvbG9naW4iLCJpYXQiOjE1NDc4NjYzNTMsImV4cCI6MTU0OTA3NTk1MywibmJmIjoxNTQ3ODY2MzUzLCJqdGkiOiJEdU9qbHFyUzNFR0FqR3VmIiwic3ViIjoxNDYyMywicHJ2IjoiMjNiZDVjODk0OWY2MDBhZGIzOWU3MDFjNDAwODcyZGI3YTU5NzZmNyJ9.Tdt00qtV2OjjZaqj-YRRdbKM06pFyQihCEXQYml2rIg</span><br><span class="line"></span><br><span class="line">sign:	规则:sign = MD5((StringA + timestamp + token + nonce).upperCase())	</span><br><span class="line">sign:   13541B7DBF0092DE2D9DDEF4009DBE74</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-接口防重放功能"><a href="#3-接口防重放功能" class="headerlink" title="3.接口防重放功能"></a>3.接口防重放功能</h2><ol>
<li><p>使用物理防火墙。例如：指定某请求在给定时间内允许访问几次</p>
</li>
<li><p>代码防重放(timestamp + nonce)</p>
<ol>
<li>在用户登录或者更新用户信息的时候使用某一接口(例如：ClienPing)获取 App 本地时间和服务器时间的差值，服务器需要保存此差值，用于防重放功能。</li>
<li>在签名验证步骤之前判断用户发起的网络请求中的时间戳和服务器的时间戳差值(例如有效时间是一分钟)是否在允许的范围之内。</li>
<li>在判断时间有效之后需要服务端需要在用户的 nonce 集合中判断是否已经存在了该值，如果存在则拒绝该网络请求。否则记录该 nonce 值，并允许该请求。</li>
<li>清理 nonce 集合，需要定制nonce集合清理的时机(可以选择一定大小和一定时机清理)，例如:若有效时间设置为一分钟，则判断某用户某一次请求时其 nonce 集合的最后修改时间是否早于该请求一分钟，若是，则删除集合，否则继续添加。</li>
</ol>
</li>
<li><p>服务器验证顺序</p>
<p>1 先验证sign签名是否合理，证明请求参数没有被中途篡改<br>2 再验证timestamp是否过期，证明请求是在最近60s被发出的<br>3 最后验证nonce是否已经有了，证明这个请求不是60s内的重放请求</p>
</li>
</ol>
<h2 id="4-接口验证不通过返回状态码"><a href="#4-接口验证不通过返回状态码" class="headerlink" title="4.接口验证不通过返回状态码"></a>4.接口验证不通过返回状态码</h2><ul>
<li>401</li>
<li>402</li>
<li>403</li>
</ul>
<blockquote>
<p>参考资料：</p>
<p>深入了解Token认证的来龙去脉:<a href="https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1593244938986076867&amp;wfr=spider&amp;for=pc</a></p>
<p>Web签名加密:<a href="https://www.cnblogs.com/letcafe/p/loginSecurity.html" target="_blank" rel="noopener">https://www.cnblogs.com/letcafe/p/loginSecurity.html</a></p>
<p>JWT:<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇——闲谈</title>
    <url>/2018/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E9%97%B2%E8%B0%88/</url>
    <content><![CDATA[<p>这个是我写的第一篇笔记，博客好久之前就搭建好了，但是一直懒得去找Hexo 写博客的教程，这次终于在任务空闲的时候写一下博客，就像大多数博主那样，很少有人能够坚持一直写博客。但是坚持下来的无一不是大神，这个月就要大学毕业了，在大学里荒废了好久的时间，现在想来真是可惜。我时不时在想，如果我没有荒废大学那么多的时间，如果两年前就具备了我现在就拥有的技能(虽然现在的自己并不牛逼，但是相比以前还是有一个一技之长)，那现在………..。但是时间从来都不是让人用来可惜的，而是用来珍惜的。搭建这个博客的目的是督促我自己记录我在学习路上的种种困难，挑战和收获。希望自己也有一天能被他人称为大神。</p>
<p>闲聊结束，下一篇我们开始讲我搭建这个博客的一点经验和收获。</p>
<p>下一篇——<a href="/2018/06/01/博客搭建篇/" title="博客搭建篇">博客搭建篇</a></p>
]]></content>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>类和 isa 指针</title>
    <url>/2018/08/15/%E7%B1%BB%E5%92%8C-isa-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>对于普通对象来说，isa 指针包含对象的类</p>
<p>oc 中所有的 isa 指针指向的都是类。</p>
<p>在 oc 中每一个类的对象都都有一个指向类的指针 isa。并且在 oc 中任何数据结构也在一个正确的位置上都有一个指向类的指针，使其能够被视为对象。</p>
<p>所以一个对象的类型是由 isa 指针决定的，isa 指针指向对象的类。</p>
<a id="more"></a>
<p><del>接下来我们查看类的定义，首先我们使用如下代码导入所需框架:</del>(这样查看的是旧的定义)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;objc/objc.h&gt;</span><br></pre></td></tr></table></figure>
<p><del>首先我们先查看对象的定义,找到objc_object ，并查看:</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p><del>我们看到objc_object中只定义了一个 Class 类型的变量，Class类型其实我们可以从上述代码第一条得知 Class其实就是一个objc_class类型的指针。<strong>对于对象来说isa指针就是指向对象所对应的类。</strong></del></p>
<p>新定义:</p>
<p>首先<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">下载文档</a>，然后我们打开它objc-private.h 文件。我们查看objc_object 定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 objc_object 中，isa 是一个 isa_t 类型的变量，继续在这个文件中查找 “union isa_t ”，然后我们看这个变量的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 isa_t 是一个union类型的结构体(或者称为联合体)。这个 isa_t 中定义了一个 Class 类型的cls 变量。然后我们接着查找这个 Class 类型。在同一个文件中搜索’objc_class *Class’，你会看到Class 类型的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>你会看到其实 cls 变量是一个指针，其值指向的对象是objc_class结构体。接着我们打开objc-runtime-new.h 文件，搜索“objc_class ”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体就是类的结构，所以我们说<strong>对于普通对象来说，isa 指针包含对象的类</strong>。为什么特指普通对象呢，我们继续看下去。</p>
<h2 id="类其实也是一个对象"><a href="#类其实也是一个对象" class="headerlink" title="类其实也是一个对象"></a>类其实也是一个对象</h2><p>首先我们着重看上述几个变量,并逐条分析。objc_class 继承自objc_obbject，所以我们 objc_class 中也存在一个isa 变量。而且由这个继承结构我们可以得出：<strong>类其实也是一个对象</strong>。只不过这个对象并不是由我们来创建，而是由系统来创建。既然类也是一个对象，那么其 isa 指针中必定也包含对象的类，即<strong>“类对象的类“</strong>。那么”类对象的类“是什么呢？其实它就是<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB" target="_blank" rel="noopener">元类(metaclass)</a>，但是，元类有什么作用呢？先别急，我们等会讨论。</p>
<h3 id="类对象中保存类的父类"><a href="#类对象中保存类的父类" class="headerlink" title="类对象中保存类的父类"></a>类对象中保存类的父类</h3><p>superclass 也是一个objc_class类型，就是一个类，按照其字面意思理解是指向本对象的父类，事实上真是这个意思，在这里就是元类的父类。这具体是指向的什么呢，这等我们讨论元类的时候再讨论。</p>
<p>然后下一个就是cache，这个变量是cache_t类型的，它是一个<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>(又名哈希表，是根据键(Key)而直接访问在内存存储位置的数据结构)，缓存的是曾经调用过的方法列表，并且它可以使用键值对的方式去读取，这样效率肯定比遍历快得多。如果你想了解更多请看<a href="https://juejin.im/post/5b1b45c36fb9a01e5b10f96b" target="_blank" rel="noopener">方法缓存与查找</a>。</p>
<h3 id="类对象保存属性、实例所能执行的普通方法和所遵守的协议"><a href="#类对象保存属性、实例所能执行的普通方法和所遵守的协议" class="headerlink" title="类对象保存属性、实例所能执行的普通方法和所遵守的协议"></a>类对象保存属性、实例所能执行的普通方法和所遵守的协议</h3><p>接下来就是一个bits，它是class_data_bits_t类型的变量，在讲解这个变量之前，我们先看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@&quot;stringValue&quot;</span><br><span class="line">    writeToFile:@&quot;/file.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</span><br></pre></td></tr></table></figure>
<p>当字符串实例调用实例方法writeToFile:的时候，这个方法也是存在于内存中的，那么它是在哪里被定义的呢？在没有接触过 runtime 之前，你可能会对此感到疑惑，可能觉得它就是保存在对象里的，也可能觉得它是保存在对象的类中的，或者说根本就没有想法(刚开始我就是一脸懵逼)。我们接下来就来探讨这个问题，首先看对象类型objc_object 结构体。在这结构体中，大部分的函数和变量都是和 ARC 与 isa 有关的，你找了很久也没有找到名称类似的函数和变量。接着我们看objc_class 结构体，因为变量才是保存信息所用的单元，所以我们先看变量。在 objc_class 中，我们讲过了前面几个变量，接着就是要讲class_data_bits_t类型的变量bits。我们在”objc-runtime-new.h”中搜索class_data_bits_t，我们可以看到这个类型的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    // Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们发现了两个新的类型，分别是uintptr_t和class_rw_t。我们依次查看这两个类型的定义：首先我们使用快捷键 cmd+shift+o 调出快速搜索栏填入uintptr_t。</p>
<p><img src="/2018/08/15/类和-isa-指针/快速查找uintptr_t.png" alt="image-20180817093327289"></p>
<p>打开这个文件，你会看到uintptr_t 的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _UINTPTR_T</span><br><span class="line">#define _UINTPTR_T</span><br><span class="line">typedef unsigned long		uintptr_t;</span><br><span class="line">#endif /* _UINTPTR_T */</span><br></pre></td></tr></table></figure>
<p>其实它就是一个长整型的别名，它不保存方法，我们接着看下一个变量类型class_rw_t。</p>
<p>还是在objc-runtime-new.h 中，搜索class_rw_t，你会看到他的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先查看变量，你会惊喜的发现有一个类型为method_array_t的变量methods。这个变量难道就是我们需要找的保存方法的变量？对没错，他就是保存对象方法列表的变量。查看它的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_list_t **beginCategoryMethodLists() &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    method_list_t **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    method_array_t duplicate() &#123;</span><br><span class="line">        return Super::duplicate&lt;method_array_t&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有多个新的类型，我们先查看第一个类型list_array_tt。同样的在”objc-runtime-new.h”中搜索list_array_tt，看到其定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list_array_tt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> count;</span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> size_t <span class="title">byteSize</span><span class="params">(<span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">array_t</span>) + count*<span class="keyword">sizeof</span>(lists[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> byteSize() &#123;</span><br><span class="line">            <span class="keyword">return</span> byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关template 关键字请看<a href="https://blog.csdn.net/hycoldrain/article/details/3716131" target="_blank" rel="noopener">这里</a>，所以我们可以知道，其实method_array_t就是一个二维数组，这个二维数组中保存的就是method_list_t数组，method_list_t数组中保存的是method_t。我们接着查看 method_t。我们继续在”objc-runtime-new.h”中搜索method_t ，我们可以看到 method_t 的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,</span><br><span class="line">                                    const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>wow，这不就是我们熟知的方法的结构吗！name 是 SEL 类型的表示方法名。imp 是 IMP 类型，表示指向方法的实现地址。<strong>所以，类对象保存着对象所能执行的普通方法。</strong>为什么是普通方法呢，等我们讨论元类的时候再做解释，接下来我们来看它们的定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们先看 IMP，IMP 类型我们根据新的 IMP 定义可以这样理解：<strong>IMP 作为一个指向 “一个拥有 至少一个 id 类型，一个 SEL 类型当作参数并回传不可为空的  id 的函数” 的指针的别名</strong>(如果对 typedef 不太了解的可以看<a href="https://zh.wikipedia.org/wiki/Typedef" target="_blank" rel="noopener">这里</a>)。IMP是最终消息执行所调用的代码，是方法真正实现的代码。</p>
<p>接着我们看 SEL，SEL 类型是一个指针类型，其内容指向objc_selector。但是在 runtime 源码中找不到其定义，所以我们无法了解到这里面写了什么(但是有兴趣的同学可以看<a href="https://blog.csdn.net/jeffasd/article/details/52084639" target="_blank" rel="noopener">这篇文章</a>所写的内容，这文章中大胆的猜测了objc_selector类型定义)，所以我们没办法知道其具体定义，只知道 <strong>SEL 代表着方法的’’标识符’’</strong>。就像”人民大会堂”这个名字就代表着人民大会堂这个建筑一样。</p>
<p>如果我们继续观察class_rw_t中的property_array_t类型和protocol_array_t类型，我们会发现这和list_array_tt类似，只不过property_array_t中保存的是<strong>对象所有的属性</strong>，protocol_array_t保存<strong>对象所遵守的协议</strong>。</p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>我们在讨论类的时候多次出现了”元类“这个概念，我们说类对象的 isa 指针指向元类。但是什么是元类呢？我们引用<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB" target="_blank" rel="noopener">维基的释义</a>——<strong>元类</strong>（英语：metaclass）是一种实例是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB" target="_blank" rel="noopener">类</a>的类。普通的类定义的是特定对象的行为，元类定义的则是特定的类及其对象的行为。</p>
<p>即：类对象的行为在元类中定义。</p>
<p>看到这里你可能会感到疑惑：类对象的行为是什么呢？我们看如下例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *string = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;class method&quot;];</span><br></pre></td></tr></table></figure>
<p>我们知道实例对象的方法保存在类对象中，但是上述代码并不是实例对象调用，而是类调用，那么这个方法也是保存在类中的吗？目前我们还不知道答案，但是我们换一个角度思考。类调用方法既是类对象调用方法，按之前我们分析得到的结果：<strong>对象的方法保存在对象所对应的类中</strong>。类一个一个对象，那么其方法必定也保存在类所对应的类中，即：元类中，但是请注意这并不是一个新的结构，只是一个名词而已其结构还是 objc_class。</p>
<p>元类我们从结构上知道，它也是一个 objc_class 的结构体。所以其中保存着类对象所执行的方法——类方法。既然是元类那么其必定也有 isa 指针，这个指针指向什么呢？请耐心看下去。</p>
<h2 id="对象和类的继承机构"><a href="#对象和类的继承机构" class="headerlink" title="对象和类的继承机构"></a>对象和类的继承机构</h2><p>普通对象中有 isa 指针指向其类，类对象中也有superclass指向其父类，元类中的 superclass 指针指向的也是其父类，就是元类的父类。元类的父类是什么呢？我们看一张图来了解一下(一图胜千言):</p>
<p><img src="/2018/08/15/类和-isa-指针/对象和类的结构.jpg" alt="F46657E4-1C70-45F0-A09D-FBC0A20E0C51"></p>
<p>在这张图中我们可以看到：</p>
<ul>
<li><strong>实例对象的 isa 指针指向其类，类的 isa 指针指向元类，元类的 isa 指针指向根元类(即 NSObject 的元类)，根元类的 isa 指针指向自己。</strong></li>
<li><strong>实例对象的类的 superclass 指向父类，父类的 superclass 指针指向其父类，最终指向 NSObject，NSObject 的 superclass 指针指向 nil。</strong></li>
<li><strong>元类的superclass 指向其类对象父类的元类，并最终指向 NSObject 类的元类，NSObject 的元类的 isa 指针指向 NSObject。</strong></li>
</ul>
<blockquote>
<p>参考资料:</p>
<p>浅谈 Objective-C 中的元类 (meta-class):<a href="https://www.jianshu.com/p/79b06fabb459" target="_blank" rel="noopener">https://www.jianshu.com/p/79b06fabb459</a> </p>
<p>iOS 常见知识点（一）：Runtime：<a href="https://www.jianshu.com/p/965bd18cb056" target="_blank" rel="noopener">https://www.jianshu.com/p/965bd18cb056</a> </p>
<p>What is a meta-class in Objective-C?：<a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></p>
<p>方法缓存与查找：<a href="https://juejin.im/post/5b1b45c36fb9a01e5b10f96b" target="_blank" rel="noopener">https://juejin.im/post/5b1b45c36fb9a01e5b10f96b</a></p>
<p>c++模板中的 typename 和 template 关键字用法:<a href="https://blog.csdn.net/hycoldrain/article/details/3716131" target="_blank" rel="noopener">https://blog.csdn.net/hycoldrain/article/details/3716131</a></p>
<p>OC 中 objc_selector 结构体详解:<a href="https://blog.csdn.net/jeffasd/article/details/52084639" target="_blank" rel="noopener">https://blog.csdn.net/jeffasd/article/details/52084639</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记(一)</title>
    <url>/2018/07/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Effective-Objective-C-2-0笔记-一"><a href="#Effective-Objective-C-2-0笔记-一" class="headerlink" title="Effective Objective-C 2.0笔记(一)"></a>Effective Objective-C 2.0笔记(一)</h2><p>一直在看大神博客，虽然讲的很详细，大神们都讲解的很透彻，但是对于我而言总是少了一个系统的学习。只是在我脑中是散乱着分布的。我就想找一本书来看看，更加系统的去接触和了解系统底层的一些组成。这次我买的是一本非常受人推崇，并且我自己看了也觉得非常好，非常有深度却又不晦涩的一本书——<code>Effective Objective-C 2.0</code>。</p>
<p>这是记录我自己学习历程的一篇文章,希望我能够在技术这条路上越走越远。</p>
<a id="more"></a>
<h1 id="第一章：熟悉-Objective-C"><a href="#第一章：熟悉-Objective-C" class="headerlink" title="第一章：熟悉 Objective-C"></a>第一章：熟悉 Objective-C</h1><h2 id="第一条：了解-Objective-C-语言的起源"><a href="#第一条：了解-Objective-C-语言的起源" class="headerlink" title="第一条：了解 Objective-C 语言的起源"></a>第一条：了解 Objective-C 语言的起源</h2><p><code>Objective-C</code> 使用的是<code>消息结构(messaging structure)</code>而非<code>函数调用(function calling)</code>。</p>
<p>首先让我们了解消息结构和函数调用的含义。</p>
<p><strong><code>消息结构(messaging structure)</code>:使用消息结构的语言其执行的代码是由运行时环境所决定。所以消息结构是动态语言，只有在运行时才知道调用了那个方法函数。所以消息结构语言的多态也只有在运行时才回去查找所要执行的方法，实际上编译器甚至不关心执行方法的对象是何种类型，收到消息的对象问题也需要在运行时处理，其过程叫做<code>动态绑定(dynamic binding)</code>。</strong></p>
<p><strong><code>函数调用(function calling)</code>:使用函数调用的语言其执行的代码是由编译器决定的，并且如果函数是多态的，那么在运行时需要按照“<code>虚方法表(virtual table)</code>来查出到底要执行那个函数。”</strong></p>
<p><strong><code>虚方法表(virtual table)</code>:虚方法表是由编程语言为实现“<code>动态派发(dynamic dispatch)</code>“或”<code>运行时方法绑定(runtime method binding)</code>”而采用的一种机制。</strong></p>
<p><strong><code>Objective-C</code>的重要工作全部都由”<code>运行时组件(runtime component)</code>“而非编译器来完成</strong>。使用<code>Objective-C</code>的面向对象特性所需的全部数据结构及函数都在运行时组件里。举例来说，运行期组件中包括所有的内存管理方法。运行期组件本质上就是一种与开发者所编写代码相链接的”<code>动态库(dynamic library)</code>“，其代码能把开发者所编写的所有程序粘合起来。这样的话，只需更新运行时组件，即可提升应用程序性能。而函数调用的语言若想获得类似的提升，则必须重新编译应用程序代码。</p>
<p><strong>Objective-C 是 c 的超集</strong>，所有C语言中所有功能在编写 Objective-C 代码时依然适用。其中尤为重要的是要理解 C语言中的<code>内存模型(memory model)</code>(参考文献中附有链接)。这有助于理解 Objective-C 中的内存模型及其<code>&quot;自动引用计数(reference countinng)&quot;</code>机制的工作原理。若要理解内存模型，则需明白：<code>Objective-C</code>语言中指针是用来指示对象的。要想声明一个变量，令其指代某个对象，可用如下语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *someString = @&quot;The string&quot;;</span><br></pre></td></tr></table></figure>
<p>它声明了一个名为 someString 的变量，其类型是 NSString*。也就是说，此变量指向 NSString 的指针。所有的 Objective-C 对象必然是这样声明的。因为<strong>对象所占内存总是分配在<code>“堆空间(heap space)”</code>中，而绝不会分配在“栈(stack)”上。</strong></p>
<p><strong>分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</strong>在 Objective-C 中将堆内存管理抽象了出来。不需要主动使用 malloc 以及 free 来分配或者释放对象所占用的内存。Objective-C 运行期环境把这部分工作抽象为一套内存管理架构，名为”引用计数”。</p>
<blockquote>
<p>参考文献:</p>
<p>没看过这篇文章，别说你真的了解Objective-C：<a href="https://blog.csdn.net/youshaoduo/article/details/64191625" target="_blank" rel="noopener">https://blog.csdn.net/youshaoduo/article/details/64191625</a></p>
<p>第一条：了解Objective-C语言的起源：<a href="https://zhuanlan.zhihu.com/p/34752950" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34752950</a></p>
<p>c语言内存模型：<a href="https://www.cnblogs.com/haore147/p/3921263.html" target="_blank" rel="noopener">https://www.cnblogs.com/haore147/p/3921263.html</a></p>
</blockquote>
<h2 id="第二条：在类的头文件中尽量少引入其他头文件"><a href="#第二条：在类的头文件中尽量少引入其他头文件" class="headerlink" title="第二条：在类的头文件中尽量少引入其他头文件"></a>第二条：在类的头文件中尽量少引入其他头文件</h2><p>与 c 和 C++一样 oc 也使用“头文件(header file)”与”实现文件(implementation file)”来分隔代码。只是 c 和 c++中是使用 #include 引入头文件，这样的引入方式会造成重复引入，例如：ClassA与 ClassB 均引入了 ClassC，当 ClassD 同时引入 ClassA 和 ClassB 时此时会产生重复引用。而 oc 中使用#import 引入头文件，#import 的作用和#include的作用相似，只是#import 会处理重复引用的问题。</p>
<p>当在头文件中不需要了解另一个类的具体实现的时候，请尽量使用@Class。</p>
<h2 id="第三条：多用字面量语法少用与之等价的方法"><a href="#第三条：多用字面量语法少用与之等价的方法" class="headerlink" title="第三条：多用字面量语法少用与之等价的方法"></a>第三条：多用字面量语法少用与之等价的方法</h2><p>字面量语法实际上就是一种“语法糖”(syntactic sugar)。</p>
<ul>
<li>字面量语法非常简明扼要。</li>
<li>应该通过取下标语法来访问数组下表或字典中键相对应的元素。</li>
<li>用字面量语法创建数组或者字典时如果传入 nil 元素则会报错，而使用与之等价的创建方法并不会报错，而是成功创建一个数组或者字典，其值是 nil 之前的元素。</li>
</ul>
<h2 id="第四条：多用类型常量，少用-define-预处理指令"><a href="#第四条：多用类型常量，少用-define-预处理指令" class="headerlink" title="第四条：多用类型常量，少用#define 预处理指令"></a>第四条：多用类型常量，少用#define 预处理指令</h2><p>使用#define 创建一个常量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3</span><br></pre></td></tr></table></figure>
<p>上述的预处理指令会将代码中所有 ANIMATION_DURATION 字符串替换为 0.3 。但是这样定义并不会有类型信息。并且即使有人重新定义了该值，编译器也不会产生警告信息。所以我们尽量使用类型常量来替换#deifne 预处理指令。现在我们以类型常量来定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br></pre></td></tr></table></figure>
<p>使用此方法定义的常量包含类型信息，其好处是能清楚的了解常量的含义。还要注意常量的命名法：若常量局限于某“编译单元”(translation unit 也就是“实现文件” ， implementation file)之内，则要在前面添加字幕k；若是常量在类之外可见，通常都是以类名为前缀。</p>
<h2 id="第五条：用枚举表示状态、选项、状态码"><a href="#第五条：用枚举表示状态、选项、状态码" class="headerlink" title="第五条：用枚举表示状态、选项、状态码"></a>第五条：用枚举表示状态、选项、状态码</h2><p>由于 Objective-C 是基于 C语言的，所以 C语言拥有的枚举功能(enum)，Objective-C 也拥有。</p>
<p>但是由于传统定义枚举的方式太不简洁，所以我们可以采用typedef关键字为枚举设置一个别名。示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum EOCConnectionState</span><br><span class="line">&#123;</span><br><span class="line">    EOCConnectionStateDisconnected,</span><br><span class="line">    EOCConnectionStateConnecting,</span><br><span class="line">    EOCConnectionStateConnected</span><br><span class="line">&#125;;</span><br><span class="line">typedef enum EOCConnectionState EOCConnectionState;</span><br></pre></td></tr></table></figure>
<p>这时候我们就可以使用简写的EOCConnectionState来替代完整的 enum EOCConnectionState了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 现在定义的表达式</span><br><span class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</span><br><span class="line">// 原来复杂的表达式</span><br><span class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</span><br></pre></td></tr></table></figure>
<p>C++11标准修订了枚举的某些特性，其中一项改动是：可以指明用何种“底层数据类型”(underlying type)来保存枚举类型的变量。这样做的好处是，可以向前声明枚举变量了。若是不指定底层数据类型，则无法向前声明枚举类型，因为<strong>编译器不清楚底层数据类型的大小</strong>，所以在用到此枚举类型时，也就不指定究竟该给变量分配多少空间。</p>
<p>指定底层数据类型所用的语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum EOCConnetionStateConnectionState : NSInterger &#123;/* .....  */&#125;</span><br></pre></td></tr></table></figure>
<p>上面这行代码确保枚举的底层数据类型是 NSInteger。也可以在向前声明时指定底层数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum EOCConnectionStateConnectionState : NSInteger;</span><br></pre></td></tr></table></figure>
<p>还可以并不使用编译器所分配的信号，而是手工指定某个枚举成员变量所对应的值。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum EOCConnectionStateConnectionState</span><br><span class="line">&#123;</span><br><span class="line">    EOCConnectionStateDisconnected = 1,</span><br><span class="line">    EOCConnectionStateConnecting,</span><br><span class="line">    EOCConnectionStateConnected</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码把EOCConnectionStateConnectionState的值设置为1，而不是编译器所分配的0。如前所述，接下来的几个枚举的值都会在上一个的基础上递增1。比如说，EOCConnectionStateConnected的值就是3。</p>
<p>定义选项选项的时候也需要使用枚举。只要枚举定义的对，各选项之间就可以通过“按位或操作符”(bitwise OR operator) 来组合。下面的代码是 iOS框架中用以表示视图应该如何在水平或垂直方向上调整大小:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class="line">    UIViewAutoresizingNone                 = 0,</span><br><span class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</span><br><span class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</span><br><span class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</span><br><span class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</span><br><span class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</span><br><span class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个选项均可以启用或者禁用，使用上述方式来定义枚举值即可保证这一点，因为在每个枚举值所对应的二进制表示中，只有一个二进制的值是1。用“按位或操作”可组合多个选项，例如UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight。用“按位与操作符”即可判断出是否已启用某个选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;</span><br><span class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth)</span><br><span class="line">&#123;</span><br><span class="line">    // UIViewAutoresizingFlexibleWidth is set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否要将代码按C++模式编译，NS_OPTIONS 宏的定义方式也有不同。如果不按 C++编译，那么其展开方式就和 NS_ENUM 相同。若按照 C++编译，则展开后的代码略有不同。原因在于，用按位或运算符来操作两个枚举时，C++编译模式的处理办法与非 C++模式不一样。作为选项的枚举值经常需要使用按位或运算符来组合。在用或运算操作两个枚举值时。C++认为运算结果的类型应该是枚举的底层数据类型本身，也就是 NSInteger。而且 C++类型不允许这个底层类型隐式转换为枚举类型本身。我们用 EOCPermittedDirection 来演示一下，假设按照 NS_ENUM 方式将其展开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;</span><br><span class="line">enum EOCPermittedDirection : int</span><br><span class="line">&#123;</span><br><span class="line">    EOCPermittedDirectionUp		= 1&lt;&lt;0,</span><br><span class="line">    EOCPermittedDirectionDown	= 1&lt;&lt;0,</span><br><span class="line">    EOCPermittedDirectionLeft	= 1&lt;&lt;0,</span><br><span class="line">    EOCPermittedDirectionRight	= 1&lt;&lt;0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后考虑下列代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft|EOCPermittedDirectionUp;</span><br></pre></td></tr></table></figure>
<p>若编译器按照 C++(或 Objective-C)模式编译，则会给出下列错误信息：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">error : cannot initalize a variable of type</span><br><span class="line"><span class="string">'EOCPermittedDirection'</span> with an rvalue of type <span class="string">'int'</span></span><br></pre></td></tr></table></figure>
<p>如果想要编译这行代码，就要将按位操作的结果显示转换为EOCPermittedDirection。所以，在 C++模式下应该使用另一种方式定义 NS_OPTIONS 宏，以便省去类型转换操作。鉴于此，<strong>凡是需要使用按位操作的枚举都应该使用 NS_OPTIONS 定义。若是枚举不需要组合，则使用 NS_ENUM。</strong></p>
<p>温馨提醒：若是对枚举类型进行 switch 判断操作，则最好不要加上 default 分支，因为这样就可以再枚举类型增加的时候提醒何处未处理这个新的状态。</p>
<p>要点：</p>
<ul>
<li>应该使用枚举表示状态机的状态、传递给方法的选项以及状态码码等值，给这个值去个通俗易懂的名字。</li>
<li>如果传递给某给方法的的选项表示为枚举值，而多个选项又可以同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作符将其组合起来。</li>
<li>使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是使用开发者所选的底层数据类型实现出来的，而不会采用编译器所所选的类型。</li>
<li>在处理枚举类型的 switch 选项中，不要实现 default 分支。这样的话再加入新枚举状态的时候就会通知给开发者：switch 语句并未处理所有枚举。</li>
</ul>
<h1 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h1><p><strong>“对象”就是”基本构造单元”(buliding block)</strong>，开发者可以通过对象来储存并传递数据。<strong>在对象之间传递并执行任务的过程就叫做消息传递。</strong></p>
<p><strong>当程序运行起来之后，为其提供相关支持的代码就叫做“Objective-C 运行时环境”。</strong>它提供了一些使得对象之间能够传递消息的重要函数，并且包含创建类实例所用的全部逻辑。</p>
<h2 id="第六条：理解“属性”这一概念"><a href="#第六条：理解“属性”这一概念" class="headerlink" title="第六条：理解“属性”这一概念"></a>第六条：理解“属性”这一概念</h2><p>Objective-C 对象通常会把其所需要的数据保存成为各种实例变量。实例变量一般通过”读取方法”(access method)来访问。</p>
<p>下述代码是声明实例变量的一种方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_firstName;</span><br><span class="line">    NSString *_lastName;</span><br><span class="line">    @private</span><br><span class="line">    NSString *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这是很多语言采用的写法，但是在 Objective-C 中并使用这种方法来做。这种写法的问题如下：<strong>对象布局在编译器(compile time)就已经固定了，只要碰到_firstName 变量的代码，编译器就把其替换为”偏移量”(offset)，这个偏移量是”硬编码”(hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</strong></p>
<p>但是此时就会出现一个问题，就是当你又添加了一个实例变量，那就比较麻烦了。例如在_firstName 变量之前添加一个新的变量NSDate *_dateOfBirth。此时原本表示_firstName 的偏移量现在却指向了_dateOfBirth。运用了偏移量硬编码的代码都会受到错误的值。</p>
<p>如果代码使用了编译器计算出来的偏移量，那么在修改类定义之后必须要重新编译，否则就会出错(如上例所示)。每种语言都有其解决方式，Objective-C 的做法是：<strong>把实例变量作为一种存储偏移量所用的“特殊变量”，加油类的对象保管。偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了</strong>，这样的话无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实力变量，这就是稳固的<strong>“应用程序二进制接口”(Application Binary Interface,ABI)</strong>。ABI 定义了许多的内容，其中一项就是生成代码时所应遵循的规范。</p>
<p>如果使用了属性，那么<strong>编译器就会自动编写访问这些属性所需的方法</strong>，此过程叫做”自动合成”。需要强调的是，<strong>这个过程由编译器在编译期执行</strong>，所以编辑器里看不到这些“合成方法”的源代码。除了生成方法代码以外，编译器还要自动向类中添加适当类型的实例变量，并在属性名前面添加下划线(‘_’)，以此作为实例变量的名字。当然，在<strong>代码中也可以使用@synthesize语法来制定实例变量的名字</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation EOCPerson</span><br><span class="line"></span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>但是一般情况下尽量少用或者不用这个语法。</p>
<p>若是不想要编译器自动合成存取方法，则可以自己实现，如果你只实现了其中一个存取方法， 则另一个方法也会由编译器来合成。如果想要阻止编译器自动合成存取方法，那就要使用@dynamic关键字。它会告诉编译器不要为其创建存取方法，也不用自动创建实现属性所用的实例变量。而且，在编译访问属性代码的时候，即使编译器发现没有定义存取方法，也不会报错，因为它相信这些方法能够在运行期找到。</p>
<h3 id="属性性质"><a href="#属性性质" class="headerlink" title="属性性质"></a>属性性质</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性。如果属性具备 nonatomic 性质，则不使用同步锁。</p>
<h4 id="读-写权限"><a href="#读-写权限" class="headerlink" title="读/写权限"></a>读/写权限</h4><ul>
<li>具备readwrite特性的属性拥有setter 和 getter。若改属性由@synthesize实现，则编译器会自动生成这两个方法。</li>
<li>具备 readonly 特性的属性只拥有获取方法。只有当该属性由@synthesize 实现时，编译器才会为其合成获取方法。</li>
</ul>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><p>属性用于封装数据，而数据则要有”具体的所有权语义”。下面这一组特质仅会影响 setter。</p>
<ul>
<li>assign：setter 仅会针对“纯量类型”(例如，CGFloat 或者 NSInteger 等)的简单赋值操作。</li>
<li>strong：此特性表明该属性定义了一种”拥有关系“。为这种属性设置新值的时候，会先保留新值然后释放旧值，接着将新值赋值上去。(注意这里的顺序，一定是先保留新值然后释放旧值，不能相反，否则假设新值和旧值是同一个值的话会造成值被释放被设为 nil)。</li>
<li>weak：此特性定义了一种“非拥有关系”。为这个属性设置新值的时候，设置方法既不会保留新值，也不会释放旧值。此特性同 assign 类似，然而在此属性所知的对象被设置摧毁之后，属性值会被设置为 nil。</li>
<li>unsafe_unretained：此特性的语义和 assign相同，但是它适用于“对象类型”，该特质表示一种“非拥有关系”(unretained)，当该属性所指向的对象遭到摧毁时，属性值不会自动清空(nil,unsafe)，这一点与 weak 有区别。</li>
<li>copy：此特性所表达的属性关系和 strong 类似。然而设置方法并不保留新值，而是将其“拷贝”(copy)。</li>
</ul>
<p>详细请看——<a href="/2018/08/14/内存管理语义/" title="内存管理语义">内存管理语义</a></p>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>可以使用如下特质来指定存取方法的方法名:</p>
<ul>
<li>getter=<name>：指定getter 的方法名。在系统中有很多BOOL 属性其方法名被加上“is”前缀。</name></li>
<li>setter=<name>：指定setter 的方法名，这种用法不太常见。</name></li>
</ul>
<p>需要注意的是：若是自己来实现这些存取方法，那么应该保证<strong>其具备相关属性所声明的特质</strong>。</p>
<h2 id="第七条：在对象内部尽量直接访问实例变量"><a href="#第七条：在对象内部尽量直接访问实例变量" class="headerlink" title="第七条：在对象内部尽量直接访问实例变量"></a>第七条：在对象内部尽量直接访问实例变量</h2><p>使用访问方法和使用变量设置值，有如下几个区别：</p>
<ul>
<li>又不不经过 Objective-C 的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li>
<li>直接访问实例变量时，就绕过了其内存管理语义。例如，在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值释放旧值。</li>
<li>若是直接访问实例变量，则不会触发 KVO(键值观察)。</li>
<li>通过属性来访问有助于错误排查，因为可以在访问方法里添加断点调试。</li>
</ul>
<p>要点:</p>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据的时候，则应该通过属性来写。</li>
<li>在某个页面或者程序启动的时候不需要立刻初始化的数据，我们可以使用“懒加载”的方式适时加载。</li>
</ul>
<h2 id="第八条：理解“对象等同性”这一概念"><a href="#第八条：理解“对象等同性”这一概念" class="headerlink" title="第八条：理解“对象等同性”这一概念"></a>第八条：理解“对象等同性”这一概念</h2><p>在比较变量或者属性相等的时候我们在其他语言中可能用到的最多的就是==操作符。但是==操作符却有其弊端，即该操作只是比较两个对象的指针本身，而不是对其所指的对象。所以有时候比较出来的结果并不是我们想要的，这时候我们应该使用 NSObject 协议中声明的”isEqual:”方法来判断两个对象的等同性。</p>
<p>NSObject 协议中有两个用于判断等同性的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object ;</span><br><span class="line">- (NSUInteger)hash;</span><br></pre></td></tr></table></figure>
<p>NSObject 类对这两个方法的默认实现是：<strong>当且仅当”指针值”完全相同的时候，才能意味着这两个对象相等</strong>。<strong>如果”isEqual:”方法判断这两个对象相等，那么它们 hash 必定也会返回一个相同的值。但是如果其 hash 值相同的，却并不一定表示它们相等</strong>。</p>
<p>如下是一个 isEqual 的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface CopyTest : NSObject</span><br><span class="line"></span><br><span class="line">@property (copy,nonatomic) NSMutableString *firstName;</span><br><span class="line">@property (copy,nonatomic) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (object == self) return true;</span><br><span class="line">    if ([object class] != [self class]) return false;</span><br><span class="line">    CopyTest *anotherObject = (CopyTest *)object;</span><br><span class="line">    </span><br><span class="line">    if (![self.lastName isEqualToString:anotherObject.lastName]) return false;</span><br><span class="line">    else if (![self.firstName isEqualToString:anotherObject.firstName]) return false;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说过”isEqual:”相等，则 hash 必定相等。接下来我们就实现 hash。</p>
<p>hash 有多种实现方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一种:给定一个固定的值</span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    return 1170;</span><br><span class="line">&#125;</span><br><span class="line">// 第二种：将属性都格式化为字符串，然后返回字符串的 hash</span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    NSString *hashString = [NSString stringWithFormat:@&quot;%@%@&quot;,self.firstName,self.lastName];</span><br><span class="line">    return [hashString hash];</span><br><span class="line">&#125;</span><br><span class="line">// 第三种：返回各个属性的 hash，并取其值的异或。</span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    NSUInteger firstNameHash = [_firstName hash];</span><br><span class="line">    NSUInteger lastNameHash = [_lastName hash];</span><br><span class="line">    return firstNameHash ^ lastNameHash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来分析一下这三种做法:</p>
<p>首先，这三种做法都是可行的做法，但是前两种做法都有其比较大的弊端。第一种：该做法给定一个值，在这种做法中，会对 collection 产生性能问题。<strong>因为 collection 在做哈希表(hash table)索引的时候，会用对象的哈希码做索引。</strong>假如某个 collection 使用 set 来实现的，那么 set 可能会根据哈希码将对象分编到不同的分组上。在向 set 中添加新对象时，要根据其哈希码找到与之对应的数组，遍历数组，依次检查其中各个数据，看数组中是否已经存在有对象和即将加入的对象相等。如果相等，就说明该对象已经添加到 set 中了。由此可见，如果每个对象的 hash 都是固定的一个值，那么在 set 中有10000个此类型对象的时候，set 就会遍历10000次，这会十分消耗性能。</p>
<p>第二种做法：该做法是符合约定的，但是也有一个十分突出的问题，因为在每次调用这个方法的时候还要承担创建字符串的内存开销，所以比返回单一值要慢，并且将其添加到 collection 中也会产生严重的性能问题。</p>
<p>第三种做法：取属性的哈希码，这种方法相较于上面两种。既能保持高效率，又能将生成的哈希码限定于一定范围之内。但是此算法生成的哈希码还是会碰撞，不过至少可以保证哈希码有多重可能的取值。</p>
<h2 id="第九条：以“类族模式”隐藏实现细节"><a href="#第九条：以“类族模式”隐藏实现细节" class="headerlink" title="第九条：以“类族模式”隐藏实现细节"></a>第九条：以“类族模式”隐藏实现细节</h2><p>系统框架中存在着许多的类族。大部分的 collection 类都是类族。例如 NSArray 和其可变版本 NSMutableArray。在使用 NSArray 的 alloc 方法获取实例时，该方法首先会分配一个属于某类的实例，此实例充当为”占位数组”。该数组稍后会转为另一个类的实例，那个类则是 NSArray 的实体子类。</p>
<p>对类族对象判断类型是否相等要使用方法”isKindOfClass:”。</p>
<p>要点：</p>
<ul>
<li>类族方式将一些实现细节隐藏在一套简单的公共接口后面。</li>
<li>系统框架经常使用类族。</li>
<li>从类族的公共基类中继承子类时要当心。</li>
</ul>
<h2 id="第十条：在既有类中使用关联对象存放自定义数据"><a href="#第十条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第十条：在既有类中使用关联对象存放自定义数据"></a>第十条：在既有类中使用关联对象存放自定义数据</h2><table>
<thead>
<tr>
<th style="text-align:center">关联类型</th>
<th style="text-align:center">等效的@property 属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:center">assign</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:center">nontomic,retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:center">nonatomic,copy</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:center">retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY</td>
<td style="text-align:center">copy</td>
</tr>
</tbody>
</table>
<p>可以使用如下方法管理关联对象：</p>
<ul>
<li><p>objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</p>
<pre><code>id _Nullable value, objc_AssociationPolicy policy)
</code></pre><p>此方法可以使用给定的键和策略为某对象设置关联对象值。</p>
</li>
<li><p>objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) </p>
<p>此方法可以根据给定的值从某对象中去除相应的关联对象值。</p>
</li>
<li><p>objc_removeAssociatedObjects(id _Nonnull object) </p>
<p>为指定类移除全部的关联对象。</p>
</li>
</ul>
<p>我们可以将关联对象想象为是字典对象，存取关联对象值就是对字典对象调用[dictionary setObject:obj forKey:key]和[dictionary objectForKey:key]。两者之间有个重要的区别：设置关联对象时用的键是个”<a href="https://en.wikipedia.org/wiki/Opaque_pointer" target="_blank" rel="noopener">不透明指针</a>“(opaque pointer)。如果在两个键上调用”isEqual:”方法的返回值是 YES，那么字典对象就认为二者相等。然而在关联对象设置值的时候只有在二者必须是完全相同的指针才行。鉴于此，设置关联对象时，通常使用静态全局常量。</p>
<p>使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种方式:</span><br><span class="line">- (NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObjc:(NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(objc), objc, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">// 第二种方式</span><br><span class="line">static const NSString *objcKey = @&quot;objcKey&quot;;</span><br><span class="line">- (NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;objcKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObjc:(NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;objcKey, objc, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">// 第三种</span><br><span class="line">- (NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &quot;objcKey&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObjc:(NSObject *)objc</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &quot;objcKey&quot;, objc, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意键要确保其唯一性，推荐使用第一种方式。</p>
<p>要点:</p>
<ul>
<li>可以通过”关联对象”机制来吧两个对象连起来。</li>
<li>定义关联对象可指定内存管理语义，用以模仿定义属性时采用的“拥有关系”与“非拥有关系”。</li>
<li>只有在其他用法不可用的情况下在能考虑使用关联对象，因为这可能会引入难以查找的 bug。</li>
</ul>
<h2 id="第十一条：理解-objc-msgSend-的作用"><a href="#第十一条：理解-objc-msgSend-的作用" class="headerlink" title="第十一条：理解 objc_msgSend 的作用"></a>第十一条：理解 objc_msgSend 的作用</h2><p>消息传递是 Objective-C 中不可或缺的一部分。消息有”名称(name)”或”选择子(selector)”,可以接受参数，而且可能还会有返回值。</p>
<p>在 C语言中使用“静态绑定”，也就是说在编译期就能决定运行时所调用的函数。并且函数地址实际上是硬编码在指令中的。</p>
<p>在 Objective-C 中，如果想某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的 C语言函数，然而对象在收到消息之后，究竟该调用哪个方法完全是由运行期决定的，甚至可以再运行期改变。</p>
<p>给对象发送消息可以这样来写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id resultValue = [someObject messageName : parameter];</span><br></pre></td></tr></table></figure>
<p>在本例中，someObject 叫做”接收者”,messageName 叫做”选择子(selector)”。选择子和参数合起来成为消息。编译器看到此消息后，会将其转换为标准的 C语言调用，所调用的函数乃是消息传递机制中核心函数，叫做 objc_msgSend,其原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_msgSend</span><span class="params">(id self , SEL cmd,...)</span></span></span><br></pre></td></tr></table></figure>
<p>这个是参数个数可变的函数，能够接收两个以上的参数。第一个参数代表接收者，第二个参数代表选择子，后续参数就是消息中的参数，其顺序不变。<strong>选择子指的就是方法的名字</strong>。编译器会把刚才那个例子中的消息转换为如下函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</span><br></pre></td></tr></table></figure>
<p>objc_msgSend 函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其”方法列表”(关于方法列表请看本文——<a href="/2018/08/15/类和-isa-指针/" title="类和 isa 指针">类和 isa 指针</a>)，如果能找得到与选择子名称相符的方法，就跳转至实现代码。若是找不到相符的方法，那就沿着继承体系继续向上查找，等找到合适的方法后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”(message forwrarding)操作。消息跳转会在第十二条中详解。</p>
<p>这么说来，想要调用一个方法是有很多个步骤的。<strong>所幸objc_msgSend 会将匹配结果缓存到”快速映射表”中，每个类都有这样一块缓存</strong>，若是稍后还向该类发送与选择子相同的消息，那么执行就会快了。</p>
<p>上面讲的就是部分的消息调用过程，还有一些特殊情况需要运行时的其他函数来处理:</p>
<ul>
<li>objc_msgSend_stret：若是消息返回的结构体，则由此函数处理。只有将CPU 寄存器能够容纳消息返回的类型时，才能处理此消息。若是返回值无法容纳于寄存器(例如返回的结构体太大了)，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li>objc_msgSend_fpret：如果消息返回的是浮点数，那么将交由此函数处理。在某些架构的的 CPU 中调用函数时，需要对“浮点寄存器”做特殊处理，也就是说，通常所用的 objc_msgSend 在这中情况下并不合适。这个函数是为了处理 x86等架构 CPU 中某些令人稍觉惊讶的情况。</li>
<li>objc_msgSendSuper：如果需要给超类发送消息，例如:[super message:parameter]，那么就交由此函数处理。也有另外两个与 objc_msgSend_stret和objc_msgSend_fpret等效的函数，用于给 super 发送相应的消息。</li>
</ul>
<p>每一个Objective-C 对象的每一个方法都可以视为简单的函数，其原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;return_type&gt; Class_selector(id self , SEL _cmd , ...)</span><br></pre></td></tr></table></figure>
<p>要点:</p>
<ul>
<li>消息由接收者、选择子和参数构成。给对象”发送消息”也就相当于在该对象上”调用方法”。</li>
<li>给对象发送全部的消息都要经过“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码。</li>
</ul>
<h2 id="第十二条：理解消息转发机制"><a href="#第十二条：理解消息转发机制" class="headerlink" title="第十二条：理解消息转发机制"></a>第十二条：理解消息转发机制</h2><p>第十一条讲的是对象的消息传递机制，而本条要讲解的是<strong>对象收到无法解读的消息会如何处理</strong>。</p>
<p>在编译期向类发送其无法解读的消息并不会报错，因为运行时的强大特性允许它能够在运行期添加方法。<strong>当对象接收到无法解读的消息后，就会启动“消息转发”机制</strong>。</p>
<p>消息转发分为两大阶段。<strong>第一阶段先征询接收者所属的类，看其是否能动态添加方法</strong>，以处理当前这个“未知的选择子”，这叫做”动态方法解析“。<strong>第二阶段涉及”完整的消息转发机制“</strong>。如果运行期系统已经把第一阶段执行完毕，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。<strong>这里又细分为两小步</strong>。首先接收者看看有没有其他对象能够处理这条消息。若有，则运行期系统会把消息交给那个对象来处理，于是消息转发过程结束，一切如常。若没有”备援的接收者“，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会令其设法解决当前还未处理的这条消息。</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>对象在接收到无法解析的消息时，会调用所在类的下列类方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>
<p>首先我们看苹果官方的解释:<code>Dynamically provides an implementation for a given selector for an instance method</code>。就是动态的为给定的选择子提供实现。该方法的返回值是一个 BOOL 类型，表示该类能否新增一个实例方法来处理此选择子。而其参数是 SEL 类型，就是代表那个无法解析的消息。再继续往下执行转发机制之前，本类有机会新增一个处理此选择子的方法。若尚未实现的方法是类方法则会调用下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<h3 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h3><p>若是在上一步中无法处理未知的消息，则还会有第二次机会处理未知的选择子，在这一步系统会问它：能否将此消息转给其他接收者来处理。该步骤对应的处理方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>首先我们看苹果官方文档的解释:<code>Returns the object to which unrecognized messages should first be directed</code>。中文解释为:返回未知消息首先要执行的对象。该方法的参数表示未知的方法，若有备援对象可以处理此未知方法，则返回该对象，否则返回 nil。通过此方案，我们可以”模拟“出“多继承”的某些特性。</p>
<h3 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h3><p>如果转发算法已经进行到了这一步，那么唯一能做的就是启用完整的消息转发机制了。<strong>首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封装于其中。包括此对象的选择子、目标以及参数。在触发 NSInvocation 对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。</strong></p>
<p>此步骤会调用如下方法来转发消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>
<p>来自苹果官方的解释:<code>Overridden by subclasses to forward messages to other objects</code>。中文释义：由子类重写以将消息转发到其他对象。</p>
<p>这个方法很简单，只需要改变调用目标，使消息在新对象上得以调用即可。然而这样实现出来的方法与“备援接收者”方法所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为<strong>：在触发消息之前，先以某种方式改变消息内容，比如是追加另外一个参数或者是改换选择子</strong>等等。</p>
<p>实现该方法时，若是发现某调用操作不应由本类处理，则需要调用超类的同名方法。这样的话集成体系中的每一个类都有机会处理此调用请求，直至 NSObject。到最后如果调用了 NSObject 类的方法，那么该方法还会继续调用“doesNotRecognizeSelector:”以抛出异常，此异常表明选择子最终未能得到处理。</p>
<h3 id="消息转发全流程"><a href="#消息转发全流程" class="headerlink" title="消息转发全流程"></a>消息转发全流程</h3><p>下图描述了消息转发机制处理消息的各个步骤。</p>
<p><img src="/2018/07/16/读书笔记-一/消息转发全流程.png" alt="消息转发全流程"></p>
<p>接收者在每一步中均有机会处理消息。步骤越往后，处理的代价就越大。最好能在第一步就处理完，这样的话运行期系统就能够将此方法缓存起来。如果这个类的实例稍后还接收到同名的选择子，那么根本无需启动消息转发机流程。若想在第三部将消息转发给备援的接收者，还不如把转发步骤放在第二步。因为第三步只是修改了调用目标，这项改动放在第二部会更加简单，不然的话，还得创建并处理完整的 NSInvocation。</p>
<p>要点：</p>
<ul>
<li>若对象无法响应某个选择子，则进入消息转发流程。</li>
<li>通过运行期的动态解析功能，沃恩可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以将某些无法解读的选择子交给其他对象来处理。</li>
<li>经过上述两步骤若是还无法处理选择子，则启动完整的消息转发机制。</li>
</ul>
<h3 id="第十三条：用“方法调配技术”调试“黑盒方法”"><a href="#第十三条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第十三条：用“方法调配技术”调试“黑盒方法”"></a>第十三条：用“方法调配技术”调试“黑盒方法”</h3><p>第十一条中我们讲到：<strong>Objective-C 对象收到消息后，究竟会调用那个方法是在运行期才能解析出来的</strong>。所以给定选择子的方法实现也可以在运行期改变。此方案被称为“方法调配”(method swizzling)。</p>
<p>类的方法列表会把选择子的名称映射到相关的方法实现上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均已函数指针的形式来表示，这种指针叫做 IMP，其原型如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>本条将会谈到如何呼唤两个方法的实现。想交换方法实现，可使用下列函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method _Nonnull m1, Method _Nonnull m2)</span></span></span><br></pre></td></tr></table></figure>
<p>此方法的两个参数表示待交换的两个方法实现，而方法实现可以通过下列函数获得：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Method _Nullable</span><br><span class="line">class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure>
<p>我们开始试验一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Method methodA = class_getInstanceMethod([self class], @selector(methodA));</span><br><span class="line">    Method methodB = class_getInstanceMethod([self class], @selector(methodB));</span><br><span class="line"></span><br><span class="line">    method_exchangeImplementations(methodA, methodB);</span><br><span class="line">    </span><br><span class="line">    [self methodA];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodA</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;----------------------A-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodB</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;----------------------B-------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-08-<span class="number">29</span> <span class="number">17</span><span class="symbol">:</span><span class="number">13</span><span class="symbol">:</span><span class="number">07</span>.<span class="number">129774</span>+080<span class="number">0</span> sadada[<span class="number">6685</span><span class="symbol">:</span><span class="number">340152</span>] ----------------------B-------------------</span><br></pre></td></tr></table></figure>
<p>这个是对自定义的类进行方法实现交换的例子。如果要对系统类进行方法交换应该如何去做呢？首先，如果是两个系统类的方法，只需要直接调用<code>method_exchangeImplementations</code>即可，如果是要使用自定义方法来替换系统方法，只需要给系统类添加一个 “分类”(Category)中添加自定义方法，然后交换这两个方法的实现即可。</p>
<p>要点:</p>
<ul>
<li>在运行期可以向类中新增或者替换选择子所对应的方法实现。</li>
<li>使用另一份实现来替换原有的方法实现，这叫做“方法调配”。</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，不宜滥用。</li>
</ul>
<h2 id="第十四条：理解“类对象”的用意"><a href="#第十四条：理解“类对象”的用意" class="headerlink" title="第十四条：理解“类对象”的用意"></a>第十四条：理解“类对象”的用意</h2><p>消息的接收者究竟是何物？是对象本身吗？运行期系统如何知道某个对象的类型呢？<strong>对象类型并非是编译期便绑定好的，而是在运行期的时候动态查询的</strong>。而且有一个特殊的类型叫做 <code>id</code>，它能够指代任何的 Objective-C 对象类型，并且编译器假定<code>id</code>类型能够响应所有的消息。</p>
<p>“在运行期检视对象类型”这一操作又叫做“类型信息查询”(内省)。这个强大并且有用的特性是内置于 Foundation 框架的 NSObject 协议里的，凡是由公共根类(即 NSObject 和 NSProxy)继承而来的对象都要遵守此协议。</p>
<p>关于什么是类对象可以查看我的这篇文章——<a href="/2018/08/15/类和-isa-指针/" title="类和 isa 指针">类和 isa 指针</a>。</p>
<h3 id="在类集成体系中查询类型信息"><a href="#在类集成体系中查询类型信息" class="headerlink" title="在类集成体系中查询类型信息"></a>在类集成体系中查询类型信息</h3><p>由于 ios 中存在着大量的类族，所以不能简单的用”==”操作符判断对象类型，而是应该用如下两个方法来判断：</p>
<p>判断是否是某个特定类的实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)isMemberOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure>
<p>判断是否是某个特定类或者其子类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)isKindOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure>
<p>判断某个类是否是特定的类或者其子类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)isSubclassOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure>
<p>要点:</p>
<ul>
<li>每个实例都有一个指向 Class 对象，以表明其类型，而这些 Class 对象则构成了类的继承体系。</li>
<li>如果对象类型无法在编译期确定，则就应该使用类型信息查询方法来探知。</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些类对象可能实现了消息转发功能。</li>
</ul>
<h1 id="第三章：接口与-API-设计"><a href="#第三章：接口与-API-设计" class="headerlink" title="第三章：接口与 API 设计"></a>第三章：接口与 API 设计</h1><h2 id="第十五条：使用前缀避免命名冲突"><a href="#第十五条：使用前缀避免命名冲突" class="headerlink" title="第十五条：使用前缀避免命名冲突"></a>第十五条：使用前缀避免命名冲突</h2><p>由于 Objective-C 中没有命名空间这个概念，所以我们在起名时要想办法避免命名冲突。</p>
<p>避免此问题的办法就是变相实现命名空间——为所有名称前都加上适当前缀。但是请注意 <strong>Apple 宣称其保留所有使用“两位字母前缀”的权利，所以一般来说你自己要选用三位字母前缀</strong>。</p>
<p>不仅仅是类名，如果你有为既有的类新增“分类”(Category)，那么一定要给分类和分类中的方法添加前缀。</p>
<p>要点：</p>
<ul>
<li>选择与你公司、引用或者二者都有关的名称作为其类名前缀，并在所有代码中均使用这一前缀。</li>
<li>若是自己所开发的程序库中用到了第三方库，则应为其中的名称添加上前缀。</li>
</ul>
<h2 id="第十六条-提供”全能初始化方法“"><a href="#第十六条-提供”全能初始化方法“" class="headerlink" title="第十六条:提供”全能初始化方法“"></a>第十六条:提供”全能初始化方法“</h2><p>应该在类中提供一个“全能初始化方法”，所有的初始化方法最终都会调用这个方法进行初始化。</p>
<p>要点：</p>
<ul>
<li>在类中提供一个全能初始化方法，并于文档中注明。其他初始化方法最终均应该调用此初始化方法。</li>
<li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该在子类中覆写超类这个方法，并在其中抛出异常。</li>
</ul>
<h2 id="第十七条：实现-description-方法"><a href="#第十七条：实现-description-方法" class="headerlink" title="第十七条：实现 description 方法"></a>第十七条：实现 description 方法</h2><p>调试程序的时候，经常会查看对象信息，一般使用如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,object);</span><br></pre></td></tr></table></figure>
<p>在这方法中是打印 object 的信息，其实这个信息打印就是调用的对象的<code>description</code>方法。所以如果要查看一个自定义类中的信息我们可以通过重写这个方法的方式来打印。这个方法存在于 NSObject 协议中。</p>
<p>NSObject 协议中还有个方法需要注意，那就是 debugDescription，此方法和 description 方法的用法非常相似。二者的区别在于：debugDescription方法是在开发者在 debugger 模式中打印对象才调用的。</p>
<p>要点：</p>
<ul>
<li>实现 description 方法返回一个有意义的字符串，用以描述该实例。</li>
<li>若想在调试时打印出更加详尽的对象描述信息，则应该实现 debugDescription 方法。</li>
</ul>
<h2 id="第十八条：尽量使用不可变对象"><a href="#第十八条：尽量使用不可变对象" class="headerlink" title="第十八条：尽量使用不可变对象"></a>第十八条：尽量使用不可变对象</h2><p>尽量在.h 文件中将属性声明为 readonly，在.m 文件中声明为readwrite，以防止外部修改属性。</p>
<p>要点:</p>
<ul>
<li>尽量创建不可变对象。</li>
<li>若某属性仅可于对象内部修改，则在”class-continuation”分类中将其又 readonly 属性扩展为 readwrite。</li>
<li>不要把可把可变的 collection 作为属性公开，而应提供相关方法，以此改变对象中的可变 collection。</li>
</ul>
<h2 id="第十九条：使用清晰而协调的命名方式"><a href="#第十九条：使用清晰而协调的命名方式" class="headerlink" title="第十九条：使用清晰而协调的命名方式"></a>第十九条：使用清晰而协调的命名方式</h2><p>当你出入 oc 的时候你可能会发现 oc 的语法比大部分语言来说就繁琐很多，从其方法名就能够看出来。但是也正是因为方法名长，所以很多的方法的作用就一目了然。所以名称对于方法来说十分重要。</p>
<p>给方法命名时的注意事项可总结成如下几点：</p>
<ul>
<li>如果方法的返回值是新创建的，那么方法名的首单词应该是返回值的类型，除非前面还有修饰语，例如：localizedString。这点包括存取方法和拷贝对象。</li>
<li>应该把参数名词放在参数前面。</li>
<li>如果方法要在当前对象上执行，那么就应该包含动词。</li>
<li>不要使用 str 这样的简称，应该用 string 这样的全称。</li>
<li>Boolean 属性应加 is 前缀。如果某方法返回非属性的 Boolean 值，那么应该根据其功能，选用 has 或者 is 作为前缀。</li>
<li>get 这个前缀留给借由“输出函数”来保存值的方法，比如说，把返回值填充到“C语言数组“里的那种方法就能够使用这个词作为前缀。</li>
</ul>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>起名时要注意 oc 规范。</li>
<li>方法名要简言意骇，从左到右读起来要像一个句子。</li>
<li>方法名里不要使用缩略名称。</li>
</ul>
<h2 id="第二十条：为私有方法名加前缀"><a href="#第二十条：为私有方法名加前缀" class="headerlink" title="第二十条：为私有方法名加前缀"></a>第二十条：为私有方法名加前缀</h2><p>要点：</p>
<ul>
<li>给私有方法名称加上前缀，这样可以很容易地将其同公共方法区分开来。</li>
<li>不要单用一个下划线作为私有方法的前缀，因为这种方式是预留给苹果公司的。</li>
</ul>
<h2 id="第二十一条：理解-Objective-C-错误模型"><a href="#第二十一条：理解-Objective-C-错误模型" class="headerlink" title="第二十一条：理解 Objective-C 错误模型"></a>第二十一条：理解 Objective-C 错误模型</h2><p>ARC 在默认情况下不是”异常安全的“。具体来说，这意味着：如果抛出异常，那么本应在作用域末尾释放的对象现在确保不会自动释放了。若想生成”异常安全的”代码，需要打开编译器的标志”-fobjc-arc-exceptions”。</p>
<p>由于 oc 中很难写出抛出异常却不导致内存泄漏的代码，所以在<strong>OC中只有在及其罕见的情况下才会抛出异常，异常抛出之后无需考虑恢复问题，而此时应用程序也应该退出</strong>，这就是说不用再编写复杂的“异常安全”代码了。</p>
<p>所以异常只用来处理致命错误，对于非致命错误 oc 的编程范式是：令方法返回值为 nil/0，或是使用 NSError。</p>
<p>NSError 对象里封装了三条消息：</p>
<ul>
<li><p>Error domain(错误范围，其类型为字符串)</p>
<p>错误发生的范围，也就是错误发生的根源，通常用一个特有的全局变量来定义。比方说：“处理 URL的子系统”在从 URL 解析或者获取数据出错了，那么就会使用 NSURLErrorDomain 来表示错误范围。</p>
</li>
<li><p>Error code(错误码，其类型为整数)</p>
<p>独有的错误代码，用于指明在某个范围内具体发生了那种错误。某个特定范围内可能会发生一系列错误，这些错误情况通常采用 enum 定义。</p>
</li>
<li><p>User info(用户信息，其类型为字典)</p>
<p>有关此错误的额外信息，其中包含一个”本地化的描述“，或许还有导致该错误发生的另一个错误，经由此种信息，可将错误串成一条”错误连“。</p>
</li>
</ul>
<p>要点：</p>
<ul>
<li>只有发生了致命错误才应该使用异常。</li>
<li>在错误不是那么严重的情况下，可以指派“委托方法”来处理错误，也可以把错误信息放在 NSError 对象里，经由“输出参数”返回给调用者。</li>
</ul>
<h2 id="第二十二条：理解-NSCopying-协议"><a href="#第二十二条：理解-NSCopying-协议" class="headerlink" title="第二十二条：理解 NSCopying 协议"></a>第二十二条：理解 NSCopying 协议</h2><p>在 oc 中想令自定义的类支持拷贝的特性，则要实现 NSCopying 协议，该协议只有一个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p>为何会出现 NSZone 呢？因为在以前的程序开发中，会据此把内存分为不同的区，而对象会创建在某个区里，以此来防止碎片化的发生。但是现在不用了，每个程序只有一个默认区。</p>
<p><strong>NSZone 是方式内存碎片化而引入的结构。对内存分配的区域进行多重化的管理，根据使用对象的目的，对象的大小分配内存，从而提高内存管理的效率，但是目前在 oc 中使用的 ARC 已经极具高效率，所以现在的运行时系统只是简单的忽略了区域的概念</strong>。</p>
<p>copy 方法由 NSObject实现，该方法以“默认区”参数来调用“copyWithZone:”。覆写 copy 真正需要实现的却是“copyWithZone”方法。</p>
<p>上述方法拷贝出来的是一个不可变的版本，如果需要拷贝出来的是一个可变的版本，则需要遵守 NSMutableCopyingxieyi 并实现如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p>关于深拷贝和浅拷贝请看我这篇文文章——<a href="/2018/07/20/iOS-中的拷贝-copy-和-mutableCopy/" title="iOS 中的拷贝(copy 和 mutableCopy)">iOS 中的拷贝(copy 和 mutableCopy)</a>。</p>
<p>要点：</p>
<ul>
<li>若想令自己所写的对象具有拷贝功能，则需要实现 NSCopying 或者 NSMutableCopying 协议。</li>
<li>如果自定义的对象具有可变版本和不可变版本，则要继承NSMutableCopying和NSCopying协议。</li>
<li>复制对象应该决定进行深拷贝还是浅拷贝，一般来说都是浅拷贝。</li>
<li>如果自定义的对象需要进行深拷贝，则应考虑新增一个专门执行深拷贝的方法。</li>
</ul>
<h2 id="第二十三条：通过委托和数据源协议进行对象间通信"><a href="#第二十三条：通过委托和数据源协议进行对象间通信" class="headerlink" title="第二十三条：通过委托和数据源协议进行对象间通信"></a>第二十三条：通过委托和数据源协议进行对象间通信</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>对象之间经常需要相互通信，“委托模式”就是其中的一种通信方式。此模式有助于数据和业务逻辑的解耦。</p>
<p>委托协议名一般都是在相关类后面添加“delegate”，整个协议名通过“驼峰法”来写。一定要注意：代理通常都需要将其语义设置为 weak 而非 strong。因为通常情况下，扮演 delegate 的那个对象也需要持有本对象。所以为了避免循环引用需要delegate 设置为 weak 或者 unsafe_unretained，推荐设置为 weak。</p>
<p>在协议中很多方法都是可选的，这需要使用”@optional”关键字来表示。若是必选的则需要使用”@required”关键字来表示。对于可选的协议方法，在调用之前首先需要判断委托对象上是否已经实现了这个方法，这是使用如下方法实现的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>这个方法是非常有用的，其官方释义如下:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/<span class="regexp">/Returns a Boolean value that indicates whether the receiver implements or inherits a method that can respond to a specified message.</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 返回一个布尔值，指示接收器是否实现或者继承可以响应指定消息的方法。</span></span><br></pre></td></tr></table></figure>
<p>如果在代理协议中有很多的可选协议，那么就会大量出现<code>respondsToSelector:</code>方法，而且这些方法除了在第一次运行的时候检测有用之外，之后的所有检测事实上都可能是多余的。所以我们需要将方法响应能力给缓存起来，这样就不用每次都去调用此方法。</p>
<p>将方法响应能力缓存起来最好的方式就是使用“位段”(bitfield)数据类型，这是一项乏人问津的 c 语言特性，但是用在此处却是非常合适。我们可以把结构体中某个字段所占用的二进制个数设定为特定的值。比如这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> filedA : <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> filedB : <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> filedC : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> filedD : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在结构体中，filedA位段将占用8个二进制，filedB 四个，filedC 两个，filedD 一个。于是filedA可以表示0~255之间的值，filedD 可以表示0或者1。我们就可以使用这样的位段将委托对象是否实现了协议中的相关方法这一信息缓存起来。此结构体的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int didReceiveData         : 1;</span><br><span class="line">        unsigned int didFailWithError       : 1;</span><br><span class="line">        unsigned int didUpdateProgressTo    : 1;</span><br><span class="line">    &#125; _delegateFlags;</span><br><span class="line">    </span><br><span class="line">// set flag</span><br><span class="line">    _delegateFlags.didReceiveData = 1;</span><br><span class="line">    // check flag</span><br><span class="line">    if (_delegateFlags.didReceiveData)</span><br><span class="line">    &#123;</span><br><span class="line">        // yes , flag set</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样就可在设置代理的 setter 方法中，在设置代理的时候就可以调用<code>respondsToSelector:</code>判断代理是否有能够响应特定选择子的能力,并将其缓存。然后在需要使用代理方法的时候根据缓存结果判断。</p>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>其实事实上数据源也是委托模式的一种，只不过该用法是为了向类提供数据。故而称数据源模式。</p>
<p>要点：</p>
<ul>
<li>委托模式为对象提供了一套接口，使其由此将相关事情告知其他对象。</li>
<li>将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。</li>
<li>当某对象需要从另外一个对象中获取数据时，可以使用委托模式，在这种情况下，该模式为被称为“数据源模式”。</li>
<li>若有必要，可实现含有位段的结构体，将委托对象能够响应相关协议方法的信息缓存至其中。</li>
</ul>
<h2 id="第二十四条：将类的实现代码分散到便于管理的数个分类中"><a href="#第二十四条：将类的实现代码分散到便于管理的数个分类中" class="headerlink" title="第二十四条：将类的实现代码分散到便于管理的数个分类中"></a>第二十四条：将类的实现代码分散到便于管理的数个分类中</h2><p>类中经常容易充满各种方法，并且这些方法实现代码非常长，如果全部都堆在一个巨大的实现文件中，并不加以分类，有时候这样是非常不合适的。</p>
<p>因此我们需要将实现代码分为好几个部分，分散到各个分类之中。cocoa 中 NSURLRequest 类以及其可变版本便是用的这种方法。</p>
<p>要点：</p>
<ul>
<li>使用分类机制把类的实现代码划分为易于管理的小块。</li>
<li>将应该视为“私有”的方法归入名为 Private 分类中以隐藏实现细节。</li>
</ul>
<h2 id="第二十五条：总是为第三方类的分类名称加前缀"><a href="#第二十五条：总是为第三方类的分类名称加前缀" class="headerlink" title="第二十五条：总是为第三方类的分类名称加前缀"></a>第二十五条：总是为第三方类的分类名称加前缀</h2><p>分类机制通常用于向无源码的既有类中添加新的功能。这个特性极为强大，但是在使用时也有其不可忽视的弊端。这个弊端在于：分类中的方法是直接添加到类中的，它们就好比这个类的固有方法。将分类方法加入类中是在<strong>运行期系统加载分类时完成的</strong>。<strong>运行期会将分类中所实现的每个方法都添加到类的方法列表中。如果类原本就有此方法，而在分类中又实现了一遍，那么分类中的实现会覆盖原来那一份实现</strong>。</p>
<p>要解决此问题一般的做法就是：<strong>以命名空间来区分各个分类的名称与其中所对应的方法。</strong>并且要想在 oc 中实现命名空间，只有一个办法：给<strong>相关的分类和方法都添加前缀</strong>。</p>
<p>要点：</p>
<ul>
<li>向第三方类中添加分类时，总应该为其明天添加上前缀。</li>
<li>向第三方类中添加分类时，总应该为其中方法添加上前缀。</li>
</ul>
<h2 id="第二十六条：勿在分类中声明属性"><a href="#第二十六条：勿在分类中声明属性" class="headerlink" title="第二十六条：勿在分类中声明属性"></a>第二十六条：勿在分类中声明属性</h2><p>要点：</p>
<ul>
<li>把封装数据所用的全部属性都定义在主接口里。</li>
<li>在“class-continuation 分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。</li>
</ul>
<h2 id="第二十七条：使用“class-continuation-分类”隐藏实现细节"><a href="#第二十七条：使用“class-continuation-分类”隐藏实现细节" class="headerlink" title="第二十七条：使用“class-continuation 分类”隐藏实现细节"></a>第二十七条：使用“class-continuation 分类”隐藏实现细节</h2><p>“class-continuation”分类和不同分类不同的是，它必须定义在其所接续的那个类的实现文件里。其重要之处在于，这是<strong>唯一能声明实例变量的分类</strong>，并且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。与其他分类不同，“class-continuation”分类没有名字。</p>
<p>为什么要有这种分类呢？因为<strong>其中可以定义方法和实例变量</strong>。为什么能在其中定义方法和实例变量呢？<strong>只因为有“稳固的 ABI“ 这一机制(第六条详解了此机制)，使得我们无需知道对象的大小即可使用它。</strong></p>
<p>实例变量也可以添加在实现块里，从语法上来讲这与直接添加到”class-continuation 分类“等效，只看个人喜好而已。但是由于”class-continuation 分类“中还能定义一些属性，所以在这里额外声明一些实例变量也很合适。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    int _testIntValue;</span><br><span class="line">&#125;</span><br><span class="line">@implementation ViewController&#123;</span><br><span class="line">    int _testValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>通过”class-continuation 分类“向类中新增实例变量。</li>
<li>如果某属性在主接口中声明为”只读“，而类的内部又要用设置方法修改此属性，那么就在”class-continuation 分类“中将其扩展为可读写。</li>
<li>把私有方法的原型声明放在”class-continuation 分类“中。</li>
<li>若想使类所遵从的实例不为人知，则可用”class-continuation 分类“中声明。</li>
</ul>
<h2 id="第二十八条：通过协议提供匿名对象"><a href="#第二十八条：通过协议提供匿名对象" class="headerlink" title="第二十八条：通过协议提供匿名对象"></a>第二十八条：通过协议提供匿名对象</h2><p>协议定义了一系列的方法，遵从此协议的对象应该实现它们(如果这些方法非可选，那么必须实现它们)。于是我们可以用协议把API 之中的实现细节给隐藏起来，将返回的对象设计为遵从此协议的纯 id 类型。这样的话，想要隐藏的类名就不会出现在 API 之中了。</p>
<p>要点：</p>
<ul>
<li>协议可以再某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里定义了对象所应实现的方法。</li>
<li>使用匿名对象来隐藏类型名称(或类名)。</li>
<li>如果具体类型不重要，重要的是对象能够响应(定义在协议里的)特定方法，那么可使用匿名对象来表示。</li>
</ul>
<h1 id="第五章：内存管理"><a href="#第五章：内存管理" class="headerlink" title="第五章：内存管理"></a>第五章：内存管理</h1><h2 id="第二十九条：理解引用计数"><a href="#第二十九条：理解引用计数" class="headerlink" title="第二十九条：理解引用计数"></a>第二十九条：理解引用计数</h2><h3 id="引用计数工作原理"><a href="#引用计数工作原理" class="headerlink" title="引用计数工作原理"></a>引用计数工作原理</h3><p>在 ARC 架构下，对象有一个计数器用以表示有多少个事务想令该对象存活下去。这在oc 中被称为“引用计数”。NSObject 协议声明了三个方法用于操作引用计数，以递增或者递减其值。</p>
<ul>
<li>Retain 递增保留计数。</li>
<li>Release 递减保留计数。</li>
<li>Autorelease 稍后清理自动释放池时，再递减保留计数(第三十四条会详细解释)。</li>
</ul>
<p>查看保留计数值的方法是 <code>retainCount</code>。</p>
<p><strong>对象创建出来时，其保留计数至少为1</strong>。若想继续令其存活则需要调用 retain 方法，若是不想令其存活则需要调用 release 或者 autorelease 方法。<strong>当最终保留计数归零了，对象就回收了，并且系统会将其所占用的内存标记为“可重用”(reuse)</strong>，此时所有指向该对象的引用也都变得无效了。</p>
<p>在对象引用计数将至0时，对象所占用的内存可能会回收，如果回收了再去访问这个对象，则会造成程序崩溃。但是也有可能尚未被回收，此时<strong>对象所占的内存在“解除分配”(deallocated)之后，只是放到了”可用内存池”。如果访问该对象时，该对象的内存尚未被覆写，则改对象仍然有效</strong>。此时程序不会崩溃。</p>
<p>如果对象持有指向其他对象的强引用，则前者“拥有”后者。</p>
<p>在Objective-C 中，调用 alloc 所返回的对象由调用者所拥有。</p>
<h3 id="属性存取方法中的内存管理"><a href="#属性存取方法中的内存管理" class="headerlink" title="属性存取方法中的内存管理"></a>属性存取方法中的内存管理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObj:(<span class="keyword">id</span>)obj</span><br><span class="line">&#123;</span><br><span class="line">    [obj <span class="keyword">retain</span>];</span><br><span class="line">    [_obj release];</span><br><span class="line">    _obj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法将保留新值释放旧值，然后更新实例变量，令其指向新值。顺序很重要，<strong>假如还未保留新值就先释放了旧值，而两个值又指向同一对象，那么先执行的 release 操作就很可能导致系统将此对象永久回收</strong>。而后续的 retain 操作则无法令这个已经被彻底回收的对象复生，于是实例变量就成为了悬挂指针。</p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>在 Objective-C 的引用计数架构中，自动释放池是一个非常重要的特性。调用 release 会立刻递减其引用计数，然而有时候可以不调用它，改为调用 autorelease，<strong>此方法会在稍后递减引用计数，通常是下一次“事件循环”时递减。不过也可能执行的更早一些</strong>(详见34条)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)stringValue</span><br><span class="line">&#123;</span><br><span class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this : @%@&quot;,self];</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时返回的 str 对象其保留计数比期望值要多1，因为调用 alloc 会令保留计数加1，而又没有与之相对应的释放操作。所以我们要想办法将其抵消。</p>
<p>但是不能在方法内释放 str，否则还没等方法返回，系统就把该对象回收了。这里应该用<code>autorelease</code>，它会在稍后释放对象，从而给调用者留下足够长的时间，使其可以再需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”后一定存活。事实上，<strong>释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。</strong>改用如下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"I am this : @%@"</span>,<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于返回的 str 会于稍后自动释放，所以多出来的那一次保留操作到时自然就会抵消，无需再执行内存管理操作。因为<strong>自动释放池的释放操作要等到下一次事件循环时才会执行</strong>。</p>
<p>要点：</p>
<ul>
<li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正数，则对象继续存活，当保留计数将为0时，对象就被销毁了。</li>
<li>在对象生命周期中，其余对象通过引用保留或释放此对象。保留与释放操作会分别递增递减保留计数。</li>
</ul>
<h2 id="第三十条：以-ARC-简化引用计数"><a href="#第三十条：以-ARC-简化引用计数" class="headerlink" title="第三十条：以 ARC 简化引用计数"></a>第三十条：以 ARC 简化引用计数</h2><p>Clang 编译器项目带有一个“静态分析器”(static analyzer)，用于指明程序里引用计数出问题的地方。静态分析器还有更为深入的用途。它可以根据需要预先加入适当的保留或者释放操作以避免这些问题。自动引用计数这一思路正是源于此。</p>
<p>使用 ARC 时一定要记住，引用计数实际上还是要执行的，只不过保留与释放操作现在交由 ARC 自动替你添加。不过，ARC 的那些功能都是基于核心的内存管理语义而构建的，这套标准语义贯穿了整个 oc 语言。</p>
<p>由于 ARC 会自动执行 retain、release、autorelease 等操作，所以直接在 ARC 下调用这些管理方法是非法的。</p>
<p>实际上，ARC 在调用这些方法的时候，并不通过普通的 oc 消息派发机制，而是直接调用其底层 C语言版本。比方说，ARC 会调用与 retain 等价的底层函数<code>objc_retain</code>。这也是不能覆写 retain、release或 autorelease 方法的缘由，因为这些方法从来不会被直接调用。</p>
<h3 id="使用-ARC-时必须遵守的方法命名规则"><a href="#使用-ARC-时必须遵守的方法命名规则" class="headerlink" title="使用 ARC 时必须遵守的方法命名规则"></a>使用 ARC 时必须遵守的方法命名规则</h3><p>将内存管理语义在方法名中表示出来早已成为了 Objective-C 的惯例，而 ARC 则是将之确立为硬性规定。这些规则简单地体现在方法名上。若是方法名以下列词语开头，则其返回的对象归调用者所有：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>归调用者所有的意思是：调用以上述名称开头的方法的那段代码要负责释放方法所返回的对象。也就是说，<strong>这些对象的保留计数是正值，而调用了这四种方法的那段代码要将其中一次保留计数操作抵消掉。若还有其他对象保留此对象，并对其调用<code>autorelease</code>，那么引用计数值可能比1大</strong>，这也是 retainCount 方法不太有用的原因之一。(参见36条)</p>
<p><strong>若方法名不以上述四个词语开头，则表示其所返回的对象并不归调用者所有</strong>。这种情况下，<strong>返回的对象会自动释放(autorelease)</strong>，所以其在跨越方法边界之后依然有效。若想使对象多存活一段时间必须令调用者保留它才行。</p>
<p>维系规则所需的全部内存管理事宜均由 ARC 自动处理，其中也包括在将要返回的对象上调用 autorelease，如下代码演示了 ARC 的用法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (EOCPerson *)newPerson</span><br><span class="line">&#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">    <span class="comment">// 此方法以‘new’开头并跟以‘person’已经从‘alloc’中拥有了一个未平衡的 +1 引用计数，</span></span><br><span class="line">    <span class="comment">// 所以当其return的时候并不需要 retain、release或者 autorelease</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (EOCPerson *)somePerson</span><br><span class="line">&#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] init];</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">    <span class="comment">// 该方法并没有以拥有关系的方法名开头，因此 ARC 会在其 return 的时候添加 autorelease</span></span><br><span class="line">    <span class="comment">// 在 MRC 下代码因该是如此 return [person autorelease];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    EOCPerson *personOne = [EOCPerson newPerson];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EOCPerson *personTwo = [EOCPerson somePerson];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里‘personOne’和'personTwo'出了方法半边街，因此 ARC 按需求需要清除他们</span></span><br><span class="line">    <span class="comment">// personOne是被这里的代码拥有并返回的，所以它需要释放</span></span><br><span class="line">    <span class="comment">// personTwo不是被这里代码拥有只是在这里被返回的，所以它不需要释放</span></span><br><span class="line">    <span class="comment">// 在 MRC 下其等价代码如下</span></span><br><span class="line">    <span class="comment">// [personOne release];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了会自动调用 retain 和 release 方法外，使用 ARC 还有其他好处，它可以执行一些手工操作很难甚至无法完成的优化。例如，在编译期，ARC 会把能够相互抵消的 retain、release、autorelease 操作约简。如果发现在在同一个对象上执行了多次“保留”和”释放”操作，那么 ARC 有时可以成对的移除这两个操作。</p>
<p>为了优化代码，在方法返回自动释放的对象的时候，要执行一个特殊的函数。此时不直接调用 autorelease 方法，而是<strong>改用<code>objc_autoreleaseReturnValue</code>。此函数会检视当前方法返回值后即将要执行的那段代码。若发现那段代码要在返回的对象上执行 retain 操作，则设置为全局数据结构(此数据结构的具体内容因处理器而异)中的一个标志位，而不执行 autorelease。</strong>与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码需要保留此对象，那么此时<strong>不直接执行 retain，而是改为执行<code>objc_retainAutoreleasedReturnValue</code>函数。此函数需要检测刚才提到的那个标志位，如果已经置位，则不执行 retain 操作</strong>。设置并检测标志位，要比调用 autorelease 和 retain 更快。</p>
<p>将内存管理交由<strong>编译器和运行时组件</strong>来做，可以使代码得到多种优化。</p>
<h3 id="变量的内存管理语义"><a href="#变量的内存管理语义" class="headerlink" title="变量的内存管理语义"></a>变量的内存管理语义</h3><p>ARC 也会处理局部变量与实例变量的内存管理。默认情况下，每个变量都是指向对象的强引用。</p>
<p>请看如下例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setup</span><br><span class="line">&#123;</span><br><span class="line">    _obj = [EOCPerson new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在 ARC 下编译器会自动向其中添加 retain 和 release方法，如下是编译器处理后的完整代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setup</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> temp = [EOCPerson new];</span><br><span class="line">    _obj = [temp <span class="keyword">retain</span>];</span><br><span class="line">    [temp release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然在此情况下 retain 和 release 可以消去。所以 ARC 会将这两个操作简化掉。于是，实际执行的代码和原来的一样。不过在编写setter 时，使用 ARC会简单一些。如果不使用 ARC，那么需要像下面这样写:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObj:(<span class="keyword">id</span>)obj</span><br><span class="line">&#123;</span><br><span class="line">    [_obj release];</span><br><span class="line">    _obj = [obj <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样会产生一个问题，那就是如果新值和实例变量已有的值相同呢，这时候可能导致新值的引用计数变为0。但是使用了 ARC 之后这样的问题就不可能会再次出现了，ARC 下等效代码可以书写如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObj:(<span class="keyword">id</span>)obj</span><br><span class="line">&#123;</span><br><span class="line">    _obj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC 会用一种安全地方式来设置:<strong>先保留新值，然后释放旧值，最后设置实例变量</strong>。(事实上编译器在 setter 中会调用<code>objc_storeStrong</code>通过传入变量地址和新值来保留新值和释放旧值。但是请注意在 setter 中实际上会调用三次<code>objc_storeStrong</code>，第一次是通过<strong>传入形参地址和实参值来保留形式参数</strong>，第二次是通过<strong>传入实例变量地址和新值来保留新值和释放旧值</strong>，第三次则是通过<strong>传入形参地址和 nil 来释放形参</strong>)。</p>
<p>在应用程序中，可用如下修饰符改变局部和实例变量的语义:</p>
<ul>
<li>__strong:默认语义，保留此值。</li>
<li>__unsafe_unretained:不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了。</li>
<li>__weak:不保留此值，但是变量可用安全使用，因为如果系统把这个对象回收了，那么变量也会自动清空。</li>
<li>__autoreleasing:把对象“按引用传递”(pass by reference)给方法时，使用这个特殊的修饰符。此值可以再方法返回时自动释放。</li>
</ul>
<h3 id="ARC如何清理实例变量"><a href="#ARC如何清理实例变量" class="headerlink" title="ARC如何清理实例变量"></a>ARC如何清理实例变量</h3><p>在尚未使用 ARC 之前，对对象解除引用需要手动对所有的实例变量进行释放(在 dealloc 方法中)。但是在 ARC下就无需手动操作。在 ARC 中会借用Objective-C++的一项特性来清理例程。回收 Objective-C++对象时，待回收的对象会调用所有 C++对象的析构函数。<strong>编译器如果发现某个对象里含有 c++对象，就会生成名为<code>.cxx_destruct</code> 的方法。而 ARC借助此特性，在该方法中生成清理内存所需的代码</strong>。</p>
<p>不过若是包含有非 Objective-C 对象，比如 CoreFoundation 中的对象或者是由 malloc()分配在堆中的内存，那么仍需要清理。ARC 会在<code>.cxx_destruct</code>方法中生成代码并运行此方法，而在生成的代码中会自动调用超类的 <code>dealloc</code> 方法。所以在一个对象的 <code>dealloc</code>方法中不允许调用[super dealloc]方法，并且若需要释放非 Objective-C 对象的时候也需要在此释放。</p>
<p>要点：</p>
<ul>
<li>ARC 管理对象生命周期的办法基本上就是:在合适的地方插入”保留”和”释放”操作。在 ARC 环境下，变留的内存管理语义可以通过修饰符指明，而原来则需要手动执行“保留”和”释放“操作。</li>
<li>ARC 只负责 Objective-C 对象的内存管理。尤其要注意:CoreFoundation 对象不归 ARC管理，开发者必须适时调用CFRelease/CFRetain。</li>
</ul>
<h2 id="第三十一条：在-dealloc-方法中只是放引用并解除监听"><a href="#第三十一条：在-dealloc-方法中只是放引用并解除监听" class="headerlink" title="第三十一条：在 dealloc 方法中只是放引用并解除监听"></a>第三十一条：在 dealloc 方法中只是放引用并解除监听</h2><p>对象经历其生命周期后，最后会为系统所回收，这时就要执行 dealloc 方法了。在每个对象的生命周期内，此方法仅执行一次，也就是当保留计数降为0的时候。而且当 dealloc 被调用之后对象就不再有效了。</p>
<p>在 <code>dealloc</code> 中有两件事情需要做，第一件：释放对象所拥有的引用，也就是把Objective-C 对象全部释放掉，ARC 会自动生成<code>.cxx_destruct</code>方法(参见30条)，为你自动添加这些释放代码。对象所拥有的非 Objective-C 对象也需要释放。例如 CoreFoundation 对象就需要手工释放，因为它们是纯 C 的 API 所生成的。</p>
<p>第二件:把原来配置过的观测行为都处理掉。如果 NSNotificationCenter 给此对象订阅过某种通知，那么一般在这里注销。</p>
<p>注意dealloc 中不需要调用属性的存取方法，因为有人可能会覆写这些方法，并与其中添加无法在回收阶段安全执行的操作。</p>
<p>要点：</p>
<ul>
<li>在 dealloc 中需要释放对象所拥有的拥有关系，并解除 KVO 或者 NSNotificationCenter 等通知。</li>
</ul>
<h2 id="第三十二条：编写“异常安全代码”时留意内存管理问题"><a href="#第三十二条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第三十二条：编写“异常安全代码”时留意内存管理问题"></a>第三十二条：编写“异常安全代码”时留意内存管理问题</h2><p>Objective-C 的错误模型表明，<strong>异常只应该在发生严重错误后抛出</strong>(参见第21条)。</p>
<p>在 ARC 中默认不开启异常捕获(即使抛出异常时会造成内存泄漏)，因为如果开启的话会增加大量的模板代码，这非常影响运行期性能，并且在 Objective-C 中只有遇到致命错误的时候才应该抛出异常，所以 ARC 中默认不开启异常捕获。</p>
<p>如果需要异常捕获功能，则需要手动开启。需要打开编译器的<code>-fobjc-arc-exceptions</code>标志。</p>
<p>要点:</p>
<ul>
<li>捕获异常时，一定要注意将 try 块内所创立的对象清理干净。</li>
<li>在默认情况下，ARC 并不生成安全处理异常所需要的清理代码。打开编译器标志后，可以生成这种 代码，不过会导致程序变大，并且会降低运行效率。</li>
</ul>
<h2 id="第三十三条：以弱引用避免保留环"><a href="#第三十三条：以弱引用避免保留环" class="headerlink" title="第三十三条：以弱引用避免保留环"></a>第三十三条：以弱引用避免保留环</h2><p> 避免保留环的最佳方式就是弱引用。这种引用经常用来表示”非拥有关系”。将属性声明为<code>unsafe_unretained</code>即可。</p>
<p>但是<code>unsafe_unretained</code>一词表明属性值可能不安全，而且不归此实例所拥有。如果系统已经把属性对象回收了，那么继续访问这个对象可能会导致应用程序崩溃。</p>
<p><code>unsafe_unretained</code>修饰属性特质语义同 <code>assign</code>等价。然而<code>assign</code>通常只用于基础类型，而<code>unsafe_unretained</code>则用于对象类型。</p>
<p>Objective-C 中还有另一项与 ARC 相伴的运行期特性，可以令开发者安全的使用弱引用:<code>weak</code>。它与<code>unsafe_unretained</code>的作用完全相同，但是只要系统把属性回收，属性值就会自动被设置为 nil。</p>
<p>要点：</p>
<ul>
<li>将某些引用设为 weak，可避免出现“保留环”。</li>
<li>weak 可自动清空也可不清空。自动清空是伴随 ARC 引入的因特性，由运行期系统实现。</li>
</ul>
<h2 id="第三十四条：以“自动释放池块”降低内存峰值"><a href="#第三十四条：以“自动释放池块”降低内存峰值" class="headerlink" title="第三十四条：以“自动释放池块”降低内存峰值"></a>第三十四条：以“自动释放池块”降低内存峰值</h2><p>释放对象有两种方式，第一种：调用<code>release</code>方法使其保留计数立即递减。第二种：调用<code>autorelease</code>方法，将其加入自动释放池中。自动释放池会保存那些需要稍后释放的对象，并且在清空该自动释放池时，系统会向其中保存的对象发送 release 消息。</p>
<p>一般情况下无需担心自动释放池的创建问题，因为在 iOS与 mac OS X 中的 Cocoa Touch 和 Cocoa 环境中。系统会自动床创建一些线程，例如 <strong>GCD 机制中的线程，这些线程默认都拥有自动释放池，每次执行“事件循环”(Event Loop)时，就会将其清空(所以若是没有手动创建的自动释放池，那么自动释放对象会在事件循环结束之后被统一发送 release 消息。若是有手动创建的自动释放池，则是在该手动创建的自动释放池被 drain的时候为其中保存的对象发送 release 消息)。</strong></p>
<p>自动释放池可以嵌套，<strong>嵌套自动释放池的好处是:可以借此控制应用程序的内存峰值，使其不致过高。</strong></p>
<p><strong>自动释放池机制就像是“栈”(stack)一样。系统自动创建好自动释放池之后，就将其推入栈中。而清空自动释放池则是相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。</strong></p>
<p>在 ARC 中自动释放池有了新的语法@autoreleasepool{}</p>
<p>要点：</p>
<ul>
<li>自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。</li>
</ul>
<h2 id="第三十五条：用“僵尸对象”调试内存管理问题"><a href="#第三十五条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第三十五条：用“僵尸对象”调试内存管理问题"></a>第三十五条：用“僵尸对象”调试内存管理问题</h2><p>向已经回收的对象发送消息是很不安全的。有时可以那么做，有时不可以，具体取决于对象所占内存有没有为其他内容所覆写。</p>
<p>Cocoa 提供了“僵尸对象”这个非常方便的功能。启用这个功能之后，<strong>运行期系统会把所有已经回收的实例转换为“僵尸对象”，而不会真正回收它们。这种对象所在的核心内存无法重用，因此不可能遭到覆写。</strong></p>
<p>僵尸对象的原理是什么呢？它的实现代码深植与 Objective-C 的运行期程序库、Foundation 框架及 CoreFoundation 框架中。<strong>系统在即将回收对象时，如果发现通过环境变量启用了僵尸对象功能，那么还将执行一个附加步骤。这一步骤就是把对象转化为僵尸对象，而不彻底回收</strong>。</p>
<p>这个过程其实上就是 NSObject 的 dealloc 方法所做的事情。如果运行期系统发现 NSZombieEnable 环境变量已设置，则会把 dealloc 方法“调配”(swizzle。参见13条)成为另一个版本的 dealloc方法。这个新方法是将<strong>对象所属的类改为_NSZombie_OriginalClass，其中OriginalClass 指的是原类名</strong>。</p>
<p>这个新方法的关键之处在于：对象所占内存没有(通过调用 free()方法)释放，因此这块内存不可复用。因为此时是调试功能，所以这内存泄漏无关紧要。</p>
<p>但是系统为何要给每个成为僵尸的类都创建一个对应的新类呢？这是因为，给僵尸对象发消息后，系统可由此知道该对象原来所属的类。假如把所有僵尸对象都归到<code>_NSZombie_</code>类中，那原来类名就丢了。<strong>创建新类的工作由运行时函数<code>objc_duplicateClass()</code>，它会把整个<code>_NSZombie_</code>类结构拷贝一份，并赋予其新的名字。</strong>副本类的超类、实例变量及方法都和复制前相同。</p>
<p>僵尸类的作用会在消息转发例程(参见12条)中体现出来。<code>_NSZombie</code>类(以及所有从该类中拷贝出来的类)并未实现任何方法。<strong>此类没有超类，因此和 NSObject 一样，也是一个”根类”，该类只有一个实例变量isa,所有的 Objective-C 的根类都必须有此变量。</strong>由于这个轻量级的类并没实现任何的方法，所以发给它的所有消息都要经过”完整的消息转发机制”(参见12条)。</p>
<p>在完整的消息转发机制中，__forwarding__是核心，调试程序时，大家可能在栈回溯消息里看见过这个函数。它首先要做的事情就是包括检查接收消息的对象所属的类名。<strong>若名称前缀为<code>_NSZombie_</code>,则表明消息接收者是僵尸对象，需要特殊处理。此时会打印一条消息，其中指明了僵尸对象所收到的消息及原来所属的类，然后应用程序就终止了</strong>。</p>
<p>要点：</p>
<ul>
<li>系统在回收对象时，可以不将其真的回收，而是把它转换为僵尸对象。通过环境变量<code>NSZombieEnabled</code>可开启此功能。</li>
<li>系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及接收者的消息，然后终止应用程序。</li>
</ul>
<h2 id="第三十六条：不要使用-retainCount"><a href="#第三十六条：不要使用-retainCount" class="headerlink" title="第三十六条：不要使用 retainCount"></a>第三十六条：不要使用 retainCount</h2><p>此方法无用的首要原因在于：它所返回的引用计数只是某个给定时间点上的值。该方法并未考虑到系统稍后会把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样的话，此值就未必能真实反映实际的引用计数了。</p>
<p>第二个错误在于：retainCount 可能永远不返回0，因为有时系统会优化对象的释放行为，在引用计数还是 1的时候就把它回收了。只有在对象不打算这么优化，引用计数的值才会递减至0。</p>
<p><strong>系统会尽可能把 NSString 实现成单例对象，例如编译器常量，那么就可以这样来实现。</strong>这种情况下，编译器会把 NSString 对象所表示的数据放到应用程序的二进制文件里，这样的话运行程序时就可以直接用了，无需再创建 NSString 对象。NSNumber 也类似，它使用了一种叫做“标签指针”的概念来标注特定类型的数值。这种做法不适用 NSNumber 对象，而是把与数值有关的全部消息都放入指针值里。运行期系统会在消息派发期间检测这种标签指针，并对它执行相应操作，使其行为看上去和真正的 NSNumber 对象一样。这种优化只在某种场合中使用(例如保存内容为 int 的 NSNumber 对象)，而保存内容为浮点数的 NSNumber 则没有这种优化，所以其引用计数为1。</p>
<p>对于单例对象，其引用计数绝对不会改变，所以所有的保留和释放操作对于它们都是”空操作”(no-op)。</p>
<p>要点：</p>
<ul>
<li>对象的保留计数看似有用，实则不然。</li>
<li>引用 ARC 后，retainCount 就废止了。</li>
</ul>
<h1 id="第六章：块与大中枢派发"><a href="#第六章：块与大中枢派发" class="headerlink" title="第六章：块与大中枢派发"></a>第六章：块与大中枢派发</h1><h2 id="第三十七条：理解“块”这一概念"><a href="#第三十七条：理解“块”这一概念" class="headerlink" title="第三十七条：理解“块”这一概念"></a>第三十七条：理解“块”这一概念</h2><p>Block 其实就是一个值，而且自有其相关类型。block 类型的语法与函数指针近似。</p>
<p>block的语法结构如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">return_type (^block_name)(parateters)</span><br></pre></td></tr></table></figure>
<p>block 的强大之处在于：在<strong>它声明的范围内，所有变量都可以为其所捕获</strong>。</p>
<p>默认情况下，为块所捕获的变量是不可以在 block 中修改的。不过声明的时候添加上<code>__block</code>修饰符，这样就可以在 block 中修改了。</p>
<p>如果 block 捕获的变量是对象类型，那么就会自动保留它。系统在释放这个 block 的时候也会将其一并释放。block 本身也可视为对象，收到 ARC 管理，在引用计数将至0的时候，block 就回收了。同时也会释放 block 所捕获的变量，以便平衡捕获时所执行的保留操作。</p>
<p>block 总能修改实例变量，所以无需加<code>__block</code>。不过如果通过读取或写入操作捕获了实例变量，那么也会自动把 <code>self</code> 变量一并捕获，因为实例变量是与<code>self</code>所指代的实例关联在一起的。</p>
<p>记住：<code>self</code>也是一个对象，因而 block 在捕获它时也会将其保留。</p>
<h3 id="块的内部结构"><a href="#块的内部结构" class="headerlink" title="块的内部结构"></a>块的内部结构</h3><p>block 本身也是对象，在存放 block 对象的内存区域中，首个变量是指向Class 对象的指针，该指针叫做isa(参见14条)。其余内存里含有块对象正常运转所需的各种信息。详见下图内存布局:</p>
<p><img src="/2018/07/16/读书笔记-一/Block 结构.png" alt="Block结构"></p>
<p>在内存布局中，最重要的就是<code>invoke</code>变量，这是个函数指针，<strong>指向块的实现代码</strong>。函数原型至少要接受一个 <code>void*</code>型的参数，此参数代表block。block 其实就是一种代替函数指针的语法结构，原来使用函数指针时，需要用”不透明的void 指针”来传递状态。而改用块之后，则可以把原来用标准 C语言特性所编写的代码封装成简明且易用的接口。</p>
<p><code>descriptor</code>变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了<code>copy_helper</code> 和<code>dispose_helper</code>这两个辅助函数所对应的函数指针。辅助函数在拷贝及丢弃块时运行，其中会执行一些操作，比方说，前者要保留捕获的<strong>对象</strong>，而后者则将之释放。</p>
<p>块还会把它所捕获的所有变量都拷贝一份。这些拷贝是放在 <code>descriptor</code>后面，捕获了多少变量就要占用多少内存空间。请注意，<strong>拷贝的不是对象本身，而是指向这些对象的指针变量</strong>。<code>invoke</code>函数为什么要把块对象作为参数传进来呢？原因就在于，执行块时要从内存中把这些捕获到的变量读出来。</p>
<h3 id="全局块，栈块及堆块"><a href="#全局块，栈块及堆块" class="headerlink" title="全局块，栈块及堆块"></a>全局块，栈块及堆块</h3><p><strong>定义块的时候，其所占用的内存区域是分配在栈中的</strong>。我们来看如下例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (......)</span><br><span class="line">&#123;</span><br><span class="line">	block = ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Block A"</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Block B"</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在if及 else 语句中的两个块都分配在栈内存中。编译器会给每个块分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块的内存覆写掉。于是，这两个块只能保证在对应的 if 或 else 语句范围内有效。这样写出来的代码可以编译，但是运行起来可能时而正确时而错误。<strong>若编译器未覆写待执行块，则程序照常运行，若覆写，程序崩溃。</strong></p>
<p>未解决此问题，<strong>可给块对象发从<code>copy</code>消息以拷贝之。这样的话就可以把块复制到堆上了</strong>。拷贝之后的块，可以再定义它的范围之外使用。而且，<strong>一旦复制到堆上，块就成了带引用计数的对象了。后续的拷贝操作都不会真正的执行复制，只是递增块对象的引用计数。</strong>当引用计数将为0后，分配在堆上的块会像其他对象一样，被系统回收。而<strong>分配在栈上的块则无需明确释放，因为栈内存本来就会自动回收</strong>。</p>
<p>明白这一点后，我们只需要在上述代码在为 block 赋值的时候使用 <code>copy</code>拷贝即可。</p>
<p>除了堆块和栈块之外，还有一类叫做全局块。这种块<strong>不会捕捉任何状态(比如外围的变量等)，运行时业务须有状态来参与。块所使用的整个内存区域在编译期就已经完全确定了，因此全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。</strong>另外，全局块的拷贝操作是一个空操作，因为全局块决不能为系统所回收，这种块实际上相当于单例。</p>
<p>要点：</p>
<ul>
<li>块是C、C++、Objective-C 中的词法闭包。</li>
<li>块可以接受参数，也可返回值。</li>
<li>块可以分配在堆或栈上，也可以是全局的。分配在栈上的块可以拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。</li>
</ul>
<h2 id="第三十八条：为常用的块类型创建typedef"><a href="#第三十八条：为常用的块类型创建typedef" class="headerlink" title="第三十八条：为常用的块类型创建typedef"></a>第三十八条：为常用的块类型创建typedef</h2><p>为了隐藏复杂的 block 类型，需要用到 C语言中名为”类型定义”的特性。<code>typedef</code>关键字用于给类型起个易读的别名。</p>
<p>要点:</p>
<ul>
<li>以<code>typedef</code>重新定义块类型，可令块变量用起来更简单。</li>
</ul>
<h2 id="第三十九条：用-handler-块降低代码分散程度"><a href="#第三十九条：用-handler-块降低代码分散程度" class="headerlink" title="第三十九条：用 handler 块降低代码分散程度"></a>第三十九条：用 handler 块降低代码分散程度</h2><p>使用块来代替委托，可以使代码更加清晰。</p>
<h2 id="第四十条：用块引用其所属对象时不要出现保留环"><a href="#第四十条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第四十条：用块引用其所属对象时不要出现保留环"></a>第四十条：用块引用其所属对象时不要出现保留环</h2><p>要点：</p>
<ul>
<li>如果块所捕获的对象直接或者间接地保留了块本身，那么就得当心保留环。</li>
<li>一定要找一个适合的时机解除保留环，而不能把责任推给 API 的调用者。</li>
</ul>
<h2 id="第四十一条：多用派发队列，少用同步锁"><a href="#第四十一条：多用派发队列，少用同步锁" class="headerlink" title="第四十一条：多用派发队列，少用同步锁"></a>第四十一条：多用派发队列，少用同步锁</h2><p>Objective-C 中如果多个线程要同时执行一份代码，这通常需要使用锁来实现。在 GCD 诞生以前，有两种办法，第一种采用内置的“同步块”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)synchronizedMethod</span><br><span class="line">&#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        // safe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法会根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕。执行到这段代码结尾处，锁就被释放了。然而，滥用<code>@synchronized</code>会降低代码效率，因为公用锁的那些同步块，都必须按照顺序执行。</p>
<p>另一种办法就是直接是用内购<code>NSLock</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">- (void)synchronizedMethod</span><br><span class="line">&#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    // safe</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>NSRecursiveLock</code>这种”递归锁”，线程能够多次持有该锁，而不会出现死锁的现象。</p>
<p>两种方法都很好，但是都有其缺陷。比方说，在特定的情况下，同步块会造成死锁，另外，其效率也并不见得很高，而如果直接使用锁对象的话，一旦遇到死锁将会非常麻烦。</p>
<p>代替方案就是<code>GCD</code>,它能够以更简单，更高效的方式为代码加锁。“串行同步队列”将读取操作以及写入操作全部安排在同一个队列里，即可保证数据同步。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    _syncQueue = dispatch_queue_create(&quot;com.apple.syncQueue&quot;, NULL);    //NULL 表示默认串行队列</span><br><span class="line"></span><br><span class="line">- (NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">    __block NSString *localSomeString;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">        localSomeString = self-&gt;_someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    return localSomeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这模式的思路是：将存取和写入操作全部放到序列化的队列里执行，这样的话所有针对于属性的访问操作就同步了。全部加锁任务都在 GCD 中处理，而 GCD 是在相当深的底层来实现的，于是能够做许多优化。</p>
<p>然而还可以进一步优化，设置方法可以不是同步的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setSomeString:(NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(_syncQueue, ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>派发队列可用表述同步语义，这种做法要比使用<code>synchronized</code>和<code>NSLock</code>对象更简单。</li>
<li>将同步异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。</li>
<li>使用同步队列以及栅栏块，可令同步行为更加高效。</li>
</ul>
<h2 id="第四十二条：多用-GCD，少用performSelector系列方法"><a href="#第四十二条：多用-GCD，少用performSelector系列方法" class="headerlink" title="第四十二条：多用 GCD，少用performSelector系列方法"></a>第四十二条：多用 GCD，少用performSelector系列方法</h2><p><code>performSelector</code>系列方法会产生几个问题：</p>
<p>首先，编译器不知道将要调用的选择子是什么，因此也就不了解方法签名以及返回值，甚至连是否有返回值都不清楚。而且，由于编译器并不知道方法名，所以没有办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了一种谨慎的做法，就是不添加释放操作。然而这么做可能会导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<p>这个方法不甚理想，另一个原因在于：返回值只能是void 或对象类型。如果想返回 float 或者 int 等类型就要执行一些复杂的转换操作了，而这种转换很容易出错。</p>
<p>要点：</p>
<ul>
<li><code>performSelector</code>系列方法在内存管理方面有所疏忽，它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。</li>
<li><code>performSelector</code>系列方法所能处理的选择子太过于局限，选择子的返回值类型以及发送给方法的参数个数都受到限制。</li>
<li>如果想把任务放在另一个线程上执行，那么最好不要使用<code>performSelector</code>方法，而是应该将其封装到块里，然后调用大中枢派发机制的相关方法来实现。</li>
</ul>
<h2 id="第四十三条：掌握GCD-及操作队列的使用时机"><a href="#第四十三条：掌握GCD-及操作队列的使用时机" class="headerlink" title="第四十三条：掌握GCD 及操作队列的使用时机"></a>第四十三条：掌握GCD 及操作队列的使用时机</h2><p>在后台执行任务时，GCD 并不一定是最佳的方式。有一种技术叫做<code>NSOperationQueue</code>。</p>
<p>在两者诸多的差别中，首先要注意的是：GCD 是纯 C 的 API，而操作队列则是 Objective-C 的对象。在 GCD 中任务用块来表示，而块是一个轻量级数据结构。与之相反，“操作”则是一个更为重量级的 Objective-C 对象。</p>
<p>使用 NSOperation 及 NSOperationQueue 的好处如下：</p>
<ul>
<li>取消某个任务。如果使用操作队列，那么想要取消操作是很容易的。运行任务之前，可以在NSOperation对象上调用 cancel 方法，该方法会设置对象中的标志位，用以表明此任务不需要执行，不过已经启动的任务无法取消。若是使用 GCD 则无法取消。</li>
<li>指定操作间的依赖关系。一个操作可以依赖多个其他操作。</li>
<li>通过键值观测机制监控 NSOperation 对象的属性。如果想在某个人物变更其状态时(isFinished)得到通知，或是想用比 GCD 更为精细的方式来控制所要执行的任务，那么 KVO 会很有用。</li>
<li>执行操作的优先级。GCD 确实有优先级，但是那是针对队列的优先级而不是针对每个块的。</li>
</ul>
<p>NSOperation对象也有“线程优先级”，这决定了运行此操作的线程处于何种优先级上。用 GCD 也可以实现此功能，然而操作队列更加简单，只需要设置一个属性。</p>
<ul>
<li>重用 NSOperation 对象。系统内置了一些 NSOperation 的子类(例如 NSBlockOperation)供开发者使用。</li>
</ul>
<p>有一个 API 选择了操作队列而不是 GCD 队列，这就是 NSNotificationCenter。</p>
<p>要点：</p>
<ul>
<li>在解决多线程与任务管理问题时，GCD 并非唯一方案。</li>
<li>操作队列提供了一套高层的 Objective-C API，能够实现纯 GCD 所具备的绝大部分的功能，而且能完成一些更加复杂的操作。</li>
</ul>
<h2 id="第四十四条：通过-dispatch-group-机制，根据系统资源状况来执行任务"><a href="#第四十四条：通过-dispatch-group-机制，根据系统资源状况来执行任务" class="headerlink" title="第四十四条：通过 dispatch group 机制，根据系统资源状况来执行任务"></a>第四十四条：通过 dispatch group 机制，根据系统资源状况来执行任务</h2><p>dispatch group 是一项 GCD 特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时调用者会得到通知。</p>
<p>创建dispatch group ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> dispatch_group_create(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>任务编组第一种方式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line">	<span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p> 它比普通的 dispatch_async 多了一个参数用于表明待执行块所属地组。</p>
<p>任务编组第二种方式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br><span class="line"><span class="comment">/*************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure>
<p>前者使分组里正要执行的任务数量增加，后者使之递减。</p>
<p>下面这个函数用于等待 dispatch group 执行完毕:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_group_wait(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_time_t</span> timeout);</span><br></pre></td></tr></table></figure>
<p>此函数接受两个参数，第一个是要等待的group，第二个是代表等待的时间。timeout 参数表示函数在 dispatch group 执行完毕时，应该阻塞多久。如果执行 dispatch group 所需的时间小于 timeout，则返回0，否则返回非零。此参数也可以传入DISPATCH_TIME_FOREVER 表示函数一直等待 dispatch group 执行完。</p>
<p>除了可用上述函数等待 dispatch group 执行完之外，也可以换个办法，使用下列函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line">	<span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>开发者可以在此函数传入块，等 dispatch group 执行完毕之后，块会在特定线程执行。</p>
<p>为了执行队列中的块，GCD 会在适当的时候自动创建线程或者复用旧线程。如果使用并发队列，那么其中可能会有多个线程，这就意味着多个块可以并发执行。在并发队列中，执行任务所用的并发线程数量取决于各个因素，而 GCD 根据系统资源状况判断这些因素。假如 CPU 有多个核心，并且队列中有大量任务等待执行，那么 GCD 就可能会给该队列配备多个线程。</p>
<p>在队列中多次执行某项任务:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="keyword">size_t</span> iterations,</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span>  <span class="built_in">queue</span>,</span><br><span class="line">		<span class="keyword">void</span> (^block)(<span class="keyword">size_t</span>));</span><br></pre></td></tr></table></figure>
<p>此函数会将块反复执行一定的次数，每次传递给块的数值都会增加，从0开始直到iterations-1。并且dispatch_apply所用的是并发队列。</p>
<p>要点：</p>
<ul>
<li>一系列任务可以归于一个 dispatch group中。开发者可以在这组任务执行完毕时获得通知。</li>
<li>通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时 GCD 会根据系统资源状况来调度这些并发执行的任务。</li>
</ul>
<h2 id="第四十五条：使用-dispatch-once-来执行只需运行一次的线程安全代码"><a href="#第四十五条：使用-dispatch-once-来执行只需运行一次的线程安全代码" class="headerlink" title="第四十五条：使用 dispatch_once 来执行只需运行一次的线程安全代码"></a>第四十五条：使用 dispatch_once 来执行只需运行一次的线程安全代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once(<span class="keyword">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>使用dispatch_once可以简化代码，并且彻底保证线程安全。</p>
<h2 id="第四十六条：不要使用-dispatch-get-current-queue"><a href="#第四十六条：不要使用-dispatch-get-current-queue" class="headerlink" title="第四十六条：不要使用 dispatch_get_current_queue"></a>第四十六条：不要使用 dispatch_get_current_queue</h2><p>要点：</p>
<ul>
<li>dispatch_get_current_queue 函数行为常常与开发者所预期的不同，此函数已经被废弃，只应用作调试。</li>
</ul>
<h1 id="第七章：系统框架"><a href="#第七章：系统框架" class="headerlink" title="第七章：系统框架"></a>第七章：系统框架</h1><h2 id="第四十七条：熟悉系统框架"><a href="#第四十七条：熟悉系统框架" class="headerlink" title="第四十七条：熟悉系统框架"></a>第四十七条：熟悉系统框架</h2><p>将一系列代码封装成动态库，并在其中放入描述其接口的头文件，这样做出来的东西就叫做框架。</p>
<p>Foundation 框架中很多功能都可以在 CoreFoundation框架中找到对应的 C语言的实现。无缝桥接技术(tool-free bridging)可以将CoreFoundation的 C语言数据结构转换为 Foundation 中的 Objective-C 对象，也可以反向转换。无缝桥接技术使用某些相当复杂的代码实现出来的，这些代码可以使运行期系统把 CoreFoundation 框架中的对象视为普通的 Objective-C 对象。</p>
<h2 id="第四十八条：多用块枚举，少用-for-循环"><a href="#第四十八条：多用块枚举，少用-for-循环" class="headerlink" title="第四十八条：多用块枚举，少用 for 循环"></a>第四十八条：多用块枚举，少用 for 循环</h2><p>快速遍历(for-in)与使用 NSEnumerator 来遍历差不多。</p>
<p>如果某个类的对象支持快速遍历，那么就可以宣城自己遵循名为 NSFasttEnumeration 的协议，从而令开发者可以采用此语法来迭代该对象。</p>
<p>该协议只定义了一个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)countByEnumerating</span><br><span class="line">   		WithState:(NSFastEnumerationState *)state </span><br><span class="line">        objects:(id)buffer </span><br><span class="line">        count:(NSUInteger)len;</span><br></pre></td></tr></table></figure>
<p>该方法允许类实例同时返回多个对象，这就使得循环遍历操作更加高效了。</p>
<h3 id="基于块的遍历方式"><a href="#基于块的遍历方式" class="headerlink" title="基于块的遍历方式"></a>基于块的遍历方式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateObjectsUsingBlock:</span><br><span class="line">			(<span class="keyword">void</span> (^)(ObjectType obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop))block;</span><br></pre></td></tr></table></figure>
<p>在遍历数组及 set 时，每次迭代都要执行由 block 参数所传入的块，这个块有三个参数，当前迭代所针对的对象，所针对的下标，以及指向布尔值的指针。第三个参数所提供的机制，可以令开发者改变其值来终止遍历。</p>
<p>此方式还有一个好处，能够修改块的方法签名，以免进行显式类型转换操作。从效果上来讲把原本需要执行的类型转换操作交给块的方法签名来做。</p>
<p>要点：</p>
<ul>
<li>块枚举本身就能通过 GCD 来并发执行遍历操作，无需另外编写代码。</li>
</ul>
<h2 id="第四十九条：对自定义其内存你管理语义的-collection-使用无缝桥接"><a href="#第四十九条：对自定义其内存你管理语义的-collection-使用无缝桥接" class="headerlink" title="第四十九条：对自定义其内存你管理语义的 collection 使用无缝桥接"></a>第四十九条：对自定义其内存你管理语义的 collection 使用无缝桥接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *array = @[@1,@2,@3,@4,@5];</span><br><span class="line">CFArrayRef cfarray = (__bridge CFArrayRef)array;</span><br><span class="line">NSLog(@&quot;Size of array%li&quot;,CFArrayGetCount(cfarray));</span><br><span class="line">// output : Size of array = 5</span><br></pre></td></tr></table></figure>
<p>转化中的<code>__bridge</code>告诉 ARC 如何处理转换所涉及的 Objective-C 对象。<code>__bridge</code>本身的意思是：ARC 任具有这个 Objective-C 对象的所有权。而<code>__bridge_retain</code>则与之相反，意味着 ARC 将交出对象的所有权。如果是上述代码使用它来实现，那么用完数组之后需要加上 CFRelease（cfarray）以释放其内存。与之类似，反向转换可以使用<code>__bridge_transfer</code>来实现。比方说，想把<code>CFArrayRef</code>转换为<code>NSArray*</code>，并且向令 ARC 获得对象所有权，那么久可以采用此中转换方式。这三种转换被称为”桥式转换”。</p>
<p>要点：</p>
<ul>
<li>无缝桥接技术可以再 Foundation 框架中的 Objective-C 对象和 CoreFoundation 框架中的 C语言数据结构之间来回转换。</li>
<li>在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的 Objective-C collection。</li>
</ul>
<h2 id="第五十条：构建缓存首选-NSCache-而非-NSDictionary"><a href="#第五十条：构建缓存首选-NSCache-而非-NSDictionary" class="headerlink" title="第五十条：构建缓存首选 NSCache 而非 NSDictionary"></a>第五十条：构建缓存首选 NSCache 而非 NSDictionary</h2><p>NSCache 胜过 NSDictionary 之处在于，当系统资源将要耗尽时，它可以自动删减缓存。</p>
<p>NSCache并不会“拷贝”键，而是“保留”它。NSCache对象不拷贝键的原因在于：很多时候，键都是有不支持拷贝操作的对象来充当的。NSCache是线程安全的，而NSDictionary不具备此优势。</p>
<p>开发者可以操控缓存删减其内容的时机。有两个与系统资源相关的尺度可供调整，其一是缓存中的对象总数，其二是所有对象的“总开销”。</p>
<p>还有一个类叫做 NSPurgeableData，和 NSCache 搭配起来使用，效果很好。</p>
<p>要点：</p>
<ul>
<li>实现缓存时应选用 NSCache 而非NSDictionary。因为NSCache可以提供优雅的自动删减功能，而且是线程安全的，此外它与字典不同，不会拷贝键。</li>
<li>可以给NSCache对象设置上限，用以限制缓存中的对象总个数及总成本。</li>
</ul>
<h2 id="第五十一条：精简-initialize-与-load-的实现代码"><a href="#第五十一条：精简-initialize-与-load-的实现代码" class="headerlink" title="第五十一条：精简 initialize 与 load 的实现代码"></a>第五十一条：精简 initialize 与 load 的实现代码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load;</span><br></pre></td></tr></table></figure>
<p>对于加入运行期系统汇总的每一个类及分类来说，必定会调用此方法，而且仅调用一次。当包含类或分类的程序载入系统时，就会执行此方法，而这通常就是指应用启动的时候，若是为 iOS 设计的，则肯定会在此时执行。如果分类和其所属的类中都声明了 load 方法，则先调用类里的在调用分类里的。</p>
<p>load 方法的问题在于，执行该方法时，运行期系统处于“脆弱状态”。在执行子类的 load 方法前，必定会先执行所有超类的 load 方法，而如果代码还依赖了其他程序库，那么程序库里的相关类 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中各个类的载入顺序。因此，在 load 方法中使用其他类是不安全的。</p>
<p>load 并不向普通方法那样，如果某个类中没有实现 load 方法， 无论其父类或者子类实现与否，系统都不会调用。</p>
<p>而且 load 方法务必实现的精简一些，也就是要减少其所执行的操作，因为整个应用程序在执行 load 方法时都会阻塞。</p>
<p>想执行与类相关的初始化操作还有一个方法就是覆写如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)initialize;</span><br></pre></td></tr></table></figure>
<p>对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。其虽与 load 相似，但却有几个非常重要的微妙区别。首先，它是“惰性调用的”，也就是说只有当程序使用到了相关类时，才会调用。这与 load 不同，应用程序必须阻塞并等待所有类的 load 都执行完，才能继续。</p>
<p>此方法和 laod 还有一个区别，就是运行期系统在执行此方法的时候是处于正常状态。</p>
<p>最后一个区别是：initialize方法与其他消息一样，如果某个类未实现它，而其超类实现了，那么就会运行超类的实现代码。</p>
<p>要点：</p>
<ul>
<li>在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以调用此方法，类的 load 方法要被分类的 load 方法先调用。与其他方法不同，load 方法不参与覆写机制。</li>
<li>首次使用某各类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写机制，所以通常应该在里面判断当前要初始化的类是哪个类。</li>
<li>load 和initialize都应该实现的精简一点，这有助于保持应用程序的响应能力。也能减少引入“依赖环”的几率。</li>
<li>无法在编译期设定的全局常量，可以放在initialize方法里初始化。</li>
</ul>
<h2 id="第五十二条：别忘了-NSTimer-会保留目标对象"><a href="#第五十二条：别忘了-NSTimer-会保留目标对象" class="headerlink" title="第五十二条：别忘了 NSTimer 会保留目标对象"></a>第五十二条：别忘了 NSTimer 会保留目标对象</h2><p>计时器和 RunLoop相关联，运行循环到时候会触发任务。创建 NSTimer 可以将其“预先安排”在当前的运行循环中，也可以先创建好，然后由开发者自己调用。无论采用哪种方式，只有把计时器放在运行循环中，它才能正常触发任务。</p>
<p>并且计时器会保留其目标对象，等到自身失效再释放此对象。</p>
<p>要点：</p>
<ul>
<li>NSTimer 对象会保留其目标，知道计时器本身失效为止，调用 invalidate 方法可以令计时器失效，另外一次性的计时器在触发完任务之后也会失效。</li>
</ul>
]]></content>
      <tags>
        <tag>Effective Objective-C 2.0</tag>
      </tags>
  </entry>
</search>
